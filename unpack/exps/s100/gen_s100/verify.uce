
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

BAD_EVENT()
{
  MEMBER(DATA8 bad);
  UINT32 be NOENCODE
  {
     0_31: b = MATCH(0xbad00bad);
  }
  ENCODE(bad,(value=1));

}

BARRIER()
{
  UINT32 barrier NOENCODE
  {
     0_19: no;
    20_31: ba = RANGE(0xf52,0xf58);
  }
}

DUMMY()
{
  UINT32 no NOENCODE;
}

ERR_WORD_SIX()
{
  UINT32 err NOENCODE
  {
     0_31: err = MATCH(0x06000000);
  }
}

external EXT_AIDA()
;

FATIMA_VME_SCALERS()
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 sc_header NOENCODE
  {
     0_07: empty1;
     8_12: nwords;
    13_26: empty2;
    27_31: geo = MATCH(15);
  }
  list(0<=index<sc_header.nwords)
  {
    UINT32 sc_data NOENCODE
    {
       0_31: value;
    }
    ENCODE(data[index],(value=sc_data.value));

  }
  UINT32 scaler_trailer NOENCODE;
}

FEBEX_EVENT(card)
{
  MEMBER(DATA8 trig);
  MEMBER(DATA32 event_trigger_time_hi);
  MEMBER(DATA32 event_trigger_time_lo);
  MEMBER(DATA16 hit_pattern);
  MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  UINT32 sumchannel NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfpnr;
    16_23: card = MATCH(card);
    24_31: 255;
    ENCODE(trig,(value=trigger_type));
  }
  UINT32 channel_size NOENCODE
  {
     0_01: ignore;
     2_31: size;
  }
  UINT32 event_timestamp_hi NOENCODE
  {
     0_15: timestamp_hi;
    16_31: ignore;
    ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  }
  UINT32 event_timestamp_lo NOENCODE
  {
     0_31: timestamp_lo;
    ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  }
  UINT32 hp NOENCODE
  {
     0_15: hp;
    16_31: ignore;
    ENCODE(hit_pattern,(value=hp));
  }
  UINT32 deadbeef NOENCODE
  {
     0_31: 0xdeadbeef;
  }
  list(0<=index<((channel_size.size / 4) - 1))
  {
    UINT32 channelids NOENCODE
    {
       0_15: chan_ts_hi;
      16_23: channel_id_bits;
      24_31: 240;
      ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    }
    UINT32 channel_ts NOENCODE
    {
       0_31: chan_ts_lo;
      ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    }
    UINT32 chan_enrgy NOENCODE
    {
       0_23: chan_energy;
      24_29: TSF;
         30: pileup_flag;
         31: overflow_flag;
      ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    }
    UINT32 future_use NOENCODE
    {
       0_31: 0;
    }
  }
}

FEBEX_EVENT_TRACES(card)
{
  MEMBER(DATA8 trig);
  MEMBER(DATA32 event_trigger_time_hi);
  MEMBER(DATA32 event_trigger_time_lo);
  MEMBER(DATA16 hit_pattern);
  MEMBER(DATA32 num_channels_fired);
  MEMBER(DATA8 board_num);
  MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  UINT32 sumchannel NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfpnr;
    16_23: board_id = MATCH(card);
    24_31: 255;
    ENCODE(board_num,(value=board_id));
    ENCODE(trig,(value=trigger_type));
  }
  UINT32 channel_size NOENCODE
  {
     0_01: ignore;
     2_31: size;
    ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  }
  UINT32 event_timestamp_hi NOENCODE
  {
     0_15: timestamp_hi;
    16_31: ignore;
    ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  }
  UINT32 event_timestamp_lo NOENCODE
  {
     0_31: timestamp_lo;
    ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  }
  UINT32 hp NOENCODE
  {
     0_15: hp;
    16_31: ignore;
    ENCODE(hit_pattern,(value=hp));
  }
  UINT32 deadbeef NOENCODE
  {
     0_31: 0xdeadbeef;
  }
  if((sumchannel.trigger_type == 1))
  {
    list(0<=index<((channel_size.size / 4) - 1))
    {
      UINT32 channelids NOENCODE
      {
         0_15: chan_ts_hi;
        16_23: channel_id_bits;
        24_31: 240;
        ENCODE(channel_id[index],(value=channel_id_bits));
        ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      }
      UINT32 channel_ts NOENCODE
      {
         0_31: chan_ts_lo;
        ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      }
      UINT32 chan_enrgy NOENCODE
      {
         0_23: chan_energy;
        24_29: TSF;
           30: pileup_flag;
           31: overflow_flag;
        ENCODE(channel_cfd[index],(value=TSF));
        ENCODE(channel_energy[index],(value=chan_energy));
        ENCODE(pileup[index],(value=pileup_flag));
        ENCODE(overflow[index],(value=overflow_flag));
      }
      UINT32 future_use NOENCODE
      {
         0_31: 0;
      }
    }
    list(0<=index<16)
    {
      select optional
      {
        trace = TRACE(board=card);
      }
    }
  }
  else
  {
    if((sumchannel.trigger_type == 3))
    {
      several UINT32 dummy NOENCODE;
    }
  }
}

FEBEX_PADDING()
{
  UINT32 pads_data NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

MAIN_CRATE_DATA()
{
  barrier0 = BARRIER();
  v830 = VME_CAEN_V830(geom=8);
  filler0 = ZERO_FILLER();
  barrier1 = BARRIER();
  v792 = VME_CAEN_V7X5(geom=14);
  UINT32 aaahhh NOENCODE
  {
     0_31: 0xaaaa1290;
  }
  UINT32 exxxxx NOENCODE;
  barrier2 = BARRIER();
  v1290 = VME_CAEN_V1290_N();
  optional UINT32 eodb NOENCODE;
}

SPILL_OFF()
{
  MEMBER(DATA8 spilloff);
  UINT32 off1 NOENCODE
  {
     0_31: 0x4040400a;
  }
  UINT32 off2 NOENCODE
  {
     0_31: 0x4040400b;
  }
  UINT32 off3 NOENCODE
  {
     0_31: 0x4040400c;
  }
  ENCODE(spilloff,(value=1));

}

SPILL_ON()
{
  MEMBER(DATA8 spillon);
  UINT32 on NOENCODE
  {
     0_31: 0x30303030;
  }
  ENCODE(spillon,(value=1));

}

TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  time_epoch)
{
  MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  UINT32 data NOENCODE
  {
     0_27: epoch;
    28_31: 6;
    ENCODE(time_coarse APPEND_LIST,(value=0));
    ENCODE(time_fine APPEND_LIST,(value=0));
    ENCODE(time_edge APPEND_LIST,(value=0));
    ENCODE(time_channel APPEND_LIST,(value=0));
    ENCODE(time_epoch APPEND_LIST,(value=epoch));
  }
}

TAMEX4_HEADER()
{
  MEMBER(DATA16 post_trig_ns);
  MEMBER(DATA16 pre_trig_ns);
  UINT32 trigger_window NOENCODE
  {
     0_15: post_trig_ns;
    16_31: pre_trig_ns;
    ENCODE(post_trig_ns,(value=post_trig_ns));
    ENCODE(pre_trig_ns,(value=pre_trig_ns));
  }
}

TAMEX4_PADDING()
{
  UINT32 padding NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

TAMEX4_SFP(sfp,card)
{
  MEMBER(DATA16 trig);
  MEMBER(DATA32 event_size);
  MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  UINT32 indicator NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfp = MATCH(sfp);
    16_23: card = MATCH(card);
    24_31: 0;
  }
  MATCH_END;
  UINT32 data_size NOENCODE
  {
     0_31: bytes;
    ENCODE(event_size,(value=bytes));
  }
  UINT32 tdc_header NOENCODE
  {
     0_15: lec;
       16: buf_no;
    17_19: reserved;
    20_23: trigger_type;
    24_31: 170;
    ENCODE(trig,(value=trigger_type));
  }
  list(0<=i<((data_size.bytes / 4) - 3))
  {
    select
    {
      epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                time_fine=time_fine,time_edge=time_edge,
                                time_channel=time_channel,time_epoch=time_epoch);
      time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              time_fine=time_fine,time_edge=time_edge,
                              time_channel=time_channel,time_epoch=time_epoch);
    }
  }
  UINT32 error_bits NOENCODE
  {
     0_23: bits;
    24_31: 238;
  }
  UINT32 trailer NOENCODE
  {
     0_15: lec;
       16: buf_no;
    17_19: reserved;
    20_23: trigger_type;
    24_31: 187;
  }
}

TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 time_epoch)
{
  MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  UINT32 data NOENCODE
  {
     0_10: coarse;
       11: is_leading;
    12_21: fine;
    22_27: channel;
    28_31: type = CHECK(8);
    ENCODE(time_coarse APPEND_LIST,(value=coarse));
    ENCODE(time_fine APPEND_LIST,(value=fine));
    ENCODE(time_edge APPEND_LIST,(value=is_leading));
    ENCODE(time_channel APPEND_LIST,(value=channel));
    ENCODE(time_epoch APPEND_LIST,(value=0));
  }
}

TDC_DATA_V1190()
{
  MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  UINT32 tdc_data NOENCODE
  {
     0_18: tdc;
    19_25: chn;
       26: lot;
    27_31: 0;
    ENCODE(data[chn],(value=tdc));
    ENCODE(leadOrTrail[chn],(value=lot));
  }
}

TDC_DATA_V1290()
{
  MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  UINT32 tdc_data NOENCODE
  {
     0_20: tdc;
    21_25: chn;
       26: lot;
    27_31: 0;
    ENCODE(data[chn],(value=tdc));
    ENCODE(leadOrTrail[chn],(value=lot));
  }
}

TDC_ERROR()
{
  UINT32 tdc_err NOENCODE
  {
     0_14: error_flags;
    15_23: unused1;
    24_25: tdc;
       26: unused2;
    27_31: 4;
  }
}

TDC_HEADER()
{
  UINT32 tdc_header NOENCODE
  {
     0_11: bunch_id;
    12_23: event_id;
    24_25: tdc;
       26: unused;
    27_31: 1;
  }
}

TDC_TRAILER()
{
  UINT32 tdc_trailer NOENCODE
  {
     0_11: word_count;
    12_23: event_id;
    24_25: tdc;
       26: unused;
    27_31: 3;
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TIMESTAMP_WHITERABBIT_EXTENDED(id)
{
  MEMBER(DATA16 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_12: id = MATCH(id);
    13_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TPAT_CRATE_DATA()
{
  MEMBER(DATA16 tpat);
  UINT32 w1;
  UINT32 w2;
  UINT32 w3;
  UINT32 trigger_pattern
  {
     0_15: pattern;
    16_31: nothing;
    ENCODE(tpat,(value=pattern));
  }
}

TPC_CRATE_DATA()
{
  select several
  {
    barrier0 = BARRIER();
    v785 = VME_CAEN_V7X5(geom=8);
    v775 = VME_CAEN_V7X5(geom=12);
  }
  UINT32 aaahhh NOENCODE
  {
     0_31: 0xaaaa1190;
  }
  UINT32 exxxxx NOENCODE;
  barrier[2] = BARRIER();
  v1190 = VME_CAEN_V1190_N();
}

TRACE(board)
{
  MEMBER(DATA16 traces[16][4000] ZERO_SUPPRESS);
  MEMBER(DATA8 channel_id_traces[16] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_07: 52;
     8_15: other;
    16_19: board = MATCH(board);
    24_31: ch_id;
    ENCODE(channel_id_traces[ch_id],(value=ch_id));
  }
  UINT32 tracesize NOENCODE
  {
     0_31: size;
  }
  UINT32 tracehead NOENCODE
  {
     0_23: other;
    24_31: head;
  }
  list(0<=j<((tracesize.size / 4) - 2))
  {
    UINT32 channel_trace NOENCODE
    {
       0_13: data1;
      14_15: stuff1;
      16_29: data2;
      30_31: stuff2;
      ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
      ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
    }
  }
  UINT32 trace_trailer NOENCODE
  {
     0_23: notused;
    24_31: id = RANGE(176,191);
  }
}

TRIG3EVENT()
{
  UINT32 trig3 NOENCODE
  {
     0_31: 0x20202020;
  }
}

USER_CRATE_DATA()
{
  barrier0 = BARRIER();
  v830 = VME_CAEN_V830(geom=6);
  filler0 = ZERO_FILLER();
  select several
  {
    barrier1 = BARRIER();
    v775[0] = VME_CAEN_V7X5(geom=8);
    v775[1] = VME_CAEN_V7X5(geom=9);
    v785[0] = VME_CAEN_V7X5(geom=10);
    v785[1] = VME_CAEN_V7X5(geom=12);
  }
}

VME_CAEN_V1190_N()
{
  MEMBER(DATA8 geo);
  UINT32 header NOENCODE
  {
     0_04: geom;
     5_26: event_count;
    27_31: seven_f;
    ENCODE(geo,(value=geom));
  }
  if((header.seven_f != 8))
  {
    UINT32 second1 NOENCODE
    {
       0_31: 0xffffffff;
    }
    UINT32 real_header NOENCODE
    {
       0_04: geom;
       5_26: event_count;
      27_31: 8;
    }
  }
  select several
  {
    tdc_header = TDC_HEADER();
    measurement = TDC_DATA_V1190();
    tdc_error = TDC_ERROR();
    tdc_trailer = TDC_TRAILER();
  }
  optional UINT32 ext_time_tag NOENCODE
  {
     0_26: time_tag;
    27_31: 17;
  }
  UINT32 trailer NOENCODE
  {
     0_04: geom;
     5_20: word_count;
    21_23: unused;
       24: tdc_error;
       25: overflow;
       26: trigger_lost;
    27_31: whatever;
  }
  optional UINT32 eob NOENCODE;
}

VME_CAEN_V1290_N()
{
  MEMBER(DATA8 geo);
  UINT32 header NOENCODE
  {
     0_04: geom;
     5_26: event_count;
    27_31: type = MATCH(8);
    ENCODE(geo,(value=geom));
  }
  select several
  {
    tdc_header = TDC_HEADER();
    measurement = TDC_DATA_V1290();
    tdc_err = TDC_ERROR();
    tdc_trailer = TDC_TRAILER();
  }
  optional UINT32 ext_time_tag NOENCODE
  {
     0_26: time_tag;
    27_31: 17;
  }
  UINT32 trailer NOENCODE
  {
     0_04: geom;
     5_20: word_count;
    21_23: unused;
       24: tdc_error;
       25: overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1751(board)
{
  MEMBER(DATA8 board_id);
  MEMBER(DATA8 channels);
  MEMBER(DATA32 board_time);
  MEMBER(DATA32 channel_time[64] NO_INDEX_LIST);
  MEMBER(DATA16 chan_ext_time[64] NO_INDEX_LIST);
  MEMBER(DATA12 chan_fine_time[64] NO_INDEX_LIST);
  MEMBER(DATA16 qshort[64] NO_INDEX_LIST);
  MEMBER(DATA16 qlong[64] NO_INDEX_LIST);
  UINT32 board_agg_size NOENCODE
  {
     0_27: event_size;
    28_31: 10;
  }
  UINT32 board_details NOENCODE
  {
     0_07: channels;
     8_23: pattern;
    24_25: empty;
       26: board_fail;
    27_31: id = MATCH(board);
    ENCODE(channels,(value=channels));
    ENCODE(board_id,(value=id));
  }
  UINT32 board_agg_counter NOENCODE
  {
     0_22: counter;
    23_31: empty;
  }
  UINT32 board_agg_timetag NOENCODE
  {
     0_31: time_tag;
    ENCODE(board_time,(value=time_tag));
  }
  if((board_agg_size.event_size > 4))
  {
    list(0<=index<((board_agg_size.event_size - 4) / 6))
    {
      UINT32 channel_agg_size NOENCODE
      {
         0_21: size;
        22_27: empty;
        28_31: format;
      }
      UINT32 format_one NOENCODE
      {
         0_15: no_wave_samples;
        16_17: empty;
           18: ed;
        19_21: dp1;
        22_24: dp2;
        25_26: ap;
           27: es;
           28: ee;
           29: et;
           30: eq;
           31: dt;
      }
      if((channel_agg_size.format == 4))
      {
        UINT32 format_two NOENCODE
        {
           0_02: ex;
              3: pp;
              4: dm;
           5_07: interp;
           8_31: empty;
        }
        if((format_one.et == 1))
        {
          UINT32 channel_time_tag NOENCODE
          {
             0_31: time_tag;
            ENCODE(channel_time APPEND_LIST,(value=time_tag));
          }
        }
        if(((format_one.ee == 1) && (channel_agg_size.format == 4)))
        {
          if((format_two.ex == 0))
          {
            UINT32 extras NOENCODE
            {
               0_15: baseline;
              16_31: ext_time;
              ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
            }
          }
          else
          {
            if((format_two.ex == 1))
            {
              UINT32 extras NOENCODE
              {
                 0_15: flags;
                16_31: ext_time;
                ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
              }
            }
            else
            {
              if((format_two.ex == 2))
              {
                UINT32 extras NOENCODE
                {
                   0_09: fine_time;
                  10_15: flags;
                  16_31: ext_time;
                  ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
                }
              }
              else
              {
                if((format_two.ex == 4))
                {
                  UINT32 extras NOENCODE
                  {
                     0_15: baseline;
                    16_26: fine_time;
                    27_31: flags;
                    ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  }
                }
                else
                {
                  if((format_two.ex == 5))
                  {
                    UINT32 extras NOENCODE
                    {
                       0_09: midscale;
                      10_19: sazc;
                      20_29: sbzc;
                         30: pp;
                         31: dm;
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        if((format_one.et == 1))
        {
          UINT32 channel_time_tag NOENCODE
          {
             0_31: time_tag;
            ENCODE(channel_time APPEND_LIST,(value=time_tag));
          }
        }
      }
      if((format_one.eq == 1))
      {
        UINT32 qdata NOENCODE
        {
           0_14: qshort;
             15: empty;
          16_31: qlong;
          ENCODE(qshort APPEND_LIST,(value=qshort));
          ENCODE(qlong APPEND_LIST,(value=qlong));
        }
      }
    }
  }
}

VME_CAEN_V7X5(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_07: undefined;
     8_13: count;
    16_23: crate;
    24_26: 2;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
         12: overflow;
         13: underflow;
         14: valid;
         15: undefined;
      16_20: channel;
      21_23: undefined2;
      24_26: 0;
      27_31: geom;
      ENCODE(data[channel],(value=value));
    }
  }
  UINT32 eob NOENCODE
  {
     0_23: nothing;
    24_26: 4;
    27_31: id = MATCH(geom);
  }
  list(0<=i<2)
  {
    optional UINT32 eob2 NOENCODE
    {
       0_23: nothing;
      24_26: id = MATCH(6);
      27_31: geom;
    }
  }
}

VME_CAEN_V830(geom)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 header
  {
     0_15: event_number;
    16_17: ts;
    18_23: count;
    24_25: undefined;
       26: 1;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_25: value;
         26: 0;
      27_31: channel;
      ENCODE(data[channel],(value=value));
    }
  }
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

ZERO_FILLER()
{
  UINT32 filler NOENCODE
  {
     0_31: zero = MATCH(0);
  }
}

SUBEVENT(aida_subev)
{
  ts = TIMESTAMP_WHITERABBIT(id=0x700);
  external data = EXT_AIDA();
}

SUBEVENT(bgo_tamex_subevent)
{
  select optional
  {
    ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1900);
  }
  optional UINT32 be
  {
     0_31: b = MATCH(0xbad00bad);
  }
  select optional
  {
    trigger_window = TAMEX4_HEADER();
  }
  select several
  {
    padding = TAMEX4_PADDING();
  }
  select several
  {
    tamex[0] = TAMEX4_SFP(sfp=1,card=0);
    tamex[1] = TAMEX4_SFP(sfp=1,card=1);
    tamex[2] = TAMEX4_SFP(sfp=1,card=2);
  }
}

SUBEVENT(bm_subev)
{
  MEMBER(DATA32 dataS2[100000] NO_INDEX_LIST);
  MEMBER(DATA32 dataS4[100000] NO_INDEX_LIST);
  select optional
  {
    ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1700);
  }
  UINT32 headS2 NOENCODE
  {
     0_12: l_hit_ct;
    13_15: reserved;
    16_31: l_id = MATCH(0xaaaa);
  }
  list(0<=l_i<headS2.l_hit_ct)
  {
    UINT32 hit NOENCODE
    {
       0_31: data;
      ENCODE(dataS2 APPEND_LIST,(value=data));
    }
  }
  UINT32 headS4 NOENCODE
  {
     0_12: l_hit_ct;
    13_15: reserved;
    16_31: l_id = MATCH(0xbbbb);
  }
  list(0<=l_i<headS4.l_hit_ct)
  {
    UINT32 hit NOENCODE
    {
       0_31: data;
      ENCODE(dataS4 APPEND_LIST,(value=data));
    }
  }
  UINT32 trailer NOENCODE
  {
     0_15: reserved;
    16_31: l_id = MATCH(0xcccc);
  }
}

SUBEVENT(bplast_subev)
{
  select optional
  {
    ts = TIMESTAMP_WHITERABBIT(id=0x500);
  }
  select optional
  {
    trigger_window = TAMEX4_HEADER();
  }
  select several
  {
    padding = TAMEX4_PADDING();
  }
  select several
  {
    tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    tamex[4] = TAMEX4_SFP(sfp=0,card=4);
    tamex[5] = TAMEX4_SFP(sfp=0,card=5);
    tamex[6] = TAMEX4_SFP(sfp=0,card=6);
    tamex[7] = TAMEX4_SFP(sfp=0,card=7);
    tamex[8] = TAMEX4_SFP(sfp=0,card=8);
  }
}

SUBEVENT(fatima_tamex_subev)
{
  select optional
  {
    ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  }
  select optional
  {
    trigger_window = TAMEX4_HEADER();
  }
  select several
  {
    padding = TAMEX4_PADDING();
  }
  select several
  {
    tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    tamex[3] = TAMEX4_SFP(sfp=0,card=3);
  }
}

SUBEVENT(fatima_vme_subev)
{
  select optional
  {
    ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  }
  select several
  {
    error1 = ERR_WORD_SIX();
  }
  select optional
  {
    scalers = FATIMA_VME_SCALERS();
  }
  select optional
  {
    qdc1 = VME_CAEN_V1751(board=6);
  }
  select optional
  {
    qdc2 = VME_CAEN_V1751(board=7);
  }
  select optional
  {
    qdc3 = VME_CAEN_V1751(board=8);
  }
  select optional
  {
    qdc4 = VME_CAEN_V1751(board=9);
  }
  select optional
  {
    qdc5 = VME_CAEN_V1751(board=10);
  }
  select several
  {
    error2 = ERR_WORD_SIX();
  }
  select optional
  {
    tdc1 = VME_CAEN_V1290_N();
  }
  select several
  {
    error3 = ERR_WORD_SIX();
  }
  select optional
  {
    tdc2 = VME_CAEN_V1290_N();
  }
}

SUBEVENT(febex_subev)
{
  select optional
  {
    ts = TIMESTAMP_WHITERABBIT(id=0x400);
  }
  select several
  {
    padding = FEBEX_PADDING();
  }
  select several
  {
    data[0] = FEBEX_EVENT(card=0);
    data[1] = FEBEX_EVENT(card=1);
    data[2] = FEBEX_EVENT(card=2);
    data[3] = FEBEX_EVENT(card=3);
  }
}

SUBEVENT(frs_main_subev)
{
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    spill_on = SPILL_ON();
  }
  select several
  {
    spill_off = SPILL_OFF();
  }
  select optional
  {
    data = MAIN_CRATE_DATA();
  }
}

SUBEVENT(frs_tpat_subev)
{
  select optional
  {
    wr = TIMESTAMP_WHITERABBIT(id=0x100);
  }
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select optional
  {
    data = TPAT_CRATE_DATA();
  }
}

SUBEVENT(frs_tpc_subev)
{
  optional UINT32 be
  {
     0_31: b = MATCH(0xbad00bad);
  }
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    spill_on = SPILL_ON();
  }
  select several
  {
    spill_off = SPILL_OFF();
  }
  select optional
  {
    data = TPC_CRATE_DATA();
  }
}

SUBEVENT(frs_user_subev)
{
  select several
  {
    trig3 = TRIG3EVENT();
  }
  select several
  {
    spill_on = SPILL_ON();
  }
  select several
  {
    spill_off = SPILL_OFF();
  }
  select optional
  {
    data = USER_CRATE_DATA();
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  germanium = febex_subev(type=10,subtype=1,procid=60,control=20);
  fatima = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20);
  fatimavme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20);
  bplast = bplast_subev(type=10,subtype=1,procid=80,control=20);
  bgo = bgo_tamex_subevent(procid=100);
  frsmain = frs_main_subev(procid=10);
  frstpc = frs_tpc_subev(procid=20);
  frsuser = frs_user_subev(procid=30);
  frstpat = frs_tpat_subev(procid=15);
  beammonitor = bm_subev(procid=1);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(MUSIC1E1,frsuser.data.v785[0].data[0],DATA24);
SIGNAL(MUSIC1E2,frsuser.data.v785[0].data[1],DATA24);
SIGNAL(MUSIC1E3,frsuser.data.v785[0].data[2],DATA24);
SIGNAL(MUSIC1E4,frsuser.data.v785[0].data[3],DATA24);
SIGNAL(MUSIC1E5,frsuser.data.v785[0].data[4],DATA24);
SIGNAL(MUSIC1E6,frsuser.data.v785[0].data[5],DATA24);
SIGNAL(MUSIC1E7,frsuser.data.v785[0].data[6],DATA24);
SIGNAL(MUSIC1E8,frsuser.data.v785[0].data[7],DATA24);
SIGNAL(MUSIC1LOT1,frsmain.data.v1290.measurement.leadOrTrail[16],DATA8);
SIGNAL(MUSIC1LOT2,frsmain.data.v1290.measurement.leadOrTrail[17],DATA8);
SIGNAL(MUSIC1LOT3,frsmain.data.v1290.measurement.leadOrTrail[18],DATA8);
SIGNAL(MUSIC1LOT4,frsmain.data.v1290.measurement.leadOrTrail[19],DATA8);
SIGNAL(MUSIC1LOT5,frsmain.data.v1290.measurement.leadOrTrail[20],DATA8);
SIGNAL(MUSIC1LOT6,frsmain.data.v1290.measurement.leadOrTrail[21],DATA8);
SIGNAL(MUSIC1LOT7,frsmain.data.v1290.measurement.leadOrTrail[22],DATA8);
SIGNAL(MUSIC1LOT8,frsmain.data.v1290.measurement.leadOrTrail[23],DATA8);
SIGNAL(MUSIC1T1,frsmain.data.v1290.measurement.data[16],DATA24);
SIGNAL(MUSIC1T2,frsmain.data.v1290.measurement.data[17],DATA24);
SIGNAL(MUSIC1T3,frsmain.data.v1290.measurement.data[18],DATA24);
SIGNAL(MUSIC1T4,frsmain.data.v1290.measurement.data[19],DATA24);
SIGNAL(MUSIC1T5,frsmain.data.v1290.measurement.data[20],DATA24);
SIGNAL(MUSIC1T6,frsmain.data.v1290.measurement.data[21],DATA24);
SIGNAL(MUSIC1T7,frsmain.data.v1290.measurement.data[22],DATA24);
SIGNAL(MUSIC1T8,frsmain.data.v1290.measurement.data[23],DATA24);
SIGNAL(MUSIC2E1,frsuser.data.v785[0].data[8],DATA24);
SIGNAL(MUSIC2E2,frsuser.data.v785[0].data[9],DATA24);
SIGNAL(MUSIC2E3,frsuser.data.v785[0].data[10],DATA24);
SIGNAL(MUSIC2E4,frsuser.data.v785[0].data[11],DATA24);
SIGNAL(MUSIC2E5,frsuser.data.v785[0].data[12],DATA24);
SIGNAL(MUSIC2E6,frsuser.data.v785[0].data[13],DATA24);
SIGNAL(MUSIC2E7,frsuser.data.v785[0].data[14],DATA24);
SIGNAL(MUSIC2E8,frsuser.data.v785[0].data[15],DATA24);
SIGNAL(MUSIC2LOT1,frsmain.data.v1290.measurement.leadOrTrail[24],DATA8);
SIGNAL(MUSIC2LOT2,frsmain.data.v1290.measurement.leadOrTrail[25],DATA8);
SIGNAL(MUSIC2LOT3,frsmain.data.v1290.measurement.leadOrTrail[26],DATA8);
SIGNAL(MUSIC2LOT4,frsmain.data.v1290.measurement.leadOrTrail[27],DATA8);
SIGNAL(MUSIC2LOT5,frsmain.data.v1290.measurement.leadOrTrail[28],DATA8);
SIGNAL(MUSIC2LOT6,frsmain.data.v1290.measurement.leadOrTrail[29],DATA8);
SIGNAL(MUSIC2LOT7,frsmain.data.v1290.measurement.leadOrTrail[30],DATA8);
SIGNAL(MUSIC2LOT8,frsmain.data.v1290.measurement.leadOrTrail[31],DATA8);
SIGNAL(MUSIC2T1,frsmain.data.v1290.measurement.data[24],DATA24);
SIGNAL(MUSIC2T2,frsmain.data.v1290.measurement.data[25],DATA24);
SIGNAL(MUSIC2T3,frsmain.data.v1290.measurement.data[26],DATA24);
SIGNAL(MUSIC2T4,frsmain.data.v1290.measurement.data[27],DATA24);
SIGNAL(MUSIC2T5,frsmain.data.v1290.measurement.data[28],DATA24);
SIGNAL(MUSIC2T6,frsmain.data.v1290.measurement.data[29],DATA24);
SIGNAL(MUSIC2T7,frsmain.data.v1290.measurement.data[30],DATA24);
SIGNAL(MUSIC2T8,frsmain.data.v1290.measurement.data[31],DATA24);
SIGNAL(SCALERS1_1,frsmain.data.v830.data[0],DATA32);
SIGNAL(SCALERS1_10,frsmain.data.v830.data[9],DATA32);
SIGNAL(SCALERS1_11,frsmain.data.v830.data[10],DATA32);
SIGNAL(SCALERS1_12,frsmain.data.v830.data[11],DATA32);
SIGNAL(SCALERS1_13,frsmain.data.v830.data[12],DATA32);
SIGNAL(SCALERS1_14,frsmain.data.v830.data[13],DATA32);
SIGNAL(SCALERS1_15,frsmain.data.v830.data[14],DATA32);
SIGNAL(SCALERS1_16,frsmain.data.v830.data[15],DATA32);
SIGNAL(SCALERS1_17,frsmain.data.v830.data[16],DATA32);
SIGNAL(SCALERS1_18,frsmain.data.v830.data[17],DATA32);
SIGNAL(SCALERS1_19,frsmain.data.v830.data[18],DATA32);
SIGNAL(SCALERS1_2,frsmain.data.v830.data[1],DATA32);
SIGNAL(SCALERS1_20,frsmain.data.v830.data[19],DATA32);
SIGNAL(SCALERS1_21,frsmain.data.v830.data[20],DATA32);
SIGNAL(SCALERS1_22,frsmain.data.v830.data[21],DATA32);
SIGNAL(SCALERS1_23,frsmain.data.v830.data[22],DATA32);
SIGNAL(SCALERS1_24,frsmain.data.v830.data[23],DATA32);
SIGNAL(SCALERS1_25,frsmain.data.v830.data[24],DATA32);
SIGNAL(SCALERS1_26,frsmain.data.v830.data[25],DATA32);
SIGNAL(SCALERS1_27,frsmain.data.v830.data[26],DATA32);
SIGNAL(SCALERS1_28,frsmain.data.v830.data[27],DATA32);
SIGNAL(SCALERS1_29,frsmain.data.v830.data[28],DATA32);
SIGNAL(SCALERS1_3,frsmain.data.v830.data[2],DATA32);
SIGNAL(SCALERS1_30,frsmain.data.v830.data[29],DATA32);
SIGNAL(SCALERS1_31,frsmain.data.v830.data[30],DATA32);
SIGNAL(SCALERS1_32,frsmain.data.v830.data[31],DATA32);
SIGNAL(SCALERS1_4,frsmain.data.v830.data[3],DATA32);
SIGNAL(SCALERS1_5,frsmain.data.v830.data[4],DATA32);
SIGNAL(SCALERS1_6,frsmain.data.v830.data[5],DATA32);
SIGNAL(SCALERS1_7,frsmain.data.v830.data[6],DATA32);
SIGNAL(SCALERS1_8,frsmain.data.v830.data[7],DATA32);
SIGNAL(SCALERS1_9,frsmain.data.v830.data[8],DATA32);
SIGNAL(SCALERS2_1,frsuser.data.v830.data[0],DATA32);
SIGNAL(SCALERS2_10,frsuser.data.v830.data[9],DATA32);
SIGNAL(SCALERS2_11,frsuser.data.v830.data[10],DATA32);
SIGNAL(SCALERS2_12,frsuser.data.v830.data[11],DATA32);
SIGNAL(SCALERS2_13,frsuser.data.v830.data[12],DATA32);
SIGNAL(SCALERS2_14,frsuser.data.v830.data[13],DATA32);
SIGNAL(SCALERS2_15,frsuser.data.v830.data[14],DATA32);
SIGNAL(SCALERS2_16,frsuser.data.v830.data[15],DATA32);
SIGNAL(SCALERS2_17,frsuser.data.v830.data[16],DATA32);
SIGNAL(SCALERS2_18,frsuser.data.v830.data[17],DATA32);
SIGNAL(SCALERS2_19,frsuser.data.v830.data[18],DATA32);
SIGNAL(SCALERS2_2,frsuser.data.v830.data[1],DATA32);
SIGNAL(SCALERS2_20,frsuser.data.v830.data[19],DATA32);
SIGNAL(SCALERS2_21,frsuser.data.v830.data[20],DATA32);
SIGNAL(SCALERS2_22,frsuser.data.v830.data[21],DATA32);
SIGNAL(SCALERS2_23,frsuser.data.v830.data[22],DATA32);
SIGNAL(SCALERS2_24,frsuser.data.v830.data[23],DATA32);
SIGNAL(SCALERS2_25,frsuser.data.v830.data[24],DATA32);
SIGNAL(SCALERS2_26,frsuser.data.v830.data[25],DATA32);
SIGNAL(SCALERS2_27,frsuser.data.v830.data[26],DATA32);
SIGNAL(SCALERS2_28,frsuser.data.v830.data[27],DATA32);
SIGNAL(SCALERS2_29,frsuser.data.v830.data[28],DATA32);
SIGNAL(SCALERS2_3,frsuser.data.v830.data[2],DATA32);
SIGNAL(SCALERS2_30,frsuser.data.v830.data[29],DATA32);
SIGNAL(SCALERS2_31,frsuser.data.v830.data[30],DATA32);
SIGNAL(SCALERS2_32,frsuser.data.v830.data[31],DATA32);
SIGNAL(SCALERS2_4,frsuser.data.v830.data[3],DATA32);
SIGNAL(SCALERS2_5,frsuser.data.v830.data[4],DATA32);
SIGNAL(SCALERS2_6,frsuser.data.v830.data[5],DATA32);
SIGNAL(SCALERS2_7,frsuser.data.v830.data[6],DATA32);
SIGNAL(SCALERS2_8,frsuser.data.v830.data[7],DATA32);
SIGNAL(SCALERS2_9,frsuser.data.v830.data[8],DATA32);
SIGNAL(SCI_MHTDC_LOT1,frsmain.data.v1290.measurement.leadOrTrail[0],DATA8);
SIGNAL(SCI_MHTDC_LOT10,frsmain.data.v1290.measurement.leadOrTrail[9],DATA8);
SIGNAL(SCI_MHTDC_LOT11,frsmain.data.v1290.measurement.leadOrTrail[10],DATA8);
SIGNAL(SCI_MHTDC_LOT12,frsmain.data.v1290.measurement.leadOrTrail[11],DATA8);
SIGNAL(SCI_MHTDC_LOT13,frsmain.data.v1290.measurement.leadOrTrail[12],DATA8);
SIGNAL(SCI_MHTDC_LOT14,frsmain.data.v1290.measurement.leadOrTrail[13],DATA8);
SIGNAL(SCI_MHTDC_LOT15,frsmain.data.v1290.measurement.leadOrTrail[14],DATA8);
SIGNAL(SCI_MHTDC_LOT16,frsmain.data.v1290.measurement.leadOrTrail[15],DATA8);
SIGNAL(SCI_MHTDC_LOT2,frsmain.data.v1290.measurement.leadOrTrail[1],DATA8);
SIGNAL(SCI_MHTDC_LOT3,frsmain.data.v1290.measurement.leadOrTrail[2],DATA8);
SIGNAL(SCI_MHTDC_LOT4,frsmain.data.v1290.measurement.leadOrTrail[3],DATA8);
SIGNAL(SCI_MHTDC_LOT5,frsmain.data.v1290.measurement.leadOrTrail[4],DATA8);
SIGNAL(SCI_MHTDC_LOT6,frsmain.data.v1290.measurement.leadOrTrail[5],DATA8);
SIGNAL(SCI_MHTDC_LOT7,frsmain.data.v1290.measurement.leadOrTrail[6],DATA8);
SIGNAL(SCI_MHTDC_LOT8,frsmain.data.v1290.measurement.leadOrTrail[7],DATA8);
SIGNAL(SCI_MHTDC_LOT9,frsmain.data.v1290.measurement.leadOrTrail[8],DATA8);
SIGNAL(SCI_MHTDC_T1,frsmain.data.v1290.measurement.data[0],DATA24);
SIGNAL(SCI_MHTDC_T10,frsmain.data.v1290.measurement.data[9],DATA24);
SIGNAL(SCI_MHTDC_T11,frsmain.data.v1290.measurement.data[10],DATA24);
SIGNAL(SCI_MHTDC_T12,frsmain.data.v1290.measurement.data[11],DATA24);
SIGNAL(SCI_MHTDC_T13,frsmain.data.v1290.measurement.data[12],DATA24);
SIGNAL(SCI_MHTDC_T14,frsmain.data.v1290.measurement.data[13],DATA24);
SIGNAL(SCI_MHTDC_T15,frsmain.data.v1290.measurement.data[14],DATA24);
SIGNAL(SCI_MHTDC_T16,frsmain.data.v1290.measurement.data[15],DATA24);
SIGNAL(SCI_MHTDC_T2,frsmain.data.v1290.measurement.data[1],DATA24);
SIGNAL(SCI_MHTDC_T3,frsmain.data.v1290.measurement.data[2],DATA24);
SIGNAL(SCI_MHTDC_T4,frsmain.data.v1290.measurement.data[3],DATA24);
SIGNAL(SCI_MHTDC_T5,frsmain.data.v1290.measurement.data[4],DATA24);
SIGNAL(SCI_MHTDC_T6,frsmain.data.v1290.measurement.data[5],DATA24);
SIGNAL(SCI_MHTDC_T7,frsmain.data.v1290.measurement.data[6],DATA24);
SIGNAL(SCI_MHTDC_T8,frsmain.data.v1290.measurement.data[7],DATA24);
SIGNAL(SCI_MHTDC_T9,frsmain.data.v1290.measurement.data[8],DATA24);
SIGNAL(SCI_TAC_DE1,frsmain.data.v792.data[0],DATA24);
SIGNAL(SCI_TAC_DE10,frsmain.data.v792.data[9],DATA24);
SIGNAL(SCI_TAC_DE11,frsmain.data.v792.data[10],DATA24);
SIGNAL(SCI_TAC_DE12,frsmain.data.v792.data[11],DATA24);
SIGNAL(SCI_TAC_DE13,frsmain.data.v792.data[12],DATA24);
SIGNAL(SCI_TAC_DE14,frsmain.data.v792.data[13],DATA24);
SIGNAL(SCI_TAC_DE15,frsmain.data.v792.data[14],DATA24);
SIGNAL(SCI_TAC_DE16,frsmain.data.v792.data[15],DATA24);
SIGNAL(SCI_TAC_DE2,frsmain.data.v792.data[1],DATA24);
SIGNAL(SCI_TAC_DE3,frsmain.data.v792.data[2],DATA24);
SIGNAL(SCI_TAC_DE4,frsmain.data.v792.data[3],DATA24);
SIGNAL(SCI_TAC_DE5,frsmain.data.v792.data[4],DATA24);
SIGNAL(SCI_TAC_DE6,frsmain.data.v792.data[5],DATA24);
SIGNAL(SCI_TAC_DE7,frsmain.data.v792.data[6],DATA24);
SIGNAL(SCI_TAC_DE8,frsmain.data.v792.data[7],DATA24);
SIGNAL(SCI_TAC_DE9,frsmain.data.v792.data[8],DATA24);
SIGNAL(SCI_TAC_DT1,frsuser.data.v785[1].data[0],DATA24);
SIGNAL(SCI_TAC_DT10,frsuser.data.v785[1].data[9],DATA24);
SIGNAL(SCI_TAC_DT11,frsuser.data.v785[1].data[10],DATA24);
SIGNAL(SCI_TAC_DT12,frsuser.data.v785[1].data[11],DATA24);
SIGNAL(SCI_TAC_DT13,frsuser.data.v785[1].data[12],DATA24);
SIGNAL(SCI_TAC_DT14,frsuser.data.v785[1].data[13],DATA24);
SIGNAL(SCI_TAC_DT15,frsuser.data.v785[1].data[14],DATA24);
SIGNAL(SCI_TAC_DT16,frsuser.data.v785[1].data[15],DATA24);
SIGNAL(SCI_TAC_DT2,frsuser.data.v785[1].data[1],DATA24);
SIGNAL(SCI_TAC_DT3,frsuser.data.v785[1].data[2],DATA24);
SIGNAL(SCI_TAC_DT4,frsuser.data.v785[1].data[3],DATA24);
SIGNAL(SCI_TAC_DT5,frsuser.data.v785[1].data[4],DATA24);
SIGNAL(SCI_TAC_DT6,frsuser.data.v785[1].data[5],DATA24);
SIGNAL(SCI_TAC_DT7,frsuser.data.v785[1].data[6],DATA24);
SIGNAL(SCI_TAC_DT8,frsuser.data.v785[1].data[7],DATA24);
SIGNAL(SCI_TAC_DT9,frsuser.data.v785[1].data[8],DATA24);
SIGNAL(SPILL_OFF,frsmain.spill_off.spilloff,DATA8);
SIGNAL(SPILL_ON,frsmain.spill_on.spillon,DATA8);
SIGNAL(TPAT,frstpat.data.tpat,DATA16);
SIGNAL(TPC_ADC1_1,frstpc.data.v775.data[0],DATA24);
SIGNAL(TPC_ADC1_2,frstpc.data.v775.data[1],DATA24);
SIGNAL(TPC_ADC1_3,frstpc.data.v775.data[2],DATA24);
SIGNAL(TPC_ADC1_4,frstpc.data.v775.data[3],DATA24);
SIGNAL(TPC_ADC1_5,frstpc.data.v775.data[4],DATA24);
SIGNAL(TPC_ADC1_6,frstpc.data.v775.data[5],DATA24);
SIGNAL(TPC_ADC1_7,frstpc.data.v775.data[6],DATA24);
SIGNAL(TPC_ADC1_8,frstpc.data.v775.data[7],DATA24);
SIGNAL(TPC_ADC2_1,frstpc.data.v775.data[8],DATA24);
SIGNAL(TPC_ADC2_2,frstpc.data.v775.data[9],DATA24);
SIGNAL(TPC_ADC2_3,frstpc.data.v775.data[10],DATA24);
SIGNAL(TPC_ADC2_4,frstpc.data.v775.data[11],DATA24);
SIGNAL(TPC_ADC2_5,frstpc.data.v775.data[12],DATA24);
SIGNAL(TPC_ADC2_6,frstpc.data.v775.data[13],DATA24);
SIGNAL(TPC_ADC2_7,frstpc.data.v775.data[14],DATA24);
SIGNAL(TPC_ADC2_8,frstpc.data.v775.data[15],DATA24);
SIGNAL(TPC_ADC3_1,frstpc.data.v775.data[16],DATA24);
SIGNAL(TPC_ADC3_2,frstpc.data.v775.data[17],DATA24);
SIGNAL(TPC_ADC3_3,frstpc.data.v775.data[18],DATA24);
SIGNAL(TPC_ADC3_4,frstpc.data.v775.data[19],DATA24);
SIGNAL(TPC_ADC3_5,frstpc.data.v775.data[20],DATA24);
SIGNAL(TPC_ADC3_6,frstpc.data.v775.data[21],DATA24);
SIGNAL(TPC_ADC3_7,frstpc.data.v775.data[22],DATA24);
SIGNAL(TPC_ADC3_8,frstpc.data.v775.data[23],DATA24);
SIGNAL(TPC_ADC4_1,frstpc.data.v775.data[24],DATA24);
SIGNAL(TPC_ADC4_2,frstpc.data.v775.data[25],DATA24);
SIGNAL(TPC_ADC4_3,frstpc.data.v775.data[26],DATA24);
SIGNAL(TPC_ADC4_4,frstpc.data.v775.data[27],DATA24);
SIGNAL(TPC_ADC4_5,frstpc.data.v775.data[28],DATA24);
SIGNAL(TPC_ADC4_6,frstpc.data.v775.data[29],DATA24);
SIGNAL(TPC_ADC4_7,frstpc.data.v775.data[30],DATA24);
SIGNAL(TPC_ADC4_8,frstpc.data.v775.data[31],DATA24);
SIGNAL(TPC_ADC5_1,frstpc.data.v785.data[0],DATA24);
SIGNAL(TPC_ADC5_2,frstpc.data.v785.data[1],DATA24);
SIGNAL(TPC_ADC5_3,frstpc.data.v785.data[2],DATA24);
SIGNAL(TPC_ADC5_4,frstpc.data.v785.data[3],DATA24);
SIGNAL(TPC_ADC5_5,frstpc.data.v785.data[4],DATA24);
SIGNAL(TPC_ADC5_6,frstpc.data.v785.data[5],DATA24);
SIGNAL(TPC_ADC5_7,frstpc.data.v785.data[6],DATA24);
SIGNAL(TPC_ADC5_8,frstpc.data.v785.data[7],DATA24);
SIGNAL(TPC_ADC6_1,frstpc.data.v785.data[8],DATA24);
SIGNAL(TPC_ADC6_2,frstpc.data.v785.data[9],DATA24);
SIGNAL(TPC_ADC6_3,frstpc.data.v785.data[10],DATA24);
SIGNAL(TPC_ADC6_4,frstpc.data.v785.data[11],DATA24);
SIGNAL(TPC_ADC6_5,frstpc.data.v785.data[12],DATA24);
SIGNAL(TPC_ADC6_6,frstpc.data.v785.data[13],DATA24);
SIGNAL(TPC_ADC6_7,frstpc.data.v785.data[14],DATA24);
SIGNAL(TPC_ADC6_8,frstpc.data.v785.data[15],DATA24);
SIGNAL(TPC_ADC7_1,frstpc.data.v785.data[16],DATA24);
SIGNAL(TPC_ADC7_2,frstpc.data.v785.data[17],DATA24);
SIGNAL(TPC_ADC7_3,frstpc.data.v785.data[18],DATA24);
SIGNAL(TPC_ADC7_4,frstpc.data.v785.data[19],DATA24);
SIGNAL(TPC_ADC7_5,frstpc.data.v785.data[20],DATA24);
SIGNAL(TPC_ADC7_6,frstpc.data.v785.data[21],DATA24);
SIGNAL(TPC_ADC7_7,frstpc.data.v785.data[22],DATA24);
SIGNAL(TPC_ADC7_8,frstpc.data.v785.data[23],DATA24);
SIGNAL(TPC_TDC_LOT1,frstpc.data.v1190.measurement.leadOrTrail[0],DATA8);
SIGNAL(TPC_TDC_LOT10,frstpc.data.v1190.measurement.leadOrTrail[9],DATA8);
SIGNAL(TPC_TDC_LOT100,frstpc.data.v1190.measurement.leadOrTrail[99],DATA8);
SIGNAL(TPC_TDC_LOT101,frstpc.data.v1190.measurement.leadOrTrail[100],DATA8);
SIGNAL(TPC_TDC_LOT102,frstpc.data.v1190.measurement.leadOrTrail[101],DATA8);
SIGNAL(TPC_TDC_LOT103,frstpc.data.v1190.measurement.leadOrTrail[102],DATA8);
SIGNAL(TPC_TDC_LOT104,frstpc.data.v1190.measurement.leadOrTrail[103],DATA8);
SIGNAL(TPC_TDC_LOT105,frstpc.data.v1190.measurement.leadOrTrail[104],DATA8);
SIGNAL(TPC_TDC_LOT106,frstpc.data.v1190.measurement.leadOrTrail[105],DATA8);
SIGNAL(TPC_TDC_LOT107,frstpc.data.v1190.measurement.leadOrTrail[106],DATA8);
SIGNAL(TPC_TDC_LOT108,frstpc.data.v1190.measurement.leadOrTrail[107],DATA8);
SIGNAL(TPC_TDC_LOT109,frstpc.data.v1190.measurement.leadOrTrail[108],DATA8);
SIGNAL(TPC_TDC_LOT11,frstpc.data.v1190.measurement.leadOrTrail[10],DATA8);
SIGNAL(TPC_TDC_LOT110,frstpc.data.v1190.measurement.leadOrTrail[109],DATA8);
SIGNAL(TPC_TDC_LOT111,frstpc.data.v1190.measurement.leadOrTrail[110],DATA8);
SIGNAL(TPC_TDC_LOT112,frstpc.data.v1190.measurement.leadOrTrail[111],DATA8);
SIGNAL(TPC_TDC_LOT113,frstpc.data.v1190.measurement.leadOrTrail[112],DATA8);
SIGNAL(TPC_TDC_LOT114,frstpc.data.v1190.measurement.leadOrTrail[113],DATA8);
SIGNAL(TPC_TDC_LOT115,frstpc.data.v1190.measurement.leadOrTrail[114],DATA8);
SIGNAL(TPC_TDC_LOT116,frstpc.data.v1190.measurement.leadOrTrail[115],DATA8);
SIGNAL(TPC_TDC_LOT117,frstpc.data.v1190.measurement.leadOrTrail[116],DATA8);
SIGNAL(TPC_TDC_LOT118,frstpc.data.v1190.measurement.leadOrTrail[117],DATA8);
SIGNAL(TPC_TDC_LOT119,frstpc.data.v1190.measurement.leadOrTrail[118],DATA8);
SIGNAL(TPC_TDC_LOT12,frstpc.data.v1190.measurement.leadOrTrail[11],DATA8);
SIGNAL(TPC_TDC_LOT120,frstpc.data.v1190.measurement.leadOrTrail[119],DATA8);
SIGNAL(TPC_TDC_LOT121,frstpc.data.v1190.measurement.leadOrTrail[120],DATA8);
SIGNAL(TPC_TDC_LOT122,frstpc.data.v1190.measurement.leadOrTrail[121],DATA8);
SIGNAL(TPC_TDC_LOT123,frstpc.data.v1190.measurement.leadOrTrail[122],DATA8);
SIGNAL(TPC_TDC_LOT124,frstpc.data.v1190.measurement.leadOrTrail[123],DATA8);
SIGNAL(TPC_TDC_LOT125,frstpc.data.v1190.measurement.leadOrTrail[124],DATA8);
SIGNAL(TPC_TDC_LOT126,frstpc.data.v1190.measurement.leadOrTrail[125],DATA8);
SIGNAL(TPC_TDC_LOT127,frstpc.data.v1190.measurement.leadOrTrail[126],DATA8);
SIGNAL(TPC_TDC_LOT128,frstpc.data.v1190.measurement.leadOrTrail[127],DATA8);
SIGNAL(TPC_TDC_LOT13,frstpc.data.v1190.measurement.leadOrTrail[12],DATA8);
SIGNAL(TPC_TDC_LOT14,frstpc.data.v1190.measurement.leadOrTrail[13],DATA8);
SIGNAL(TPC_TDC_LOT15,frstpc.data.v1190.measurement.leadOrTrail[14],DATA8);
SIGNAL(TPC_TDC_LOT16,frstpc.data.v1190.measurement.leadOrTrail[15],DATA8);
SIGNAL(TPC_TDC_LOT17,frstpc.data.v1190.measurement.leadOrTrail[16],DATA8);
SIGNAL(TPC_TDC_LOT18,frstpc.data.v1190.measurement.leadOrTrail[17],DATA8);
SIGNAL(TPC_TDC_LOT19,frstpc.data.v1190.measurement.leadOrTrail[18],DATA8);
SIGNAL(TPC_TDC_LOT2,frstpc.data.v1190.measurement.leadOrTrail[1],DATA8);
SIGNAL(TPC_TDC_LOT20,frstpc.data.v1190.measurement.leadOrTrail[19],DATA8);
SIGNAL(TPC_TDC_LOT21,frstpc.data.v1190.measurement.leadOrTrail[20],DATA8);
SIGNAL(TPC_TDC_LOT22,frstpc.data.v1190.measurement.leadOrTrail[21],DATA8);
SIGNAL(TPC_TDC_LOT23,frstpc.data.v1190.measurement.leadOrTrail[22],DATA8);
SIGNAL(TPC_TDC_LOT24,frstpc.data.v1190.measurement.leadOrTrail[23],DATA8);
SIGNAL(TPC_TDC_LOT25,frstpc.data.v1190.measurement.leadOrTrail[24],DATA8);
SIGNAL(TPC_TDC_LOT26,frstpc.data.v1190.measurement.leadOrTrail[25],DATA8);
SIGNAL(TPC_TDC_LOT27,frstpc.data.v1190.measurement.leadOrTrail[26],DATA8);
SIGNAL(TPC_TDC_LOT28,frstpc.data.v1190.measurement.leadOrTrail[27],DATA8);
SIGNAL(TPC_TDC_LOT29,frstpc.data.v1190.measurement.leadOrTrail[28],DATA8);
SIGNAL(TPC_TDC_LOT3,frstpc.data.v1190.measurement.leadOrTrail[2],DATA8);
SIGNAL(TPC_TDC_LOT30,frstpc.data.v1190.measurement.leadOrTrail[29],DATA8);
SIGNAL(TPC_TDC_LOT31,frstpc.data.v1190.measurement.leadOrTrail[30],DATA8);
SIGNAL(TPC_TDC_LOT32,frstpc.data.v1190.measurement.leadOrTrail[31],DATA8);
SIGNAL(TPC_TDC_LOT33,frstpc.data.v1190.measurement.leadOrTrail[32],DATA8);
SIGNAL(TPC_TDC_LOT34,frstpc.data.v1190.measurement.leadOrTrail[33],DATA8);
SIGNAL(TPC_TDC_LOT35,frstpc.data.v1190.measurement.leadOrTrail[34],DATA8);
SIGNAL(TPC_TDC_LOT36,frstpc.data.v1190.measurement.leadOrTrail[35],DATA8);
SIGNAL(TPC_TDC_LOT37,frstpc.data.v1190.measurement.leadOrTrail[36],DATA8);
SIGNAL(TPC_TDC_LOT38,frstpc.data.v1190.measurement.leadOrTrail[37],DATA8);
SIGNAL(TPC_TDC_LOT39,frstpc.data.v1190.measurement.leadOrTrail[38],DATA8);
SIGNAL(TPC_TDC_LOT4,frstpc.data.v1190.measurement.leadOrTrail[3],DATA8);
SIGNAL(TPC_TDC_LOT40,frstpc.data.v1190.measurement.leadOrTrail[39],DATA8);
SIGNAL(TPC_TDC_LOT41,frstpc.data.v1190.measurement.leadOrTrail[40],DATA8);
SIGNAL(TPC_TDC_LOT42,frstpc.data.v1190.measurement.leadOrTrail[41],DATA8);
SIGNAL(TPC_TDC_LOT43,frstpc.data.v1190.measurement.leadOrTrail[42],DATA8);
SIGNAL(TPC_TDC_LOT44,frstpc.data.v1190.measurement.leadOrTrail[43],DATA8);
SIGNAL(TPC_TDC_LOT45,frstpc.data.v1190.measurement.leadOrTrail[44],DATA8);
SIGNAL(TPC_TDC_LOT46,frstpc.data.v1190.measurement.leadOrTrail[45],DATA8);
SIGNAL(TPC_TDC_LOT47,frstpc.data.v1190.measurement.leadOrTrail[46],DATA8);
SIGNAL(TPC_TDC_LOT48,frstpc.data.v1190.measurement.leadOrTrail[47],DATA8);
SIGNAL(TPC_TDC_LOT49,frstpc.data.v1190.measurement.leadOrTrail[48],DATA8);
SIGNAL(TPC_TDC_LOT5,frstpc.data.v1190.measurement.leadOrTrail[4],DATA8);
SIGNAL(TPC_TDC_LOT50,frstpc.data.v1190.measurement.leadOrTrail[49],DATA8);
SIGNAL(TPC_TDC_LOT51,frstpc.data.v1190.measurement.leadOrTrail[50],DATA8);
SIGNAL(TPC_TDC_LOT52,frstpc.data.v1190.measurement.leadOrTrail[51],DATA8);
SIGNAL(TPC_TDC_LOT53,frstpc.data.v1190.measurement.leadOrTrail[52],DATA8);
SIGNAL(TPC_TDC_LOT54,frstpc.data.v1190.measurement.leadOrTrail[53],DATA8);
SIGNAL(TPC_TDC_LOT55,frstpc.data.v1190.measurement.leadOrTrail[54],DATA8);
SIGNAL(TPC_TDC_LOT56,frstpc.data.v1190.measurement.leadOrTrail[55],DATA8);
SIGNAL(TPC_TDC_LOT57,frstpc.data.v1190.measurement.leadOrTrail[56],DATA8);
SIGNAL(TPC_TDC_LOT58,frstpc.data.v1190.measurement.leadOrTrail[57],DATA8);
SIGNAL(TPC_TDC_LOT59,frstpc.data.v1190.measurement.leadOrTrail[58],DATA8);
SIGNAL(TPC_TDC_LOT6,frstpc.data.v1190.measurement.leadOrTrail[5],DATA8);
SIGNAL(TPC_TDC_LOT60,frstpc.data.v1190.measurement.leadOrTrail[59],DATA8);
SIGNAL(TPC_TDC_LOT61,frstpc.data.v1190.measurement.leadOrTrail[60],DATA8);
SIGNAL(TPC_TDC_LOT62,frstpc.data.v1190.measurement.leadOrTrail[61],DATA8);
SIGNAL(TPC_TDC_LOT63,frstpc.data.v1190.measurement.leadOrTrail[62],DATA8);
SIGNAL(TPC_TDC_LOT64,frstpc.data.v1190.measurement.leadOrTrail[63],DATA8);
SIGNAL(TPC_TDC_LOT65,frstpc.data.v1190.measurement.leadOrTrail[64],DATA8);
SIGNAL(TPC_TDC_LOT66,frstpc.data.v1190.measurement.leadOrTrail[65],DATA8);
SIGNAL(TPC_TDC_LOT67,frstpc.data.v1190.measurement.leadOrTrail[66],DATA8);
SIGNAL(TPC_TDC_LOT68,frstpc.data.v1190.measurement.leadOrTrail[67],DATA8);
SIGNAL(TPC_TDC_LOT69,frstpc.data.v1190.measurement.leadOrTrail[68],DATA8);
SIGNAL(TPC_TDC_LOT7,frstpc.data.v1190.measurement.leadOrTrail[6],DATA8);
SIGNAL(TPC_TDC_LOT70,frstpc.data.v1190.measurement.leadOrTrail[69],DATA8);
SIGNAL(TPC_TDC_LOT71,frstpc.data.v1190.measurement.leadOrTrail[70],DATA8);
SIGNAL(TPC_TDC_LOT72,frstpc.data.v1190.measurement.leadOrTrail[71],DATA8);
SIGNAL(TPC_TDC_LOT73,frstpc.data.v1190.measurement.leadOrTrail[72],DATA8);
SIGNAL(TPC_TDC_LOT74,frstpc.data.v1190.measurement.leadOrTrail[73],DATA8);
SIGNAL(TPC_TDC_LOT75,frstpc.data.v1190.measurement.leadOrTrail[74],DATA8);
SIGNAL(TPC_TDC_LOT76,frstpc.data.v1190.measurement.leadOrTrail[75],DATA8);
SIGNAL(TPC_TDC_LOT77,frstpc.data.v1190.measurement.leadOrTrail[76],DATA8);
SIGNAL(TPC_TDC_LOT78,frstpc.data.v1190.measurement.leadOrTrail[77],DATA8);
SIGNAL(TPC_TDC_LOT79,frstpc.data.v1190.measurement.leadOrTrail[78],DATA8);
SIGNAL(TPC_TDC_LOT8,frstpc.data.v1190.measurement.leadOrTrail[7],DATA8);
SIGNAL(TPC_TDC_LOT80,frstpc.data.v1190.measurement.leadOrTrail[79],DATA8);
SIGNAL(TPC_TDC_LOT81,frstpc.data.v1190.measurement.leadOrTrail[80],DATA8);
SIGNAL(TPC_TDC_LOT82,frstpc.data.v1190.measurement.leadOrTrail[81],DATA8);
SIGNAL(TPC_TDC_LOT83,frstpc.data.v1190.measurement.leadOrTrail[82],DATA8);
SIGNAL(TPC_TDC_LOT84,frstpc.data.v1190.measurement.leadOrTrail[83],DATA8);
SIGNAL(TPC_TDC_LOT85,frstpc.data.v1190.measurement.leadOrTrail[84],DATA8);
SIGNAL(TPC_TDC_LOT86,frstpc.data.v1190.measurement.leadOrTrail[85],DATA8);
SIGNAL(TPC_TDC_LOT87,frstpc.data.v1190.measurement.leadOrTrail[86],DATA8);
SIGNAL(TPC_TDC_LOT88,frstpc.data.v1190.measurement.leadOrTrail[87],DATA8);
SIGNAL(TPC_TDC_LOT89,frstpc.data.v1190.measurement.leadOrTrail[88],DATA8);
SIGNAL(TPC_TDC_LOT9,frstpc.data.v1190.measurement.leadOrTrail[8],DATA8);
SIGNAL(TPC_TDC_LOT90,frstpc.data.v1190.measurement.leadOrTrail[89],DATA8);
SIGNAL(TPC_TDC_LOT91,frstpc.data.v1190.measurement.leadOrTrail[90],DATA8);
SIGNAL(TPC_TDC_LOT92,frstpc.data.v1190.measurement.leadOrTrail[91],DATA8);
SIGNAL(TPC_TDC_LOT93,frstpc.data.v1190.measurement.leadOrTrail[92],DATA8);
SIGNAL(TPC_TDC_LOT94,frstpc.data.v1190.measurement.leadOrTrail[93],DATA8);
SIGNAL(TPC_TDC_LOT95,frstpc.data.v1190.measurement.leadOrTrail[94],DATA8);
SIGNAL(TPC_TDC_LOT96,frstpc.data.v1190.measurement.leadOrTrail[95],DATA8);
SIGNAL(TPC_TDC_LOT97,frstpc.data.v1190.measurement.leadOrTrail[96],DATA8);
SIGNAL(TPC_TDC_LOT98,frstpc.data.v1190.measurement.leadOrTrail[97],DATA8);
SIGNAL(TPC_TDC_LOT99,frstpc.data.v1190.measurement.leadOrTrail[98],DATA8);
SIGNAL(TPC_TDC_T1,frstpc.data.v1190.measurement.data[0],DATA24);
SIGNAL(TPC_TDC_T10,frstpc.data.v1190.measurement.data[9],DATA24);
SIGNAL(TPC_TDC_T100,frstpc.data.v1190.measurement.data[99],DATA24);
SIGNAL(TPC_TDC_T101,frstpc.data.v1190.measurement.data[100],DATA24);
SIGNAL(TPC_TDC_T102,frstpc.data.v1190.measurement.data[101],DATA24);
SIGNAL(TPC_TDC_T103,frstpc.data.v1190.measurement.data[102],DATA24);
SIGNAL(TPC_TDC_T104,frstpc.data.v1190.measurement.data[103],DATA24);
SIGNAL(TPC_TDC_T105,frstpc.data.v1190.measurement.data[104],DATA24);
SIGNAL(TPC_TDC_T106,frstpc.data.v1190.measurement.data[105],DATA24);
SIGNAL(TPC_TDC_T107,frstpc.data.v1190.measurement.data[106],DATA24);
SIGNAL(TPC_TDC_T108,frstpc.data.v1190.measurement.data[107],DATA24);
SIGNAL(TPC_TDC_T109,frstpc.data.v1190.measurement.data[108],DATA24);
SIGNAL(TPC_TDC_T11,frstpc.data.v1190.measurement.data[10],DATA24);
SIGNAL(TPC_TDC_T110,frstpc.data.v1190.measurement.data[109],DATA24);
SIGNAL(TPC_TDC_T111,frstpc.data.v1190.measurement.data[110],DATA24);
SIGNAL(TPC_TDC_T112,frstpc.data.v1190.measurement.data[111],DATA24);
SIGNAL(TPC_TDC_T113,frstpc.data.v1190.measurement.data[112],DATA24);
SIGNAL(TPC_TDC_T114,frstpc.data.v1190.measurement.data[113],DATA24);
SIGNAL(TPC_TDC_T115,frstpc.data.v1190.measurement.data[114],DATA24);
SIGNAL(TPC_TDC_T116,frstpc.data.v1190.measurement.data[115],DATA24);
SIGNAL(TPC_TDC_T117,frstpc.data.v1190.measurement.data[116],DATA24);
SIGNAL(TPC_TDC_T118,frstpc.data.v1190.measurement.data[117],DATA24);
SIGNAL(TPC_TDC_T119,frstpc.data.v1190.measurement.data[118],DATA24);
SIGNAL(TPC_TDC_T12,frstpc.data.v1190.measurement.data[11],DATA24);
SIGNAL(TPC_TDC_T120,frstpc.data.v1190.measurement.data[119],DATA24);
SIGNAL(TPC_TDC_T121,frstpc.data.v1190.measurement.data[120],DATA24);
SIGNAL(TPC_TDC_T122,frstpc.data.v1190.measurement.data[121],DATA24);
SIGNAL(TPC_TDC_T123,frstpc.data.v1190.measurement.data[122],DATA24);
SIGNAL(TPC_TDC_T124,frstpc.data.v1190.measurement.data[123],DATA24);
SIGNAL(TPC_TDC_T125,frstpc.data.v1190.measurement.data[124],DATA24);
SIGNAL(TPC_TDC_T126,frstpc.data.v1190.measurement.data[125],DATA24);
SIGNAL(TPC_TDC_T127,frstpc.data.v1190.measurement.data[126],DATA24);
SIGNAL(TPC_TDC_T128,frstpc.data.v1190.measurement.data[127],DATA24);
SIGNAL(TPC_TDC_T13,frstpc.data.v1190.measurement.data[12],DATA24);
SIGNAL(TPC_TDC_T14,frstpc.data.v1190.measurement.data[13],DATA24);
SIGNAL(TPC_TDC_T15,frstpc.data.v1190.measurement.data[14],DATA24);
SIGNAL(TPC_TDC_T16,frstpc.data.v1190.measurement.data[15],DATA24);
SIGNAL(TPC_TDC_T17,frstpc.data.v1190.measurement.data[16],DATA24);
SIGNAL(TPC_TDC_T18,frstpc.data.v1190.measurement.data[17],DATA24);
SIGNAL(TPC_TDC_T19,frstpc.data.v1190.measurement.data[18],DATA24);
SIGNAL(TPC_TDC_T2,frstpc.data.v1190.measurement.data[1],DATA24);
SIGNAL(TPC_TDC_T20,frstpc.data.v1190.measurement.data[19],DATA24);
SIGNAL(TPC_TDC_T21,frstpc.data.v1190.measurement.data[20],DATA24);
SIGNAL(TPC_TDC_T22,frstpc.data.v1190.measurement.data[21],DATA24);
SIGNAL(TPC_TDC_T23,frstpc.data.v1190.measurement.data[22],DATA24);
SIGNAL(TPC_TDC_T24,frstpc.data.v1190.measurement.data[23],DATA24);
SIGNAL(TPC_TDC_T25,frstpc.data.v1190.measurement.data[24],DATA24);
SIGNAL(TPC_TDC_T26,frstpc.data.v1190.measurement.data[25],DATA24);
SIGNAL(TPC_TDC_T27,frstpc.data.v1190.measurement.data[26],DATA24);
SIGNAL(TPC_TDC_T28,frstpc.data.v1190.measurement.data[27],DATA24);
SIGNAL(TPC_TDC_T29,frstpc.data.v1190.measurement.data[28],DATA24);
SIGNAL(TPC_TDC_T3,frstpc.data.v1190.measurement.data[2],DATA24);
SIGNAL(TPC_TDC_T30,frstpc.data.v1190.measurement.data[29],DATA24);
SIGNAL(TPC_TDC_T31,frstpc.data.v1190.measurement.data[30],DATA24);
SIGNAL(TPC_TDC_T32,frstpc.data.v1190.measurement.data[31],DATA24);
SIGNAL(TPC_TDC_T33,frstpc.data.v1190.measurement.data[32],DATA24);
SIGNAL(TPC_TDC_T34,frstpc.data.v1190.measurement.data[33],DATA24);
SIGNAL(TPC_TDC_T35,frstpc.data.v1190.measurement.data[34],DATA24);
SIGNAL(TPC_TDC_T36,frstpc.data.v1190.measurement.data[35],DATA24);
SIGNAL(TPC_TDC_T37,frstpc.data.v1190.measurement.data[36],DATA24);
SIGNAL(TPC_TDC_T38,frstpc.data.v1190.measurement.data[37],DATA24);
SIGNAL(TPC_TDC_T39,frstpc.data.v1190.measurement.data[38],DATA24);
SIGNAL(TPC_TDC_T4,frstpc.data.v1190.measurement.data[3],DATA24);
SIGNAL(TPC_TDC_T40,frstpc.data.v1190.measurement.data[39],DATA24);
SIGNAL(TPC_TDC_T41,frstpc.data.v1190.measurement.data[40],DATA24);
SIGNAL(TPC_TDC_T42,frstpc.data.v1190.measurement.data[41],DATA24);
SIGNAL(TPC_TDC_T43,frstpc.data.v1190.measurement.data[42],DATA24);
SIGNAL(TPC_TDC_T44,frstpc.data.v1190.measurement.data[43],DATA24);
SIGNAL(TPC_TDC_T45,frstpc.data.v1190.measurement.data[44],DATA24);
SIGNAL(TPC_TDC_T46,frstpc.data.v1190.measurement.data[45],DATA24);
SIGNAL(TPC_TDC_T47,frstpc.data.v1190.measurement.data[46],DATA24);
SIGNAL(TPC_TDC_T48,frstpc.data.v1190.measurement.data[47],DATA24);
SIGNAL(TPC_TDC_T49,frstpc.data.v1190.measurement.data[48],DATA24);
SIGNAL(TPC_TDC_T5,frstpc.data.v1190.measurement.data[4],DATA24);
SIGNAL(TPC_TDC_T50,frstpc.data.v1190.measurement.data[49],DATA24);
SIGNAL(TPC_TDC_T51,frstpc.data.v1190.measurement.data[50],DATA24);
SIGNAL(TPC_TDC_T52,frstpc.data.v1190.measurement.data[51],DATA24);
SIGNAL(TPC_TDC_T53,frstpc.data.v1190.measurement.data[52],DATA24);
SIGNAL(TPC_TDC_T54,frstpc.data.v1190.measurement.data[53],DATA24);
SIGNAL(TPC_TDC_T55,frstpc.data.v1190.measurement.data[54],DATA24);
SIGNAL(TPC_TDC_T56,frstpc.data.v1190.measurement.data[55],DATA24);
SIGNAL(TPC_TDC_T57,frstpc.data.v1190.measurement.data[56],DATA24);
SIGNAL(TPC_TDC_T58,frstpc.data.v1190.measurement.data[57],DATA24);
SIGNAL(TPC_TDC_T59,frstpc.data.v1190.measurement.data[58],DATA24);
SIGNAL(TPC_TDC_T6,frstpc.data.v1190.measurement.data[5],DATA24);
SIGNAL(TPC_TDC_T60,frstpc.data.v1190.measurement.data[59],DATA24);
SIGNAL(TPC_TDC_T61,frstpc.data.v1190.measurement.data[60],DATA24);
SIGNAL(TPC_TDC_T62,frstpc.data.v1190.measurement.data[61],DATA24);
SIGNAL(TPC_TDC_T63,frstpc.data.v1190.measurement.data[62],DATA24);
SIGNAL(TPC_TDC_T64,frstpc.data.v1190.measurement.data[63],DATA24);
SIGNAL(TPC_TDC_T65,frstpc.data.v1190.measurement.data[64],DATA24);
SIGNAL(TPC_TDC_T66,frstpc.data.v1190.measurement.data[65],DATA24);
SIGNAL(TPC_TDC_T67,frstpc.data.v1190.measurement.data[66],DATA24);
SIGNAL(TPC_TDC_T68,frstpc.data.v1190.measurement.data[67],DATA24);
SIGNAL(TPC_TDC_T69,frstpc.data.v1190.measurement.data[68],DATA24);
SIGNAL(TPC_TDC_T7,frstpc.data.v1190.measurement.data[6],DATA24);
SIGNAL(TPC_TDC_T70,frstpc.data.v1190.measurement.data[69],DATA24);
SIGNAL(TPC_TDC_T71,frstpc.data.v1190.measurement.data[70],DATA24);
SIGNAL(TPC_TDC_T72,frstpc.data.v1190.measurement.data[71],DATA24);
SIGNAL(TPC_TDC_T73,frstpc.data.v1190.measurement.data[72],DATA24);
SIGNAL(TPC_TDC_T74,frstpc.data.v1190.measurement.data[73],DATA24);
SIGNAL(TPC_TDC_T75,frstpc.data.v1190.measurement.data[74],DATA24);
SIGNAL(TPC_TDC_T76,frstpc.data.v1190.measurement.data[75],DATA24);
SIGNAL(TPC_TDC_T77,frstpc.data.v1190.measurement.data[76],DATA24);
SIGNAL(TPC_TDC_T78,frstpc.data.v1190.measurement.data[77],DATA24);
SIGNAL(TPC_TDC_T79,frstpc.data.v1190.measurement.data[78],DATA24);
SIGNAL(TPC_TDC_T8,frstpc.data.v1190.measurement.data[7],DATA24);
SIGNAL(TPC_TDC_T80,frstpc.data.v1190.measurement.data[79],DATA24);
SIGNAL(TPC_TDC_T81,frstpc.data.v1190.measurement.data[80],DATA24);
SIGNAL(TPC_TDC_T82,frstpc.data.v1190.measurement.data[81],DATA24);
SIGNAL(TPC_TDC_T83,frstpc.data.v1190.measurement.data[82],DATA24);
SIGNAL(TPC_TDC_T84,frstpc.data.v1190.measurement.data[83],DATA24);
SIGNAL(TPC_TDC_T85,frstpc.data.v1190.measurement.data[84],DATA24);
SIGNAL(TPC_TDC_T86,frstpc.data.v1190.measurement.data[85],DATA24);
SIGNAL(TPC_TDC_T87,frstpc.data.v1190.measurement.data[86],DATA24);
SIGNAL(TPC_TDC_T88,frstpc.data.v1190.measurement.data[87],DATA24);
SIGNAL(TPC_TDC_T89,frstpc.data.v1190.measurement.data[88],DATA24);
SIGNAL(TPC_TDC_T9,frstpc.data.v1190.measurement.data[8],DATA24);
SIGNAL(TPC_TDC_T90,frstpc.data.v1190.measurement.data[89],DATA24);
SIGNAL(TPC_TDC_T91,frstpc.data.v1190.measurement.data[90],DATA24);
SIGNAL(TPC_TDC_T92,frstpc.data.v1190.measurement.data[91],DATA24);
SIGNAL(TPC_TDC_T93,frstpc.data.v1190.measurement.data[92],DATA24);
SIGNAL(TPC_TDC_T94,frstpc.data.v1190.measurement.data[93],DATA24);
SIGNAL(TPC_TDC_T95,frstpc.data.v1190.measurement.data[94],DATA24);
SIGNAL(TPC_TDC_T96,frstpc.data.v1190.measurement.data[95],DATA24);
SIGNAL(TPC_TDC_T97,frstpc.data.v1190.measurement.data[96],DATA24);
SIGNAL(TPC_TDC_T98,frstpc.data.v1190.measurement.data[97],DATA24);
SIGNAL(TPC_TDC_T99,frstpc.data.v1190.measurement.data[98],DATA24);
SIGNAL(WR_ID,frstpat.wr.subsystem_id,DATA12);
SIGNAL(WR_T1,frstpat.wr.t1,DATA16);
SIGNAL(WR_T2,frstpat.wr.t2,DATA16);
SIGNAL(WR_T3,frstpat.wr.t3,DATA16);
SIGNAL(WR_T4,frstpat.wr.t4,DATA16);
SIGNAL( ZERO_SUPPRESS_MULTI(128):MUSIC1_LOT_8);
SIGNAL( ZERO_SUPPRESS_MULTI(128):MUSIC1_T_8);
SIGNAL( ZERO_SUPPRESS:MUSIC2_E_8);
SIGNAL( ZERO_SUPPRESS_MULTI(128):MUSIC2_LOT_8);
SIGNAL( ZERO_SUPPRESS_MULTI(128):MUSIC2_T_8);
SIGNAL( ZERO_SUPPRESS:SCALERS2_32);
SIGNAL( ZERO_SUPPRESS_MULTI(128):SCI_MHTDC_LOT_16);
SIGNAL( ZERO_SUPPRESS_MULTI(128):SCI_MHTDC_T_16);
SIGNAL( ZERO_SUPPRESS:SCI_TAC_DE_16);
SIGNAL( ZERO_SUPPRESS:SCI_TAC_DT_16);
SIGNAL( ZERO_SUPPRESS:TPC_ADC7_32);
SIGNAL( ZERO_SUPPRESS_MULTI(128):TPC_TDC_LOT_128);
SIGNAL( ZERO_SUPPRESS_MULTI(128):TPC_TDC_T_128);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: BAD_EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for BAD_EVENT.
 *
 * Do not edit - automatically generated.
 */

// BAD_EVENT()
#if !PACKER_CODE
# define DECLARED_UNPACK_BAD_EVENT
class BAD_EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_BAD_EVENT
class PACKER_BAD_EVENT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 bad);
  DATA8 bad;
  // UINT32 be NOENCODE
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  // ENCODE(bad,(value=1));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(BAD_EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for BAD_EVENT.
 *
 * Do not edit - automatically generated.
 */

// BAD_EVENT()
template<typename __data_src_t>
void BAD_EVENT::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "BAD_EVENT",CT_OUT(NORM));
  }
  // MEMBER(DATA8 bad);
  // UINT32 be NOENCODE
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 b : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 b : 32; // 0..31
#endif
    };
    uint32  u32;
  } be;
  READ_FROM_BUFFER_FULL(14,uint32 ,be,be.u32,0);
  CHECK_BITS_EQUAL(13,be.b,0xbad00bad);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: be ", CT_OUT(BOLD), be.u32, CT_OUT(NORM));
    printf(".b=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  be.b, CT_OUT(NORM));
    printf("\n");
  }
  // ENCODE(bad,(value=1));

  {
    bad.value = 1;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,BAD_EVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for BAD_EVENT.
 *
 * Do not edit - automatically generated.
 */

// BAD_EVENT()
template<typename __data_src_t>
bool BAD_EVENT::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 bad);
  // UINT32 be NOENCODE
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 b : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 b : 32; // 0..31
#endif
    };
    uint32  u32;
  } be;
  MATCH_READ_FROM_BUFFER_FULL(14,uint32 ,be,be.u32,1);
  MATCH_BITS_EQUAL(13,be.b,0xbad00bad);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,BAD_EVENT::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for BAD_EVENT.
 *
 * Do not edit - automatically generated.
 */

// BAD_EVENT()
template<typename __data_dest_t>
void PACKER_BAD_EVENT::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 bad);
  // UINT32 be NOENCODE
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  // ENCODE(bad,(value=1));

}
FORCE_IMPL_DATA_SRC_FCN(void,BAD_EVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: BARRIER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
#if !PACKER_CODE
# define DECLARED_UNPACK_BARRIER
class BARRIER
#else//PACKER_CODE
# define DECLARED_PACKER_BARRIER
class PACKER_BARRIER
#endif//PACKER_CODE

{
public:
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(BARRIER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_src_t>
void BARRIER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "BARRIER",CT_OUT(NORM));
  }
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 no : 20; // 0..19
      uint32 ba : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ba : 12; // 20..31
      uint32 no : 20; // 0..19
#endif
    };
    uint32  u32;
  } barrier;
  READ_FROM_BUFFER_FULL(25,uint32 ,barrier,barrier.u32,2);
  CHECK_BITS_RANGE(24,barrier.ba,0xf52,0xf58);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: barrier ", CT_OUT(BOLD), barrier.u32, CT_OUT(NORM));
    printf(".no=%s%5" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  barrier.no, CT_OUT(NORM));
    printf(".ba=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  barrier.ba, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,BARRIER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_src_t>
bool BARRIER::__match(__data_src_t &__buffer)
{
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 no : 20; // 0..19
      uint32 ba : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ba : 12; // 20..31
      uint32 no : 20; // 0..19
#endif
    };
    uint32  u32;
  } barrier;
  MATCH_READ_FROM_BUFFER_FULL(25,uint32 ,barrier,barrier.u32,3);
  MATCH_BITS_RANGE(24,barrier.ba,0xf52,0xf58);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,BARRIER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_dest_t>
void PACKER_BARRIER::__packer(__data_dest_t &__buffer)
{
  // UINT32 barrier NOENCODE
  // {
    //  0_19: no;
    // 20_31: ba = RANGE(0xf52,0xf58);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,BARRIER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: DUMMY
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
#if !PACKER_CODE
# define DECLARED_UNPACK_DUMMY
class DUMMY
#else//PACKER_CODE
# define DECLARED_PACKER_DUMMY
class PACKER_DUMMY
#endif//PACKER_CODE

{
public:
  // UINT32 no NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(DUMMY);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_src_t>
void DUMMY::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "DUMMY",CT_OUT(NORM));
  }
  // UINT32 no NOENCODE;
  uint32  no;READ_FROM_BUFFER(30,uint32 ,no,4);
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_src_t>
bool DUMMY::__match(__data_src_t &__buffer)
{
  // UINT32 no NOENCODE;
  uint32  no;
  MATCH_READ_FROM_BUFFER(30,uint32 ,no,5);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,DUMMY::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// DUMMY()
template<typename __data_dest_t>
void PACKER_DUMMY::__packer(__data_dest_t &__buffer)
{
  // UINT32 no NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: ERR_WORD_SIX
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for ERR_WORD_SIX.
 *
 * Do not edit - automatically generated.
 */

// ERR_WORD_SIX()
#if !PACKER_CODE
# define DECLARED_UNPACK_ERR_WORD_SIX
class ERR_WORD_SIX
#else//PACKER_CODE
# define DECLARED_PACKER_ERR_WORD_SIX
class PACKER_ERR_WORD_SIX
#endif//PACKER_CODE

{
public:
  // UINT32 err NOENCODE
  // {
    //  0_31: err = MATCH(0x06000000);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(ERR_WORD_SIX);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for ERR_WORD_SIX.
 *
 * Do not edit - automatically generated.
 */

// ERR_WORD_SIX()
template<typename __data_src_t>
void ERR_WORD_SIX::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "ERR_WORD_SIX",CT_OUT(NORM));
  }
  // UINT32 err NOENCODE
  // {
    //  0_31: err = MATCH(0x06000000);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 err : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 err : 32; // 0..31
#endif
    };
    uint32  u32;
  } err;
  READ_FROM_BUFFER_FULL(38,uint32 ,err,err.u32,6);
  CHECK_BITS_EQUAL(37,err.err,0x06000000);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: err ", CT_OUT(BOLD), err.u32, CT_OUT(NORM));
    printf(".err=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  err.err, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,ERR_WORD_SIX::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for ERR_WORD_SIX.
 *
 * Do not edit - automatically generated.
 */

// ERR_WORD_SIX()
template<typename __data_src_t>
bool ERR_WORD_SIX::__match(__data_src_t &__buffer)
{
  // UINT32 err NOENCODE
  // {
    //  0_31: err = MATCH(0x06000000);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 err : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 err : 32; // 0..31
#endif
    };
    uint32  u32;
  } err;
  MATCH_READ_FROM_BUFFER_FULL(38,uint32 ,err,err.u32,7);
  MATCH_BITS_EQUAL(37,err.err,0x06000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,ERR_WORD_SIX::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for ERR_WORD_SIX.
 *
 * Do not edit - automatically generated.
 */

// ERR_WORD_SIX()
template<typename __data_dest_t>
void PACKER_ERR_WORD_SIX::__packer(__data_dest_t &__buffer)
{
  // UINT32 err NOENCODE
  // {
    //  0_31: err = MATCH(0x06000000);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,ERR_WORD_SIX::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: EXT_AIDA
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_AIDA.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: FATIMA_VME_SCALERS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FATIMA_VME_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME_SCALERS()
#if !PACKER_CODE
# define DECLARED_UNPACK_FATIMA_VME_SCALERS
class FATIMA_VME_SCALERS
#else//PACKER_CODE
# define DECLARED_PACKER_FATIMA_VME_SCALERS
class PACKER_FATIMA_VME_SCALERS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 sc_header NOENCODE
  // {
    //  0_07: empty1;
    //  8_12: nwords;
    // 13_26: empty2;
    // 27_31: geo = MATCH(15);
  // }
  // list(0<=index<sc_header.nwords)

    // UINT32 sc_data NOENCODE
    // {
      //  0_31: value;
    // }
    // ENCODE(data[index],(value=sc_data.value));

  // UINT32 scaler_trailer NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FATIMA_VME_SCALERS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FATIMA_VME_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME_SCALERS()
template<typename __data_src_t>
void FATIMA_VME_SCALERS::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FATIMA_VME_SCALERS",CT_OUT(NORM));
  }
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 sc_header NOENCODE
  // {
    //  0_07: empty1;
    //  8_12: nwords;
    // 13_26: empty2;
    // 27_31: geo = MATCH(15);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 empty1 : 8; // 0..7
      uint32 nwords : 5; // 8..12
      uint32 empty2 : 14; // 13..26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 empty2 : 14; // 13..26
      uint32 nwords : 5; // 8..12
      uint32 empty1 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sc_header;
  READ_FROM_BUFFER_FULL(53,uint32 ,sc_header,sc_header.u32,8);
  CHECK_BITS_EQUAL(52,sc_header.geo,15);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: sc_header ", CT_OUT(BOLD), sc_header.u32, CT_OUT(NORM));
    printf(".empty1=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sc_header.empty1, CT_OUT(NORM));
    printf(".nwords=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sc_header.nwords, CT_OUT(NORM));
    printf(".empty2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sc_header.empty2, CT_OUT(NORM));
    printf(".geo=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sc_header.geo, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<sc_header.nwords)

  for (uint32 index = 0; index < (uint32) (sc_header.nwords); ++index)
  {
    // UINT32 sc_data NOENCODE
    // {
      //  0_31: value;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } sc_data;
    READ_FROM_BUFFER_FULL(59,uint32 ,sc_data,sc_data.u32,9);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: sc_data ", CT_OUT(BOLD), sc_data.u32, CT_OUT(NORM));
      printf(".value=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sc_data.value, CT_OUT(NORM));
      printf("\n");
    }
    // ENCODE(data[index],(value=sc_data.value));

    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(60,index);
      __item.value = sc_data.value;
    }
  }
  // UINT32 scaler_trailer NOENCODE;
  uint32  scaler_trailer;READ_FROM_BUFFER(63,uint32 ,scaler_trailer,10);
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_VME_SCALERS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FATIMA_VME_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME_SCALERS()
template<typename __data_src_t>
bool FATIMA_VME_SCALERS::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 sc_header NOENCODE
  // {
    //  0_07: empty1;
    //  8_12: nwords;
    // 13_26: empty2;
    // 27_31: geo = MATCH(15);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 empty1 : 8; // 0..7
      uint32 nwords : 5; // 8..12
      uint32 empty2 : 14; // 13..26
      uint32 geo : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geo : 5; // 27..31
      uint32 empty2 : 14; // 13..26
      uint32 nwords : 5; // 8..12
      uint32 empty1 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sc_header;
  MATCH_READ_FROM_BUFFER_FULL(53,uint32 ,sc_header,sc_header.u32,11);
  MATCH_BITS_EQUAL(52,sc_header.geo,15);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FATIMA_VME_SCALERS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FATIMA_VME_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// FATIMA_VME_SCALERS()
template<typename __data_dest_t>
void PACKER_FATIMA_VME_SCALERS::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 sc_header NOENCODE
  // {
    //  0_07: empty1;
    //  8_12: nwords;
    // 13_26: empty2;
    // 27_31: geo = MATCH(15);
  // }
  // list(0<=index<sc_header.nwords)

  {
    // UINT32 sc_data NOENCODE
    // {
      //  0_31: value;
    // }
    // ENCODE(data[index],(value=sc_data.value));

  }
  // UINT32 scaler_trailer NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,FATIMA_VME_SCALERS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_EVENT
class FEBEX_EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_EVENT
class PACKER_FEBEX_EVENT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 trig);
  DATA8 trig;
  // MEMBER(DATA32 event_trigger_time_hi);
  DATA32 event_trigger_time_hi;
  // MEMBER(DATA32 event_trigger_time_lo);
  DATA32 event_trigger_time_lo;
  // MEMBER(DATA16 hit_pattern);
  DATA16 hit_pattern;
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,16> channel_trigger_time_hi;
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_trigger_time_lo;
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> pileup;
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> overflow;
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_cfd;
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_energy;
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
    // ENCODE(trig,(value=trigger_type));
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // list(0<=index<((channel_size.size / 4) - 1))

    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    // }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    // }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      // ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      // ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      // ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    // }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
template<typename __data_src_t>
void FEBEX_EVENT::__unpack(__data_src_t &__buffer,uint32 card)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FEBEX_EVENT",CT_OUT(NORM));
  }
  // MEMBER(DATA8 trig);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
    // ENCODE(trig,(value=trigger_type));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  READ_FROM_BUFFER_FULL(86,uint32 ,sumchannel,sumchannel.u32,12);
  CHECK_BITS_EQUAL(80,sumchannel.unnamed_0_7,52);
  CHECK_BITS_EQUAL(83,sumchannel.card,card);
  CHECK_BITS_EQUAL(84,sumchannel.unnamed_24_31,255);
  {
    trig.value = sumchannel.trigger_type;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: sumchannel ", CT_OUT(BOLD), sumchannel.u32, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.trigger_type, CT_OUT(NORM));
    printf(".sfpnr=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.sfpnr, CT_OUT(NORM));
    printf(".card=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.card, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ignore : 2; // 0..1
      uint32 size : 30; // 2..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 30; // 2..31
      uint32 ignore : 2; // 0..1
#endif
    };
    uint32  u32;
  } channel_size;
  READ_FROM_BUFFER_FULL(91,uint32 ,channel_size,channel_size.u32,13);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: channel_size ", CT_OUT(BOLD), channel_size.u32, CT_OUT(NORM));
    printf(".ignore=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.ignore, CT_OUT(NORM));
    printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.size, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_hi : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 timestamp_hi : 16; // 0..15
#endif
    };
    uint32  u32;
  } event_timestamp_hi;
  READ_FROM_BUFFER_FULL(97,uint32 ,event_timestamp_hi,event_timestamp_hi.u32,14);
  {
    event_trigger_time_hi.value = event_timestamp_hi.timestamp_hi;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_hi ", CT_OUT(BOLD), event_timestamp_hi.u32, CT_OUT(NORM));
    printf(".timestamp_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.timestamp_hi, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
    };
    uint32  u32;
  } event_timestamp_lo;
  READ_FROM_BUFFER_FULL(102,uint32 ,event_timestamp_lo,event_timestamp_lo.u32,15);
  {
    event_trigger_time_lo.value = event_timestamp_lo.timestamp_lo;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_lo ", CT_OUT(BOLD), event_timestamp_lo.u32, CT_OUT(NORM));
    printf(".timestamp_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_lo.timestamp_lo, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 hp : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 hp : 16; // 0..15
#endif
    };
    uint32  u32;
  } hp;
  READ_FROM_BUFFER_FULL(108,uint32 ,hp,hp.u32,16);
  {
    hit_pattern.value = hp.hp;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: hp ", CT_OUT(BOLD), hp.u32, CT_OUT(NORM));
    printf(".hp=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.hp, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } deadbeef;
  READ_FROM_BUFFER_FULL(112,uint32 ,deadbeef,deadbeef.u32,17);
  CHECK_BITS_EQUAL(111,deadbeef.unnamed_0_31,0xdeadbeef);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: deadbeef ", CT_OUT(BOLD), deadbeef.u32, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<((channel_size.size / 4) - 1))

  for (uint32 index = 0; index < (uint32) (((channel_size.size / 4) - 1)); ++index)
  {
    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_ts_hi : 16; // 0..15
        uint32 channel_id_bits : 8; // 16..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 channel_id_bits : 8; // 16..23
        uint32 chan_ts_hi : 16; // 0..15
#endif
      };
      uint32  u32;
    } channelids;
    READ_FROM_BUFFER_FULL(121,uint32 ,channelids,channelids.u32,18);
    CHECK_BITS_EQUAL(119,channelids.unnamed_24_31,240);
    {
      typedef __typeof__(*(&(channel_trigger_time_hi))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = channel_trigger_time_hi.insert_index(120,channelids.channel_id_bits);
      __item.value = channelids.chan_ts_hi;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: channelids ", CT_OUT(BOLD), channelids.u32, CT_OUT(NORM));
      printf(".chan_ts_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.chan_ts_hi, CT_OUT(NORM));
      printf(".channel_id_bits=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.channel_id_bits, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_ts_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 chan_ts_lo : 32; // 0..31
#endif
      };
      uint32  u32;
    } channel_ts;
    READ_FROM_BUFFER_FULL(126,uint32 ,channel_ts,channel_ts.u32,19);
    {
      typedef __typeof__(*(&(channel_trigger_time_lo))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = channel_trigger_time_lo.insert_index(125,channelids.channel_id_bits);
      __item.value = channel_ts.chan_ts_lo;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: channel_ts ", CT_OUT(BOLD), channel_ts.u32, CT_OUT(NORM));
      printf(".chan_ts_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_ts.chan_ts_lo, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      // ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      // ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      // ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 chan_energy : 24; // 0..23
        uint32 TSF : 6; // 24..29
        uint32 pileup_flag : 1; // 30
        uint32 overflow_flag : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow_flag : 1; // 31
        uint32 pileup_flag : 1; // 30
        uint32 TSF : 6; // 24..29
        uint32 chan_energy : 24; // 0..23
#endif
      };
      uint32  u32;
    } chan_enrgy;
    READ_FROM_BUFFER_FULL(137,uint32 ,chan_enrgy,chan_enrgy.u32,20);
    {
      {
        typedef __typeof__(*(&(channel_cfd))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_cfd.insert_index(133,channelids.channel_id_bits);
        __item.value = chan_enrgy.TSF;
      }
      {
        typedef __typeof__(*(&(channel_energy))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_energy.insert_index(134,channelids.channel_id_bits);
        __item.value = chan_enrgy.chan_energy;
      }
      {
        typedef __typeof__(*(&(pileup))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = pileup.insert_index(135,channelids.channel_id_bits);
        __item.value = chan_enrgy.pileup_flag;
      }
      {
        typedef __typeof__(*(&(overflow))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = overflow.insert_index(136,channelids.channel_id_bits);
        __item.value = chan_enrgy.overflow_flag;
      }
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: chan_enrgy ", CT_OUT(BOLD), chan_enrgy.u32, CT_OUT(NORM));
      printf(".chan_energy=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.chan_energy, CT_OUT(NORM));
      printf(".TSF=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.TSF, CT_OUT(NORM));
      printf(".pileup_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.pileup_flag, CT_OUT(NORM));
      printf(".overflow_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.overflow_flag, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } future_use;
    READ_FROM_BUFFER_FULL(141,uint32 ,future_use,future_use.u32,21);
    CHECK_BITS_EQUAL(140,future_use.unnamed_0_31,0);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: future_use ", CT_OUT(BOLD), future_use.u32, CT_OUT(NORM));
      printf("\n");
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT::__unpack,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
template<typename __data_src_t>
bool FEBEX_EVENT::__match(__data_src_t &__buffer,uint32 card)
{
  // MEMBER(DATA8 trig);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
    // ENCODE(trig,(value=trigger_type));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  MATCH_READ_FROM_BUFFER_FULL(86,uint32 ,sumchannel,sumchannel.u32,22);
  MATCH_BITS_EQUAL(80,sumchannel.unnamed_0_7,52);
  MATCH_BITS_EQUAL(83,sumchannel.card,card);
  MATCH_BITS_EQUAL(84,sumchannel.unnamed_24_31,255);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FEBEX_EVENT::__match,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_EVENT.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT(card)
template<typename __data_dest_t>
void PACKER_FEBEX_EVENT::__packer(__data_dest_t &__buffer,uint32 card)
{
  // MEMBER(DATA8 trig);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: card = MATCH(card);
    // 24_31: 255;
    // ENCODE(trig,(value=trigger_type));
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // list(0<=index<((channel_size.size / 4) - 1))

  {
    // UINT32 channelids NOENCODE
    // {
      //  0_15: chan_ts_hi;
      // 16_23: channel_id_bits;
      // 24_31: 240;
      // ENCODE(channel_trigger_time_hi[channelids.channel_id_bits],(value=chan_ts_hi));
    // }
    // UINT32 channel_ts NOENCODE
    // {
      //  0_31: chan_ts_lo;
      // ENCODE(channel_trigger_time_lo[channelids.channel_id_bits],(value=chan_ts_lo));
    // }
    // UINT32 chan_enrgy NOENCODE
    // {
      //  0_23: chan_energy;
      // 24_29: TSF;
      //    30: pileup_flag;
      //    31: overflow_flag;
      // ENCODE(channel_cfd[channelids.channel_id_bits],(value=TSF));
      // ENCODE(channel_energy[channelids.channel_id_bits],(value=chan_energy));
      // ENCODE(pileup[channelids.channel_id_bits],(value=pileup_flag));
      // ENCODE(overflow[channelids.channel_id_bits],(value=overflow_flag));
    // }
    // UINT32 future_use NOENCODE
    // {
      //  0_31: 0;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT::__packer,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_EVENT_TRACES
//
//
// Generating code for: TRACE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRACE.
 *
 * Do not edit - automatically generated.
 */

// TRACE(board)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRACE
class TRACE
#else//PACKER_CODE
# define DECLARED_PACKER_TRACE
class PACKER_TRACE
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 traces[16][4000] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,4000> traces[16];
  // MEMBER(DATA8 channel_id_traces[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_id_traces;
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_15: other;
    // 16_19: board = MATCH(board);
    // 24_31: ch_id;
    // ENCODE(channel_id_traces[ch_id],(value=ch_id));
  // }
  // UINT32 tracesize NOENCODE
  // {
    //  0_31: size;
  // }
  // UINT32 tracehead NOENCODE
  // {
    //  0_23: other;
    // 24_31: head;
  // }
  // list(0<=j<((tracesize.size / 4) - 2))

    // UINT32 channel_trace NOENCODE
    // {
      //  0_13: data1;
      // 14_15: stuff1;
      // 16_29: data2;
      // 30_31: stuff2;
      // ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
      // ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
    // }
  // UINT32 trace_trailer NOENCODE
  // {
    //  0_23: notused;
    // 24_31: id = RANGE(176,191);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 board);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 board);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 board);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRACE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRACE.
 *
 * Do not edit - automatically generated.
 */

// TRACE(board)
template<typename __data_src_t>
void TRACE::__unpack(__data_src_t &__buffer,uint32 board)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TRACE",CT_OUT(NORM));
  }
  // MEMBER(DATA16 traces[16][4000] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_id_traces[16] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_15: other;
    // 16_19: board = MATCH(board);
    // 24_31: ch_id;
    // ENCODE(channel_id_traces[ch_id],(value=ch_id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 other : 8; // 8..15
      uint32 board : 4; // 16..19
      uint32 dummy_20_23 : 4;
      uint32 ch_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ch_id : 8; // 24..31
      uint32 dummy_20_23 : 4;
      uint32 board : 4; // 16..19
      uint32 other : 8; // 8..15
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(619,uint32 ,header,header.u32,23);
  CHECK_BITS_EQUAL(614,header.unnamed_0_7,52);
  CHECK_BITS_EQUAL(616,header.board,board);
  CHECK_UNNAMED_BITS_ZERO(619,header.u32,0x00f00000);
  {
    typedef __typeof__(*(&(channel_id_traces))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = channel_id_traces.insert_index(618,header.ch_id);
    __item.value = header.ch_id;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".other=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.other, CT_OUT(NORM));
    printf(".board=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.board, CT_OUT(NORM));
    printf(".ch_id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.ch_id, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 tracesize NOENCODE
  // {
    //  0_31: size;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 32; // 0..31
#endif
    };
    uint32  u32;
  } tracesize;
  READ_FROM_BUFFER_FULL(623,uint32 ,tracesize,tracesize.u32,24);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tracesize ", CT_OUT(BOLD), tracesize.u32, CT_OUT(NORM));
    printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracesize.size, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 tracehead NOENCODE
  // {
    //  0_23: other;
    // 24_31: head;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 other : 24; // 0..23
      uint32 head : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 head : 8; // 24..31
      uint32 other : 24; // 0..23
#endif
    };
    uint32  u32;
  } tracehead;
  READ_FROM_BUFFER_FULL(628,uint32 ,tracehead,tracehead.u32,25);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tracehead ", CT_OUT(BOLD), tracehead.u32, CT_OUT(NORM));
    printf(".other=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracehead.other, CT_OUT(NORM));
    printf(".head=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tracehead.head, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=j<((tracesize.size / 4) - 2))

  for (uint32 j = 0; j < (uint32) (((tracesize.size / 4) - 2)); ++j)
  {
    // UINT32 channel_trace NOENCODE
    // {
      //  0_13: data1;
      // 14_15: stuff1;
      // 16_29: data2;
      // 30_31: stuff2;
      // ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
      // ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 data1 : 14; // 0..13
        uint32 stuff1 : 2; // 14..15
        uint32 data2 : 14; // 16..29
        uint32 stuff2 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 stuff2 : 2; // 30..31
        uint32 data2 : 14; // 16..29
        uint32 stuff1 : 2; // 14..15
        uint32 data1 : 14; // 0..13
#endif
      };
      uint32  u32;
    } channel_trace;
    READ_FROM_BUFFER_FULL(639,uint32 ,channel_trace,channel_trace.u32,26);
    {
      {
        typedef __typeof__(*(&(traces[header.ch_id]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = traces[header.ch_id].insert_index(637,((2 * j) + 0));
        __item.value = channel_trace.data1;
      }
      {
        typedef __typeof__(*(&(traces[header.ch_id]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = traces[header.ch_id].insert_index(638,((2 * j) + 1));
        __item.value = channel_trace.data2;
      }
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: channel_trace ", CT_OUT(BOLD), channel_trace.u32, CT_OUT(NORM));
      printf(".data1=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.data1, CT_OUT(NORM));
      printf(".stuff1=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.stuff1, CT_OUT(NORM));
      printf(".data2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.data2, CT_OUT(NORM));
      printf(".stuff2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_trace.stuff2, CT_OUT(NORM));
      printf("\n");
    }
  }
  // UINT32 trace_trailer NOENCODE
  // {
    //  0_23: notused;
    // 24_31: id = RANGE(176,191);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 notused : 24; // 0..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 notused : 24; // 0..23
#endif
    };
    uint32  u32;
  } trace_trailer;
  READ_FROM_BUFFER_FULL(645,uint32 ,trace_trailer,trace_trailer.u32,27);
  CHECK_BITS_RANGE(644,trace_trailer.id,176,191);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trace_trailer ", CT_OUT(BOLD), trace_trailer.u32, CT_OUT(NORM));
    printf(".notused=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trace_trailer.notused, CT_OUT(NORM));
    printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trace_trailer.id, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRACE::__unpack,uint32 board);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRACE.
 *
 * Do not edit - automatically generated.
 */

// TRACE(board)
template<typename __data_src_t>
bool TRACE::__match(__data_src_t &__buffer,uint32 board)
{
  // MEMBER(DATA16 traces[16][4000] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_id_traces[16] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_15: other;
    // 16_19: board = MATCH(board);
    // 24_31: ch_id;
    // ENCODE(channel_id_traces[ch_id],(value=ch_id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 other : 8; // 8..15
      uint32 board : 4; // 16..19
      uint32 dummy_20_23 : 4;
      uint32 ch_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ch_id : 8; // 24..31
      uint32 dummy_20_23 : 4;
      uint32 board : 4; // 16..19
      uint32 other : 8; // 8..15
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(619,uint32 ,header,header.u32,28);
  MATCH_BITS_EQUAL(614,header.unnamed_0_7,52);
  MATCH_BITS_EQUAL(616,header.board,board);
  MATCH_UNNAMED_BITS_ZERO(619,header.u32,0x00f00000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRACE::__match,uint32 board);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRACE.
 *
 * Do not edit - automatically generated.
 */

// TRACE(board)
template<typename __data_dest_t>
void PACKER_TRACE::__packer(__data_dest_t &__buffer,uint32 board)
{
  // MEMBER(DATA16 traces[16][4000] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_id_traces[16] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_15: other;
    // 16_19: board = MATCH(board);
    // 24_31: ch_id;
    // ENCODE(channel_id_traces[ch_id],(value=ch_id));
  // }
  // UINT32 tracesize NOENCODE
  // {
    //  0_31: size;
  // }
  // UINT32 tracehead NOENCODE
  // {
    //  0_23: other;
    // 24_31: head;
  // }
  // list(0<=j<((tracesize.size / 4) - 2))

  {
    // UINT32 channel_trace NOENCODE
    // {
      //  0_13: data1;
      // 14_15: stuff1;
      // 16_29: data2;
      // 30_31: stuff2;
      // ENCODE(traces[header.ch_id][((2 * j) + 0)],(value=data1));
      // ENCODE(traces[header.ch_id][((2 * j) + 1)],(value=data2));
    // }
  }
  // UINT32 trace_trailer NOENCODE
  // {
    //  0_23: notused;
    // 24_31: id = RANGE(176,191);
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRACE::__packer,uint32 board);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_EVENT_TRACES
class FEBEX_EVENT_TRACES
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_EVENT_TRACES
class PACKER_FEBEX_EVENT_TRACES
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 trig);
  DATA8 trig;
  // MEMBER(DATA32 event_trigger_time_hi);
  DATA32 event_trigger_time_hi;
  // MEMBER(DATA32 event_trigger_time_lo);
  DATA32 event_trigger_time_lo;
  // MEMBER(DATA16 hit_pattern);
  DATA16 hit_pattern;
  // MEMBER(DATA32 num_channels_fired);
  DATA32 num_channels_fired;
  // MEMBER(DATA8 board_num);
  DATA8 board_num;
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_id;
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,16> channel_trigger_time_hi;
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_trigger_time_lo;
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> pileup;
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> overflow;
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA8,DATA8,16> channel_cfd;
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> channel_energy;
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
    // ENCODE(board_num,(value=board_id));
    // ENCODE(trig,(value=trigger_type));
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // if((sumchannel.trigger_type == 1))

  // else

    // list(0<=index<((channel_size.size / 4) - 1))

      // UINT32 channelids NOENCODE
      // {
        //  0_15: chan_ts_hi;
        // 16_23: channel_id_bits;
        // 24_31: 240;
        // ENCODE(channel_id[index],(value=channel_id_bits));
        // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      // }
      // UINT32 channel_ts NOENCODE
      // {
        //  0_31: chan_ts_lo;
        // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      // }
      // UINT32 chan_enrgy NOENCODE
      // {
        //  0_23: chan_energy;
        // 24_29: TSF;
        //    30: pileup_flag;
        //    31: overflow_flag;
        // ENCODE(channel_cfd[index],(value=TSF));
        // ENCODE(channel_energy[index],(value=chan_energy));
        // ENCODE(pileup[index],(value=pileup_flag));
        // ENCODE(overflow[index],(value=overflow_flag));
      // }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: 0;
      // }
    // list(0<=index<16)

      // select optional

        // trace = TRACE(board=card);
      SINGLE(TRACE,trace);
    // if((sumchannel.trigger_type == 3))

      // several UINT32 dummy NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_EVENT_TRACES);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
template<typename __data_src_t>
void FEBEX_EVENT_TRACES::__unpack(__data_src_t &__buffer,uint32 card)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FEBEX_EVENT_TRACES",CT_OUT(NORM));
  }
  // MEMBER(DATA8 trig);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 board_num);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
    // ENCODE(board_num,(value=board_id));
    // ENCODE(trig,(value=trigger_type));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  READ_FROM_BUFFER_FULL(169,uint32 ,sumchannel,sumchannel.u32,29);
  CHECK_BITS_EQUAL(162,sumchannel.unnamed_0_7,52);
  CHECK_BITS_EQUAL(165,sumchannel.board_id,card);
  CHECK_BITS_EQUAL(166,sumchannel.unnamed_24_31,255);
  {
    {
      board_num.value = sumchannel.board_id;
    }
    {
      trig.value = sumchannel.trigger_type;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: sumchannel ", CT_OUT(BOLD), sumchannel.u32, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.trigger_type, CT_OUT(NORM));
    printf(".sfpnr=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.sfpnr, CT_OUT(NORM));
    printf(".board_id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  sumchannel.board_id, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 ignore : 2; // 0..1
      uint32 size : 30; // 2..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 30; // 2..31
      uint32 ignore : 2; // 0..1
#endif
    };
    uint32  u32;
  } channel_size;
  READ_FROM_BUFFER_FULL(175,uint32 ,channel_size,channel_size.u32,30);
  {
    num_channels_fired.value = ((channel_size.size / 4) - 1);
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: channel_size ", CT_OUT(BOLD), channel_size.u32, CT_OUT(NORM));
    printf(".ignore=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.ignore, CT_OUT(NORM));
    printf(".size=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_size.size, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_hi : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 timestamp_hi : 16; // 0..15
#endif
    };
    uint32  u32;
  } event_timestamp_hi;
  READ_FROM_BUFFER_FULL(181,uint32 ,event_timestamp_hi,event_timestamp_hi.u32,31);
  {
    event_trigger_time_hi.value = event_timestamp_hi.timestamp_hi;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_hi ", CT_OUT(BOLD), event_timestamp_hi.u32, CT_OUT(NORM));
    printf(".timestamp_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.timestamp_hi, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_hi.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timestamp_lo : 32; // 0..31
#endif
    };
    uint32  u32;
  } event_timestamp_lo;
  READ_FROM_BUFFER_FULL(186,uint32 ,event_timestamp_lo,event_timestamp_lo.u32,32);
  {
    event_trigger_time_lo.value = event_timestamp_lo.timestamp_lo;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: event_timestamp_lo ", CT_OUT(BOLD), event_timestamp_lo.u32, CT_OUT(NORM));
    printf(".timestamp_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  event_timestamp_lo.timestamp_lo, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 hp : 16; // 0..15
      uint32 ignore : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 ignore : 16; // 16..31
      uint32 hp : 16; // 0..15
#endif
    };
    uint32  u32;
  } hp;
  READ_FROM_BUFFER_FULL(192,uint32 ,hp,hp.u32,33);
  {
    hit_pattern.value = hp.hp;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: hp ", CT_OUT(BOLD), hp.u32, CT_OUT(NORM));
    printf(".hp=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.hp, CT_OUT(NORM));
    printf(".ignore=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hp.ignore, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } deadbeef;
  READ_FROM_BUFFER_FULL(196,uint32 ,deadbeef,deadbeef.u32,34);
  CHECK_BITS_EQUAL(195,deadbeef.unnamed_0_31,0xdeadbeef);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: deadbeef ", CT_OUT(BOLD), deadbeef.u32, CT_OUT(NORM));
    printf("\n");
  }
  // if((sumchannel.trigger_type == 1))

  // else

  if ((sumchannel.trigger_type == 1))
  {
    // list(0<=index<((channel_size.size / 4) - 1))

    for (uint32 index = 0; index < (uint32) (((channel_size.size / 4) - 1)); ++index)
    {
      // UINT32 channelids NOENCODE
      // {
        //  0_15: chan_ts_hi;
        // 16_23: channel_id_bits;
        // 24_31: 240;
        // ENCODE(channel_id[index],(value=channel_id_bits));
        // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_ts_hi : 16; // 0..15
          uint32 channel_id_bits : 8; // 16..23
          uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_24_31 : 8; // 24..31
          uint32 channel_id_bits : 8; // 16..23
          uint32 chan_ts_hi : 16; // 0..15
#endif
        };
        uint32  u32;
      } channelids;
      READ_FROM_BUFFER_FULL(208,uint32 ,channelids,channelids.u32,35);
      CHECK_BITS_EQUAL(205,channelids.unnamed_24_31,240);
      {
        {
          typedef __typeof__(*(&(channel_id))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_id.insert_index(206,index);
          __item.value = channelids.channel_id_bits;
        }
        {
          typedef __typeof__(*(&(channel_trigger_time_hi))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_trigger_time_hi.insert_index(207,index);
          __item.value = channelids.chan_ts_hi;
        }
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: channelids ", CT_OUT(BOLD), channelids.u32, CT_OUT(NORM));
        printf(".chan_ts_hi=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.chan_ts_hi, CT_OUT(NORM));
        printf(".channel_id_bits=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channelids.channel_id_bits, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 channel_ts NOENCODE
      // {
        //  0_31: chan_ts_lo;
        // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_ts_lo : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 chan_ts_lo : 32; // 0..31
#endif
        };
        uint32  u32;
      } channel_ts;
      READ_FROM_BUFFER_FULL(213,uint32 ,channel_ts,channel_ts.u32,36);
      {
        typedef __typeof__(*(&(channel_trigger_time_lo))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = channel_trigger_time_lo.insert_index(212,index);
        __item.value = channel_ts.chan_ts_lo;
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: channel_ts ", CT_OUT(BOLD), channel_ts.u32, CT_OUT(NORM));
        printf(".chan_ts_lo=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_ts.chan_ts_lo, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 chan_enrgy NOENCODE
      // {
        //  0_23: chan_energy;
        // 24_29: TSF;
        //    30: pileup_flag;
        //    31: overflow_flag;
        // ENCODE(channel_cfd[index],(value=TSF));
        // ENCODE(channel_energy[index],(value=chan_energy));
        // ENCODE(pileup[index],(value=pileup_flag));
        // ENCODE(overflow[index],(value=overflow_flag));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 chan_energy : 24; // 0..23
          uint32 TSF : 6; // 24..29
          uint32 pileup_flag : 1; // 30
          uint32 overflow_flag : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 overflow_flag : 1; // 31
          uint32 pileup_flag : 1; // 30
          uint32 TSF : 6; // 24..29
          uint32 chan_energy : 24; // 0..23
#endif
        };
        uint32  u32;
      } chan_enrgy;
      READ_FROM_BUFFER_FULL(224,uint32 ,chan_enrgy,chan_enrgy.u32,37);
      {
        {
          typedef __typeof__(*(&(channel_cfd))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_cfd.insert_index(220,index);
          __item.value = chan_enrgy.TSF;
        }
        {
          typedef __typeof__(*(&(channel_energy))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = channel_energy.insert_index(221,index);
          __item.value = chan_enrgy.chan_energy;
        }
        {
          typedef __typeof__(*(&(pileup))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = pileup.insert_index(222,index);
          __item.value = chan_enrgy.pileup_flag;
        }
        {
          typedef __typeof__(*(&(overflow))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = overflow.insert_index(223,index);
          __item.value = chan_enrgy.overflow_flag;
        }
      }
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: chan_enrgy ", CT_OUT(BOLD), chan_enrgy.u32, CT_OUT(NORM));
        printf(".chan_energy=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.chan_energy, CT_OUT(NORM));
        printf(".TSF=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.TSF, CT_OUT(NORM));
        printf(".pileup_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.pileup_flag, CT_OUT(NORM));
        printf(".overflow_flag=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  chan_enrgy.overflow_flag, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: 0;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_0_31 : 32; // 0..31
#endif
        };
        uint32  u32;
      } future_use;
      READ_FROM_BUFFER_FULL(228,uint32 ,future_use,future_use.u32,38);
      CHECK_BITS_EQUAL(227,future_use.unnamed_0_31,0);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: future_use ", CT_OUT(BOLD), future_use.u32, CT_OUT(NORM));
        printf("\n");
      }
    }
    // list(0<=index<16)

    for (uint32 index = 0; index < (uint32) (16); ++index)
    {
      // select optional

        // trace = TRACE(board=card);
      do
      {
        if (__buffer.empty()) goto no_match_1;
        int __match_no = 0;
        // optimized match 1: TRACE trace: (s32) => (0x00f000ff,0x00000034)
        {
        uint32 __match_peek;
        PEEK_FROM_BUFFER(235,uint32,__match_peek);
        // differ = 00000000 :
        uint32 __match_index = 0;
        static const sint8 __match_index_array[1] = { 1, };
        __match_no = __match_index_array[__match_index];
        // last_subevent_item = 0
        }
        if (!__match_no) goto no_match_1;
        switch (__match_no)
        {
          case 1:
            CHECK_SPURIOUS_MATCH_DECL(234,spurious_match_abort_loop_0,TRACE,/*board*/card);
            UNPACK_DECL(234,TRACE,trace,/*board*/card);
            break;
        }
      }
      while (0);
      spurious_match_abort_loop_0:;
        no_match_1:;
    }
  }

  else
  {
    // if((sumchannel.trigger_type == 3))

    if ((sumchannel.trigger_type == 3))
    {
      // several UINT32 dummy NOENCODE;
      for ( ; ; ) {
      uint32  dummy;if (__buffer.empty()) goto data_done_0;
      READ_FROM_BUFFER(242,uint32 ,dummy,39);
      }
      data_done_0:;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT_TRACES::__unpack,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
template<typename __data_src_t>
bool FEBEX_EVENT_TRACES::__match(__data_src_t &__buffer,uint32 card)
{
  // MEMBER(DATA8 trig);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 board_num);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
    // ENCODE(board_num,(value=board_id));
    // ENCODE(trig,(value=trigger_type));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfpnr : 4; // 12..15
      uint32 board_id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 board_id : 8; // 16..23
      uint32 sfpnr : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } sumchannel;
  MATCH_READ_FROM_BUFFER_FULL(169,uint32 ,sumchannel,sumchannel.u32,40);
  MATCH_BITS_EQUAL(162,sumchannel.unnamed_0_7,52);
  MATCH_BITS_EQUAL(165,sumchannel.board_id,card);
  MATCH_BITS_EQUAL(166,sumchannel.unnamed_24_31,255);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FEBEX_EVENT_TRACES::__match,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_EVENT_TRACES.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENT_TRACES(card)
template<typename __data_dest_t>
void PACKER_FEBEX_EVENT_TRACES::__packer(__data_dest_t &__buffer,uint32 card)
{
  // MEMBER(DATA8 trig);
  // MEMBER(DATA32 event_trigger_time_hi);
  // MEMBER(DATA32 event_trigger_time_lo);
  // MEMBER(DATA16 hit_pattern);
  // MEMBER(DATA32 num_channels_fired);
  // MEMBER(DATA8 board_num);
  // MEMBER(DATA8 channel_id[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 channel_trigger_time_hi[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_trigger_time_lo[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 pileup[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 overflow[16] ZERO_SUPPRESS);
  // MEMBER(DATA8 channel_cfd[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 channel_energy[16] ZERO_SUPPRESS);
  // UINT32 sumchannel NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfpnr;
    // 16_23: board_id = MATCH(card);
    // 24_31: 255;
    // ENCODE(board_num,(value=board_id));
    // ENCODE(trig,(value=trigger_type));
  // }
  // UINT32 channel_size NOENCODE
  // {
    //  0_01: ignore;
    //  2_31: size;
    // ENCODE(num_channels_fired,(value=((size / 4) - 1)));
  // }
  // UINT32 event_timestamp_hi NOENCODE
  // {
    //  0_15: timestamp_hi;
    // 16_31: ignore;
    // ENCODE(event_trigger_time_hi,(value=timestamp_hi));
  // }
  // UINT32 event_timestamp_lo NOENCODE
  // {
    //  0_31: timestamp_lo;
    // ENCODE(event_trigger_time_lo,(value=timestamp_lo));
  // }
  // UINT32 hp NOENCODE
  // {
    //  0_15: hp;
    // 16_31: ignore;
    // ENCODE(hit_pattern,(value=hp));
  // }
  // UINT32 deadbeef NOENCODE
  // {
    //  0_31: 0xdeadbeef;
  // }
  // if((sumchannel.trigger_type == 1))

  // else

  if ((sumchannel.trigger_type == 1))
  {
    // list(0<=index<((channel_size.size / 4) - 1))

    {
      // UINT32 channelids NOENCODE
      // {
        //  0_15: chan_ts_hi;
        // 16_23: channel_id_bits;
        // 24_31: 240;
        // ENCODE(channel_id[index],(value=channel_id_bits));
        // ENCODE(channel_trigger_time_hi[index],(value=chan_ts_hi));
      // }
      // UINT32 channel_ts NOENCODE
      // {
        //  0_31: chan_ts_lo;
        // ENCODE(channel_trigger_time_lo[index],(value=chan_ts_lo));
      // }
      // UINT32 chan_enrgy NOENCODE
      // {
        //  0_23: chan_energy;
        // 24_29: TSF;
        //    30: pileup_flag;
        //    31: overflow_flag;
        // ENCODE(channel_cfd[index],(value=TSF));
        // ENCODE(channel_energy[index],(value=chan_energy));
        // ENCODE(pileup[index],(value=pileup_flag));
        // ENCODE(overflow[index],(value=overflow_flag));
      // }
      // UINT32 future_use NOENCODE
      // {
        //  0_31: 0;
      // }
    }
    // list(0<=index<16)

    {
      // select optional

        // trace = TRACE(board=card);
      {
        PACK_DECL(234,TRACE,trace,/*board*/card);
      }
    }
  }

  else
  {
    // if((sumchannel.trigger_type == 3))

    if ((sumchannel.trigger_type == 3))
    {
      // several UINT32 dummy NOENCODE;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_EVENT_TRACES::__packer,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_PADDING
class FEBEX_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_PADDING
class PACKER_FEBEX_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
void FEBEX_PADDING::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "FEBEX_PADDING",CT_OUT(NORM));
  }
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  READ_FROM_BUFFER_FULL(254,uint32 ,pads_data,pads_data.u32,41);
  CHECK_BITS_EQUAL(253,pads_data.unnamed_20_31,0xadd);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: pads_data ", CT_OUT(BOLD), pads_data.u32, CT_OUT(NORM));
    printf(".counter=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  pads_data.counter, CT_OUT(NORM));
    printf(".index=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  pads_data.index, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
bool FEBEX_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  MATCH_READ_FROM_BUFFER_FULL(254,uint32 ,pads_data,pads_data.u32,42);
  MATCH_BITS_EQUAL(253,pads_data.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_dest_t>
void PACKER_FEBEX_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: MAIN_CRATE_DATA
//
//
// Generating code for: VME_CAEN_V830
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V830
class VME_CAEN_V830
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V830
class PACKER_VME_CAEN_V830
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 undefined : 2; // 24..25
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 undefined : 2; // 24..25
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V830);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
void VME_CAEN_V830::__unpack(__data_src_t &__buffer,uint32 geom)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V830",CT_OUT(NORM));
  }
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  READ_FROM_BUFFER_FULL(977,uint32 ,header,header.u32,43);
  CHECK_BITS_EQUAL(975,header.unnamed_26_26,1);
  CHECK_BITS_EQUAL(976,header.geom,geom);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".event_number=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.event_number, CT_OUT(NORM));
    printf(".ts=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.ts, CT_OUT(NORM));
    printf(".count=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.count, CT_OUT(NORM));
    printf(".undefined=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.undefined, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 26; // 0..25
        uint32 unnamed_26_26 : 1; // 26
        uint32 channel : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel : 5; // 27..31
        uint32 unnamed_26_26 : 1; // 26
        uint32 value : 26; // 0..25
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(986,uint32 ,ch_data,ch_data.u32,44);
    CHECK_BITS_EQUAL(983,ch_data.unnamed_26_26,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(985,ch_data.channel);
      __item.value = ch_data.value;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: ch_data ", CT_OUT(BOLD), ch_data.u32, CT_OUT(NORM));
      printf(".value=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.value, CT_OUT(NORM));
      printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.channel, CT_OUT(NORM));
      printf("\n");
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
bool VME_CAEN_V830::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 undefined : 2; // 24..25
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 undefined : 2; // 24..25
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } __header;
  MATCH_READ_FROM_BUFFER_FULL(977,uint32 ,header,__header.u32,45);
  MATCH_BITS_EQUAL(975,__header.unnamed_26_26,1);
  MATCH_BITS_EQUAL(976,__header.geom,geom);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V830::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V830::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: ZERO_FILLER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
#if !PACKER_CODE
# define DECLARED_UNPACK_ZERO_FILLER
class ZERO_FILLER
#else//PACKER_CODE
# define DECLARED_PACKER_ZERO_FILLER
class PACKER_ZERO_FILLER
#endif//PACKER_CODE

{
public:
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(ZERO_FILLER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
template<typename __data_src_t>
void ZERO_FILLER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "ZERO_FILLER",CT_OUT(NORM));
  }
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 zero : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 zero : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  READ_FROM_BUFFER_FULL(1011,uint32 ,filler,filler.u32,46);
  CHECK_BITS_EQUAL(1010,filler.zero,0);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: filler ", CT_OUT(BOLD), filler.u32, CT_OUT(NORM));
    printf(".zero=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  filler.zero, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,ZERO_FILLER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
template<typename __data_src_t>
bool ZERO_FILLER::__match(__data_src_t &__buffer)
{
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 zero : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 zero : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  MATCH_READ_FROM_BUFFER_FULL(1011,uint32 ,filler,filler.u32,47);
  MATCH_BITS_EQUAL(1010,filler.zero,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,ZERO_FILLER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for ZERO_FILLER.
 *
 * Do not edit - automatically generated.
 */

// ZERO_FILLER()
template<typename __data_dest_t>
void PACKER_ZERO_FILLER::__packer(__data_dest_t &__buffer)
{
  // UINT32 filler NOENCODE
  // {
    //  0_31: zero = MATCH(0);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,ZERO_FILLER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V7X5
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V7X5.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V7X5
class VME_CAEN_V7X5
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V7X5
class PACKER_VME_CAEN_V7X5
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA24,DATA24,32> data;
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      //    15: undefined;
      // 16_20: channel;
      // 21_23: undefined2;
      // 24_26: 0;
      // 27_31: geom;
      // ENCODE(data[channel],(value=value));
    // }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: id = MATCH(geom);
  // }
  // list(0<=i<2)

    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V7X5);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V7X5.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5(geom)
template<typename __data_src_t>
void VME_CAEN_V7X5::__unpack(__data_src_t &__buffer,uint32 geom)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V7X5",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 undefined : 8; // 0..7
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 undefined : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(932,uint32 ,header,header.u32,48);
  CHECK_BITS_EQUAL(930,header.unnamed_24_26,2);
  CHECK_BITS_EQUAL(931,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(932,header.u32,0x0000c000);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".undefined=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.undefined, CT_OUT(NORM));
    printf(".count=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.count, CT_OUT(NORM));
    printf(".crate=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.crate, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      //    15: undefined;
      // 16_20: channel;
      // 21_23: undefined2;
      // 24_26: 0;
      // 27_31: geom;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 overflow : 1; // 12
        uint32 underflow : 1; // 13
        uint32 valid : 1; // 14
        uint32 undefined : 1; // 15
        uint32 channel : 5; // 16..20
        uint32 undefined2 : 3; // 21..23
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 undefined2 : 3; // 21..23
        uint32 channel : 5; // 16..20
        uint32 undefined : 1; // 15
        uint32 valid : 1; // 14
        uint32 underflow : 1; // 13
        uint32 overflow : 1; // 12
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(947,uint32 ,ch_data,ch_data.u32,49);
    CHECK_BITS_EQUAL(944,ch_data.unnamed_24_26,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(946,ch_data.channel);
      __item.value = ch_data.value;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: ch_data ", CT_OUT(BOLD), ch_data.u32, CT_OUT(NORM));
      printf(".value=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.value, CT_OUT(NORM));
      printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.overflow, CT_OUT(NORM));
      printf(".underflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.underflow, CT_OUT(NORM));
      printf(".valid=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.valid, CT_OUT(NORM));
      printf(".undefined=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.undefined, CT_OUT(NORM));
      printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.channel, CT_OUT(NORM));
      printf(".undefined2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.undefined2, CT_OUT(NORM));
      printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ch_data.geom, CT_OUT(NORM));
      printf("\n");
    }
  }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: id = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 nothing : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 id : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 nothing : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;
  READ_FROM_BUFFER_FULL(954,uint32 ,eob,eob.u32,50);
  CHECK_BITS_EQUAL(952,eob.unnamed_24_26,4);
  CHECK_BITS_EQUAL(953,eob.id,geom);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: eob ", CT_OUT(BOLD), eob.u32, CT_OUT(NORM));
    printf(".nothing=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob.nothing, CT_OUT(NORM));
    printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob.id, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=i<2)

  for (uint32 i = 0; i < (uint32) (2); ++i)
  {
    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 nothing : 24; // 0..23
        uint32 id : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 id : 3; // 24..26
        uint32 nothing : 24; // 0..23
#endif
      };
      uint32  u32;
    } eob2;
    if (__buffer.empty()) goto data_done_1;
    PEEK_FROM_BUFFER_FULL(962,uint32 ,eob2,eob2.u32,51);
    CHECK_JUMP_BITS_EQUAL(960,eob2.id,6,data_done_1);
    __buffer.advance(sizeof(eob2.u32));
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: eob2 ", CT_OUT(BOLD), eob2.u32, CT_OUT(NORM));
      printf(".nothing=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.nothing, CT_OUT(NORM));
      printf(".id=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.id, CT_OUT(NORM));
      printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  eob2.geom, CT_OUT(NORM));
      printf("\n");
    }
    data_done_1:;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V7X5::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V7X5.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5(geom)
template<typename __data_src_t>
bool VME_CAEN_V7X5::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 undefined : 8; // 0..7
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 undefined : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(932,uint32 ,header,header.u32,52);
  MATCH_BITS_EQUAL(930,header.unnamed_24_26,2);
  MATCH_BITS_EQUAL(931,header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(932,header.u32,0x0000c000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V7X5::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V7X5.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V7X5(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V7X5::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate;
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      //    15: undefined;
      // 16_20: channel;
      // 21_23: undefined2;
      // 24_26: 0;
      // 27_31: geom;
      // ENCODE(data[channel],(value=value));
    // }
  }
  // UINT32 eob NOENCODE
  // {
    //  0_23: nothing;
    // 24_26: 4;
    // 27_31: id = MATCH(geom);
  // }
  // list(0<=i<2)

  {
    // optional UINT32 eob2 NOENCODE
    // {
      //  0_23: nothing;
      // 24_26: id = MATCH(6);
      // 27_31: geom;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V7X5::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_N
//
//
// Generating code for: TDC_HEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_HEADER
class TDC_HEADER
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_HEADER
class PACKER_TDC_HEADER
#endif//PACKER_CODE

{
public:
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_HEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
template<typename __data_src_t>
void TDC_HEADER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_HEADER",CT_OUT(NORM));
  }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_header;
  READ_FROM_BUFFER_FULL(480,uint32 ,tdc_header,tdc_header.u32,53);
  CHECK_BITS_EQUAL(479,tdc_header.unnamed_27_31,1);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_header ", CT_OUT(BOLD), tdc_header.u32, CT_OUT(NORM));
    printf(".bunch_id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.bunch_id, CT_OUT(NORM));
    printf(".event_id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.event_id, CT_OUT(NORM));
    printf(".tdc=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.tdc, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.unused, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_HEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
template<typename __data_src_t>
bool TDC_HEADER::__match(__data_src_t &__buffer)
{
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_header;
  MATCH_READ_FROM_BUFFER_FULL(480,uint32 ,tdc_header,tdc_header.u32,54);
  MATCH_BITS_EQUAL(479,tdc_header.unnamed_27_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_HEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TDC_HEADER()
template<typename __data_dest_t>
void PACKER_TDC_HEADER::__packer(__data_dest_t &__buffer)
{
  // UINT32 tdc_header NOENCODE
  // {
    //  0_11: bunch_id;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 1;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_HEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_DATA_V1290
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_DATA_V1290
class TDC_DATA_V1290
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_DATA_V1290
class PACKER_TDC_DATA_V1290
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,128,128> data;
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA8,DATA8,128,128> leadOrTrail;
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_DATA_V1290);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290()
template<typename __data_src_t>
void TDC_DATA_V1290::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_DATA_V1290",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 21; // 0..20
      uint32 chn : 5; // 21..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 5; // 21..25
      uint32 tdc : 21; // 0..20
#endif
    };
    uint32  u32;
  } tdc_data;
  READ_FROM_BUFFER_FULL(456,uint32 ,tdc_data,tdc_data.u32,55);
  CHECK_BITS_EQUAL(453,tdc_data.unnamed_27_31,0);
  {
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(454,tdc_data.chn);
      __item.value = tdc_data.tdc;
    }
    {
      typedef __typeof__(*(&(leadOrTrail))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = leadOrTrail.insert_index(455,tdc_data.chn);
      __item.value = tdc_data.lot;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_data ", CT_OUT(BOLD), tdc_data.u32, CT_OUT(NORM));
    printf(".tdc=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.tdc, CT_OUT(NORM));
    printf(".chn=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.chn, CT_OUT(NORM));
    printf(".lot=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.lot, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_DATA_V1290::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290()
template<typename __data_src_t>
bool TDC_DATA_V1290::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 21; // 0..20
      uint32 chn : 5; // 21..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 5; // 21..25
      uint32 tdc : 21; // 0..20
#endif
    };
    uint32  u32;
  } tdc_data;
  MATCH_READ_FROM_BUFFER_FULL(456,uint32 ,tdc_data,tdc_data.u32,56);
  MATCH_BITS_EQUAL(453,tdc_data.unnamed_27_31,0);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_DATA_V1290::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_DATA_V1290.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1290()
template<typename __data_dest_t>
void PACKER_TDC_DATA_V1290::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_20: tdc;
    // 21_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_DATA_V1290::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_ERROR
class TDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_ERROR
class PACKER_TDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
template<typename __data_src_t>
void TDC_ERROR::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_ERROR",CT_OUT(NORM));
  }
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 error_flags : 15; // 0..14
      uint32 unused1 : 9; // 15..23
      uint32 tdc : 2; // 24..25
      uint32 unused2 : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused2 : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 unused1 : 9; // 15..23
      uint32 error_flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } tdc_err;
  READ_FROM_BUFFER_FULL(468,uint32 ,tdc_err,tdc_err.u32,57);
  CHECK_BITS_EQUAL(467,tdc_err.unnamed_27_31,4);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_err ", CT_OUT(BOLD), tdc_err.u32, CT_OUT(NORM));
    printf(".error_flags=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.error_flags, CT_OUT(NORM));
    printf(".unused1=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.unused1, CT_OUT(NORM));
    printf(".tdc=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.tdc, CT_OUT(NORM));
    printf(".unused2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_err.unused2, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_ERROR::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
template<typename __data_src_t>
bool TDC_ERROR::__match(__data_src_t &__buffer)
{
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 error_flags : 15; // 0..14
      uint32 unused1 : 9; // 15..23
      uint32 tdc : 2; // 24..25
      uint32 unused2 : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused2 : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 unused1 : 9; // 15..23
      uint32 error_flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } tdc_err;
  MATCH_READ_FROM_BUFFER_FULL(468,uint32 ,tdc_err,tdc_err.u32,58);
  MATCH_BITS_EQUAL(467,tdc_err.unnamed_27_31,4);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_ERROR::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// TDC_ERROR()
template<typename __data_dest_t>
void PACKER_TDC_ERROR::__packer(__data_dest_t &__buffer)
{
  // UINT32 tdc_err NOENCODE
  // {
    //  0_14: error_flags;
    // 15_23: unused1;
    // 24_25: tdc;
    //    26: unused2;
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_ERROR::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_TRAILER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_TRAILER
class TDC_TRAILER
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_TRAILER
class PACKER_TDC_TRAILER
#endif//PACKER_CODE

{
public:
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_TRAILER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
template<typename __data_src_t>
void TDC_TRAILER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_TRAILER",CT_OUT(NORM));
  }
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_trailer;
  READ_FROM_BUFFER_FULL(492,uint32 ,tdc_trailer,tdc_trailer.u32,59);
  CHECK_BITS_EQUAL(491,tdc_trailer.unnamed_27_31,3);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_trailer ", CT_OUT(BOLD), tdc_trailer.u32, CT_OUT(NORM));
    printf(".word_count=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.word_count, CT_OUT(NORM));
    printf(".event_id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.event_id, CT_OUT(NORM));
    printf(".tdc=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.tdc, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_trailer.unused, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_TRAILER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
template<typename __data_src_t>
bool TDC_TRAILER::__match(__data_src_t &__buffer)
{
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 unused : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 unused : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } tdc_trailer;
  MATCH_READ_FROM_BUFFER_FULL(492,uint32 ,tdc_trailer,tdc_trailer.u32,60);
  MATCH_BITS_EQUAL(491,tdc_trailer.unnamed_27_31,3);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_TRAILER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_TRAILER.
 *
 * Do not edit - automatically generated.
 */

// TDC_TRAILER()
template<typename __data_dest_t>
void PACKER_TDC_TRAILER::__packer(__data_dest_t &__buffer)
{
  // UINT32 tdc_trailer NOENCODE
  // {
    //  0_11: word_count;
    // 12_23: event_id;
    // 24_25: tdc;
    //    26: unused;
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_TRAILER::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_N()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_N
class VME_CAEN_V1290_N
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_N
class PACKER_VME_CAEN_V1290_N
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 geo);
  DATA8 geo;
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: type = MATCH(8);
    // ENCODE(geo,(value=geom));
  // }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1290();
    // tdc_err = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  SINGLE(TDC_HEADER,tdc_header);
  SINGLE(TDC_DATA_V1290,measurement);
  SINGLE(TDC_ERROR,tdc_err);
  SINGLE(TDC_TRAILER,tdc_trailer);
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geom;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_N);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_N()
template<typename __data_src_t>
void VME_CAEN_V1290_N::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V1290_N",CT_OUT(NORM));
  }
  // MEMBER(DATA8 geo);
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: type = MATCH(8);
    // ENCODE(geo,(value=geom));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 type : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 type : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(728,uint32 ,header,header.u32,61);
  CHECK_BITS_EQUAL(726,header.type,8);
  {
    geo.value = header.geom;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf(".event_count=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.event_count, CT_OUT(NORM));
    printf(".type=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.type, CT_OUT(NORM));
    printf("\n");
  }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1290();
    // tdc_err = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TDC_HEADER tdc_header: (s32) => (0xf8000000,0x08000000)
    // optimized match 2: TDC_DATA_V1290 measurement: (s32) => (0xf8000000,0x00000000)
    // optimized match 3: TDC_ERROR tdc_err: (s32) => (0xf8000000,0x20000000)
    // optimized match 4: TDC_TRAILER tdc_trailer: (s32) => (0xf8000000,0x18000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(735,uint32,__match_peek);
    // differ = 38000000 : 27 28 29
    uint32 __match_index = 0 | /* 27,29 */ ((__match_peek >> 27) & 0x00000007);
    static const sint8 __match_index_array[8] = { 2, 1, 0, 4, 3, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(731,spurious_match_abort_loop_1,TDC_HEADER);
        UNPACK_DECL(731,TDC_HEADER,tdc_header);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(732,spurious_match_abort_loop_1,TDC_DATA_V1290);
        UNPACK_DECL(732,TDC_DATA_V1290,measurement);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(733,spurious_match_abort_loop_1,TDC_ERROR);
        UNPACK_DECL(733,TDC_ERROR,tdc_err);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(734,spurious_match_abort_loop_1,TDC_TRAILER);
        UNPACK_DECL(734,TDC_TRAILER,tdc_trailer);
        break;
    }
  }
  spurious_match_abort_loop_1:;
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } ext_time_tag;
  if (__buffer.empty()) goto data_done_2;
  PEEK_FROM_BUFFER_FULL(740,uint32 ,ext_time_tag,ext_time_tag.u32,62);
  CHECK_JUMP_BITS_EQUAL(739,ext_time_tag.unnamed_27_31,17,data_done_2);
  __buffer.advance(sizeof(ext_time_tag.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: ext_time_tag ", CT_OUT(BOLD), ext_time_tag.u32, CT_OUT(NORM));
    printf(".time_tag=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ext_time_tag.time_tag, CT_OUT(NORM));
    printf("\n");
  }
  data_done_2:;
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geom;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 16; // 5..20
      uint32 unused : 3; // 21..23
      uint32 tdc_error : 1; // 24
      uint32 overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 unused : 3; // 21..23
      uint32 word_count : 16; // 5..20
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(750,uint32 ,trailer,trailer.u32,63);
  CHECK_BITS_EQUAL(749,trailer.unnamed_27_31,16);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.geom, CT_OUT(NORM));
    printf(".word_count=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.word_count, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.unused, CT_OUT(NORM));
    printf(".tdc_error=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.tdc_error, CT_OUT(NORM));
    printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.overflow, CT_OUT(NORM));
    printf(".trigger_lost=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.trigger_lost, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1290_N::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_N()
template<typename __data_src_t>
bool VME_CAEN_V1290_N::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 geo);
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: type = MATCH(8);
    // ENCODE(geo,(value=geom));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 type : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 type : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(728,uint32 ,header,header.u32,64);
  MATCH_BITS_EQUAL(726,header.type,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V1290_N::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_N()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_N::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 geo);
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: type = MATCH(8);
    // ENCODE(geo,(value=geom));
  // }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1290();
    // tdc_err = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  {
    PACK_DECL(731,TDC_HEADER,tdc_header);
    PACK_DECL(732,TDC_DATA_V1290,measurement);
    PACK_DECL(733,TDC_ERROR,tdc_err);
    PACK_DECL(734,TDC_TRAILER,tdc_trailer);
  }
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geom;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1290_N::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_MAIN_CRATE_DATA
class MAIN_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_MAIN_CRATE_DATA
class PACKER_MAIN_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // barrier0 = BARRIER();
  // v830 = VME_CAEN_V830(geom=8);
  // filler0 = ZERO_FILLER();
  // barrier1 = BARRIER();
  // v792 = VME_CAEN_V7X5(geom=14);
  // UINT32 aaahhh NOENCODE
  // {
    //  0_31: 0xaaaa1290;
  // }
  // UINT32 exxxxx NOENCODE;
  // barrier2 = BARRIER();
  // v1290 = VME_CAEN_V1290_N();
  // optional UINT32 eodb NOENCODE;
  SINGLE(BARRIER,barrier0);
  SINGLE(VME_CAEN_V830,v830);
  SINGLE(ZERO_FILLER,filler0);
  SINGLE(BARRIER,barrier1);
  SINGLE(VME_CAEN_V7X5,v792);
  SINGLE(BARRIER,barrier2);
  SINGLE(VME_CAEN_V1290_N,v1290);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(MAIN_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
template<typename __data_src_t>
void MAIN_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "MAIN_CRATE_DATA",CT_OUT(NORM));
  }
  // barrier0 = BARRIER();
  UNPACK_DECL(259,BARRIER,barrier0);
  // v830 = VME_CAEN_V830(geom=8);
  UNPACK_DECL(260,VME_CAEN_V830,v830,/*geom*/8);
  // filler0 = ZERO_FILLER();
  UNPACK_DECL(261,ZERO_FILLER,filler0);
  // barrier1 = BARRIER();
  UNPACK_DECL(262,BARRIER,barrier1);
  // v792 = VME_CAEN_V7X5(geom=14);
  UNPACK_DECL(263,VME_CAEN_V7X5,v792,/*geom*/14);
  // UINT32 aaahhh NOENCODE
  // {
    //  0_31: 0xaaaa1290;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } aaahhh;
  READ_FROM_BUFFER_FULL(267,uint32 ,aaahhh,aaahhh.u32,65);
  CHECK_BITS_EQUAL(266,aaahhh.unnamed_0_31,0xaaaa1290);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: aaahhh ", CT_OUT(BOLD), aaahhh.u32, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 exxxxx NOENCODE;
  uint32  exxxxx;READ_FROM_BUFFER(268,uint32 ,exxxxx,66);
  // barrier2 = BARRIER();
  UNPACK_DECL(269,BARRIER,barrier2);
  // v1290 = VME_CAEN_V1290_N();
  UNPACK_DECL(270,VME_CAEN_V1290_N,v1290);
  // optional UINT32 eodb NOENCODE;
  uint32  eodb;if (__buffer.empty()) goto data_done_3;
  READ_FROM_BUFFER(271,uint32 ,eodb,67);
  data_done_3:;
}
FORCE_IMPL_DATA_SRC_FCN(void,MAIN_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
template<typename __data_src_t>
bool MAIN_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // barrier0 = BARRIER();
  MATCH_SUB_DECL(259,BARRIER,barrier0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,MAIN_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for MAIN_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// MAIN_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_MAIN_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // barrier0 = BARRIER();
  PACK_DECL(259,BARRIER,barrier0);
  // v830 = VME_CAEN_V830(geom=8);
  PACK_DECL(260,VME_CAEN_V830,v830,/*geom*/8);
  // filler0 = ZERO_FILLER();
  PACK_DECL(261,ZERO_FILLER,filler0);
  // barrier1 = BARRIER();
  PACK_DECL(262,BARRIER,barrier1);
  // v792 = VME_CAEN_V7X5(geom=14);
  PACK_DECL(263,VME_CAEN_V7X5,v792,/*geom*/14);
  // UINT32 aaahhh NOENCODE
  // {
    //  0_31: 0xaaaa1290;
  // }
  // UINT32 exxxxx NOENCODE;
  // barrier2 = BARRIER();
  PACK_DECL(269,BARRIER,barrier2);
  // v1290 = VME_CAEN_V1290_N();
  PACK_DECL(270,VME_CAEN_V1290_N,v1290);
  // optional UINT32 eodb NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,MAIN_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SPILL_OFF
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SPILL_OFF.
 *
 * Do not edit - automatically generated.
 */

// SPILL_OFF()
#if !PACKER_CODE
# define DECLARED_UNPACK_SPILL_OFF
class SPILL_OFF
#else//PACKER_CODE
# define DECLARED_PACKER_SPILL_OFF
class PACKER_SPILL_OFF
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 spilloff);
  DATA8 spilloff;
  // UINT32 off1 NOENCODE
  // {
    //  0_31: 0x4040400a;
  // }
  // UINT32 off2 NOENCODE
  // {
    //  0_31: 0x4040400b;
  // }
  // UINT32 off3 NOENCODE
  // {
    //  0_31: 0x4040400c;
  // }
  // ENCODE(spilloff,(value=1));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SPILL_OFF);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SPILL_OFF.
 *
 * Do not edit - automatically generated.
 */

// SPILL_OFF()
template<typename __data_src_t>
void SPILL_OFF::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "SPILL_OFF",CT_OUT(NORM));
  }
  // MEMBER(DATA8 spilloff);
  // UINT32 off1 NOENCODE
  // {
    //  0_31: 0x4040400a;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } off1;
  READ_FROM_BUFFER_FULL(280,uint32 ,off1,off1.u32,68);
  CHECK_BITS_EQUAL(279,off1.unnamed_0_31,0x4040400a);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: off1 ", CT_OUT(BOLD), off1.u32, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 off2 NOENCODE
  // {
    //  0_31: 0x4040400b;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } off2;
  READ_FROM_BUFFER_FULL(284,uint32 ,off2,off2.u32,69);
  CHECK_BITS_EQUAL(283,off2.unnamed_0_31,0x4040400b);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: off2 ", CT_OUT(BOLD), off2.u32, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 off3 NOENCODE
  // {
    //  0_31: 0x4040400c;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } off3;
  READ_FROM_BUFFER_FULL(288,uint32 ,off3,off3.u32,70);
  CHECK_BITS_EQUAL(287,off3.unnamed_0_31,0x4040400c);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: off3 ", CT_OUT(BOLD), off3.u32, CT_OUT(NORM));
    printf("\n");
  }
  // ENCODE(spilloff,(value=1));

  {
    spilloff.value = 1;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SPILL_OFF::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SPILL_OFF.
 *
 * Do not edit - automatically generated.
 */

// SPILL_OFF()
template<typename __data_src_t>
bool SPILL_OFF::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 spilloff);
  // UINT32 off1 NOENCODE
  // {
    //  0_31: 0x4040400a;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } off1;
  MATCH_READ_FROM_BUFFER_FULL(280,uint32 ,off1,off1.u32,71);
  MATCH_BITS_EQUAL(279,off1.unnamed_0_31,0x4040400a);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,SPILL_OFF::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SPILL_OFF.
 *
 * Do not edit - automatically generated.
 */

// SPILL_OFF()
template<typename __data_dest_t>
void PACKER_SPILL_OFF::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 spilloff);
  // UINT32 off1 NOENCODE
  // {
    //  0_31: 0x4040400a;
  // }
  // UINT32 off2 NOENCODE
  // {
    //  0_31: 0x4040400b;
  // }
  // UINT32 off3 NOENCODE
  // {
    //  0_31: 0x4040400c;
  // }
  // ENCODE(spilloff,(value=1));

}
FORCE_IMPL_DATA_SRC_FCN(void,SPILL_OFF::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SPILL_ON
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SPILL_ON.
 *
 * Do not edit - automatically generated.
 */

// SPILL_ON()
#if !PACKER_CODE
# define DECLARED_UNPACK_SPILL_ON
class SPILL_ON
#else//PACKER_CODE
# define DECLARED_PACKER_SPILL_ON
class PACKER_SPILL_ON
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 spillon);
  DATA8 spillon;
  // UINT32 on NOENCODE
  // {
    //  0_31: 0x30303030;
  // }
  // ENCODE(spillon,(value=1));


public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SPILL_ON);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SPILL_ON.
 *
 * Do not edit - automatically generated.
 */

// SPILL_ON()
template<typename __data_src_t>
void SPILL_ON::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "SPILL_ON",CT_OUT(NORM));
  }
  // MEMBER(DATA8 spillon);
  // UINT32 on NOENCODE
  // {
    //  0_31: 0x30303030;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } on;
  READ_FROM_BUFFER_FULL(299,uint32 ,on,on.u32,72);
  CHECK_BITS_EQUAL(298,on.unnamed_0_31,0x30303030);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: on ", CT_OUT(BOLD), on.u32, CT_OUT(NORM));
    printf("\n");
  }
  // ENCODE(spillon,(value=1));

  {
    spillon.value = 1;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SPILL_ON::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SPILL_ON.
 *
 * Do not edit - automatically generated.
 */

// SPILL_ON()
template<typename __data_src_t>
bool SPILL_ON::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 spillon);
  // UINT32 on NOENCODE
  // {
    //  0_31: 0x30303030;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } on;
  MATCH_READ_FROM_BUFFER_FULL(299,uint32 ,on,on.u32,73);
  MATCH_BITS_EQUAL(298,on.unnamed_0_31,0x30303030);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,SPILL_ON::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SPILL_ON.
 *
 * Do not edit - automatically generated.
 */

// SPILL_ON()
template<typename __data_dest_t>
void PACKER_SPILL_ON::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 spillon);
  // UINT32 on NOENCODE
  // {
    //  0_31: 0x30303030;
  // }
  // ENCODE(spillon,(value=1));

}
FORCE_IMPL_DATA_SRC_FCN(void,SPILL_ON::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_EPOCH_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_EPOCH_DATA
class TAMEX4_EPOCH_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_EPOCH_DATA
class PACKER_TAMEX4_EPOCH_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_EPOCH_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
template<typename __data_src_t>
void TAMEX4_EPOCH_DATA::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_EPOCH_DATA",CT_OUT(NORM));
  }
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 epoch : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 epoch : 28; // 0..27
#endif
    };
    uint32  u32;
  } data;
  READ_FROM_BUFFER_FULL(321,uint32 ,data,data.u32,74);
  CHECK_BITS_EQUAL(315,data.unnamed_28_31,6);
  {
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.append_item(316);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.append_item(317);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_edge))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_edge.append_item(318);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_channel))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_channel.append_item(319);
      __item.value = 0;
    }
    {
      typedef __typeof__(*(&(time_epoch))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_epoch.append_item(320);
      __item.value = data.epoch;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: data ", CT_OUT(BOLD), data.u32, CT_OUT(NORM));
    printf(".epoch=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.epoch, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_EPOCH_DATA::__unpack,uint32 sfp,uint32 card
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                            ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                            ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
template<typename __data_src_t>
bool TAMEX4_EPOCH_DATA::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 epoch : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 epoch : 28; // 0..27
#endif
    };
    uint32  u32;
  } data;
  MATCH_READ_FROM_BUFFER_FULL(321,uint32 ,data,data.u32,75);
  MATCH_BITS_EQUAL(315,data.unnamed_28_31,6);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX4_EPOCH_DATA::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_EPOCH_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_EPOCH_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                  // time_epoch)
template<typename __data_dest_t>
void PACKER_TAMEX4_EPOCH_DATA::__packer(__data_dest_t &__buffer,uint32 sfp
                                                               ,uint32 card
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                               ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                               ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_27: epoch;
    // 28_31: 6;
    // ENCODE(time_coarse APPEND_LIST,(value=0));
    // ENCODE(time_fine APPEND_LIST,(value=0));
    // ENCODE(time_edge APPEND_LIST,(value=0));
    // ENCODE(time_channel APPEND_LIST,(value=0));
    // ENCODE(time_epoch APPEND_LIST,(value=epoch));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_EPOCH_DATA::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_HEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_HEADER
class TAMEX4_HEADER
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_HEADER
class PACKER_TAMEX4_HEADER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 post_trig_ns);
  DATA16 post_trig_ns;
  // MEMBER(DATA16 pre_trig_ns);
  DATA16 pre_trig_ns;
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns,(value=post_trig_ns));
    // ENCODE(pre_trig_ns,(value=pre_trig_ns));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_HEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
template<typename __data_src_t>
void TAMEX4_HEADER::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_HEADER",CT_OUT(NORM));
  }
  // MEMBER(DATA16 post_trig_ns);
  // MEMBER(DATA16 pre_trig_ns);
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns,(value=post_trig_ns));
    // ENCODE(pre_trig_ns,(value=pre_trig_ns));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 post_trig_ns : 16; // 0..15
      uint32 pre_trig_ns : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pre_trig_ns : 16; // 16..31
      uint32 post_trig_ns : 16; // 0..15
#endif
    };
    uint32  u32;
  } trigger_window;
  READ_FROM_BUFFER_FULL(334,uint32 ,trigger_window,trigger_window.u32,76);
  {
    {
      post_trig_ns.value = trigger_window.post_trig_ns;
    }
    {
      pre_trig_ns.value = trigger_window.pre_trig_ns;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trigger_window ", CT_OUT(BOLD), trigger_window.u32, CT_OUT(NORM));
    printf(".post_trig_ns=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trigger_window.post_trig_ns, CT_OUT(NORM));
    printf(".pre_trig_ns=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trigger_window.pre_trig_ns, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_HEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
template<typename __data_src_t>
bool TAMEX4_HEADER::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA16 post_trig_ns);
  // MEMBER(DATA16 pre_trig_ns);
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns,(value=post_trig_ns));
    // ENCODE(pre_trig_ns,(value=pre_trig_ns));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 post_trig_ns : 16; // 0..15
      uint32 pre_trig_ns : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pre_trig_ns : 16; // 16..31
      uint32 post_trig_ns : 16; // 0..15
#endif
    };
    uint32  u32;
  } trigger_window;
  MATCH_READ_FROM_BUFFER_FULL(334,uint32 ,trigger_window,trigger_window.u32,77);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TAMEX4_HEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_HEADER()
template<typename __data_dest_t>
void PACKER_TAMEX4_HEADER::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA16 post_trig_ns);
  // MEMBER(DATA16 pre_trig_ns);
  // UINT32 trigger_window NOENCODE
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
    // ENCODE(post_trig_ns,(value=post_trig_ns));
    // ENCODE(pre_trig_ns,(value=pre_trig_ns));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_HEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_PADDING
class TAMEX4_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_PADDING
class PACKER_TAMEX4_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
template<typename __data_src_t>
void TAMEX4_PADDING::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_PADDING",CT_OUT(NORM));
  }
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } padding;
  READ_FROM_BUFFER_FULL(344,uint32 ,padding,padding.u32,78);
  CHECK_BITS_EQUAL(343,padding.unnamed_20_31,0xadd);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: padding ", CT_OUT(BOLD), padding.u32, CT_OUT(NORM));
    printf(".counter=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  padding.counter, CT_OUT(NORM));
    printf(".index=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  padding.index, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
template<typename __data_src_t>
bool TAMEX4_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } padding;
  MATCH_READ_FROM_BUFFER_FULL(344,uint32 ,padding,padding.u32,79);
  MATCH_BITS_EQUAL(343,padding.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TAMEX4_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_PADDING()
template<typename __data_dest_t>
void PACKER_TAMEX4_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX4_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX4_SFP
//
//
// Generating code for: TAMEX4_TIME_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_TIME_DATA
class TAMEX4_TIME_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_TIME_DATA
class PACKER_TAMEX4_TIME_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                       ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                       ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_TIME_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
template<typename __data_src_t>
void TAMEX4_TIME_DATA::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                      ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                      ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_TIME_DATA",CT_OUT(NORM));
  }
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 coarse : 11; // 0..10
      uint32 is_leading : 1; // 11
      uint32 fine : 10; // 12..21
      uint32 channel : 6; // 22..27
      uint32 type : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 type : 4; // 28..31
      uint32 channel : 6; // 22..27
      uint32 fine : 10; // 12..21
      uint32 is_leading : 1; // 11
      uint32 coarse : 11; // 0..10
#endif
    };
    uint32  u32;
  } data;
  READ_FROM_BUFFER_FULL(426,uint32 ,data,data.u32,80);
  CHECK_BITS_EQUAL(420,data.type,8);
  {
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.append_item(421);
      __item.value = data.coarse;
    }
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.append_item(422);
      __item.value = data.fine;
    }
    {
      typedef __typeof__(*(&(time_edge))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_edge.append_item(423);
      __item.value = data.is_leading;
    }
    {
      typedef __typeof__(*(&(time_channel))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_channel.append_item(424);
      __item.value = data.channel;
    }
    {
      typedef __typeof__(*(&(time_epoch))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_epoch.append_item(425);
      __item.value = 0;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: data ", CT_OUT(BOLD), data.u32, CT_OUT(NORM));
    printf(".coarse=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.coarse, CT_OUT(NORM));
    printf(".is_leading=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.is_leading, CT_OUT(NORM));
    printf(".fine=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.fine, CT_OUT(NORM));
    printf(".channel=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.channel, CT_OUT(NORM));
    printf(".type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data.type, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_TIME_DATA::__unpack,uint32 sfp,uint32 card
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                           ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                           ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
template<typename __data_src_t>
bool TAMEX4_TIME_DATA::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 coarse : 11; // 0..10
      uint32 is_leading : 1; // 11
      uint32 fine : 10; // 12..21
      uint32 channel : 6; // 22..27
      uint32 type : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 type : 4; // 28..31
      uint32 channel : 6; // 22..27
      uint32 fine : 10; // 12..21
      uint32 is_leading : 1; // 11
      uint32 coarse : 11; // 0..10
#endif
    };
    uint32  u32;
  } data;
  MATCH_READ_FROM_BUFFER_FULL(426,uint32 ,data,data.u32,81);
  MATCH_BITS_EQUAL(420,data.type,8);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX4_TIME_DATA::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_TIME_DATA.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_TIME_DATA(sfp,card,time_coarse,time_fine,time_edge,time_channel,
                 // time_epoch)
template<typename __data_dest_t>
void PACKER_TAMEX4_TIME_DATA::__packer(__data_dest_t &__buffer,uint32 sfp
                                                              ,uint32 card
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_coarse
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_fine
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_edge
                                                              ,raw_list_ii_zero_suppress<DATA12,DATA12,1024> &time_channel
                                                              ,raw_list_ii_zero_suppress<DATA32,DATA32,1024> &time_epoch)
{
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 data NOENCODE
  // {
    //  0_10: coarse;
    //    11: is_leading;
    // 12_21: fine;
    // 22_27: channel;
    // 28_31: type = CHECK(8);
    // ENCODE(time_coarse APPEND_LIST,(value=coarse));
    // ENCODE(time_fine APPEND_LIST,(value=fine));
    // ENCODE(time_edge APPEND_LIST,(value=is_leading));
    // ENCODE(time_channel APPEND_LIST,(value=channel));
    // ENCODE(time_epoch APPEND_LIST,(value=0));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_TIME_DATA::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX4_SFP
class TAMEX4_SFP
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX4_SFP
class PACKER_TAMEX4_SFP
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 trig);
  DATA16 trig;
  // MEMBER(DATA32 event_size);
  DATA32 event_size;
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_coarse;
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_fine;
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_edge;
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,1024> time_channel;
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,1024> time_epoch;
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
    // ENCODE(event_size,(value=bytes));
  // }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
    // ENCODE(trig,(value=trigger_type));
  // }
  // list(0<=i<((data_size.bytes / 4) - 3))

    // select

      // epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                // time_fine=time_fine,time_edge=time_edge,
                                // time_channel=time_channel,time_epoch=time_epoch);
      // time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              // time_fine=time_fine,time_edge=time_edge,
                              // time_channel=time_channel,time_epoch=time_epoch);
    SINGLE(TAMEX4_EPOCH_DATA,epoch);
    SINGLE(TAMEX4_TIME_DATA,time);
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 187;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX4_SFP);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
template<typename __data_src_t>
void TAMEX4_SFP::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TAMEX4_SFP",CT_OUT(NORM));
  }
  // MEMBER(DATA16 trig);
  // MEMBER(DATA32 event_size);
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  READ_FROM_BUFFER_FULL(363,uint32 ,indicator,indicator.u32,82);
  CHECK_BITS_EQUAL(358,indicator.unnamed_0_7,52);
  CHECK_BITS_EQUAL(360,indicator.sfp,sfp);
  CHECK_BITS_EQUAL(361,indicator.card,card);
  CHECK_BITS_EQUAL(362,indicator.unnamed_24_31,0);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: indicator ", CT_OUT(BOLD), indicator.u32, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  indicator.trigger_type, CT_OUT(NORM));
    printf(".sfp=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  indicator.sfp, CT_OUT(NORM));
    printf(".card=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  indicator.card, CT_OUT(NORM));
    printf("\n");
  }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
    // ENCODE(event_size,(value=bytes));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bytes : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 bytes : 32; // 0..31
#endif
    };
    uint32  u32;
  } data_size;
  READ_FROM_BUFFER_FULL(369,uint32 ,data_size,data_size.u32,83);
  {
    event_size.value = data_size.bytes;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: data_size ", CT_OUT(BOLD), data_size.u32, CT_OUT(NORM));
    printf(".bytes=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  data_size.bytes, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
    // ENCODE(trig,(value=trigger_type));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 lec : 16; // 0..15
      uint32 buf_no : 1; // 16
      uint32 reserved : 3; // 17..19
      uint32 trigger_type : 4; // 20..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 trigger_type : 4; // 20..23
      uint32 reserved : 3; // 17..19
      uint32 buf_no : 1; // 16
      uint32 lec : 16; // 0..15
#endif
    };
    uint32  u32;
  } tdc_header;
  READ_FROM_BUFFER_FULL(378,uint32 ,tdc_header,tdc_header.u32,84);
  CHECK_BITS_EQUAL(376,tdc_header.unnamed_24_31,170);
  {
    trig.value = tdc_header.trigger_type;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_header ", CT_OUT(BOLD), tdc_header.u32, CT_OUT(NORM));
    printf(".lec=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.lec, CT_OUT(NORM));
    printf(".buf_no=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.buf_no, CT_OUT(NORM));
    printf(".reserved=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.reserved, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_header.trigger_type, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=i<((data_size.bytes / 4) - 3))

  for (uint32 i = 0; i < (uint32) (((data_size.bytes / 4) - 3)); ++i)
  {
    // select

      // epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                // time_fine=time_fine,time_edge=time_edge,
                                // time_channel=time_channel,time_epoch=time_epoch);
      // time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              // time_fine=time_fine,time_edge=time_edge,
                              // time_channel=time_channel,time_epoch=time_epoch);
    do
    {
      int __match_no = 0;
      // optimized match 1: TAMEX4_EPOCH_DATA epoch: (s32) => (0xf0000000,0x60000000)
      // optimized match 2: TAMEX4_TIME_DATA time: (s32) => (0xf0000000,0x80000000)
      {
      uint32 __match_peek;
      PEEK_FROM_BUFFER(389,uint32,__match_peek);
      // differ = e0000000 : 29 30 31
      uint32 __match_index = 0 | /* 29,31 */ ((__match_peek >> 29) & 0x00000007);
      static const sint8 __match_index_array[8] = { 0, 0, 0, 1, 2, 0, 0, 0, };
      __match_no = __match_index_array[__match_index];
      // last_subevent_item = 0
      }
      if (!__match_no) ERROR_U_LOC(389,"No match for select statement.");
      switch (__match_no)
      {
        case 1:
          CHECK_SPURIOUS_MATCH_DECL(385,spurious_match_abort_loop_2,TAMEX4_EPOCH_DATA,/*sfp*/sfp,/*card*/card/*,time_coarse:member*//*,time_fine:member*//*,time_edge:member*//*,time_channel:member*//*,time_epoch:member*/);
          UNPACK_DECL(385,TAMEX4_EPOCH_DATA,epoch,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
          break;
        case 2:
          CHECK_SPURIOUS_MATCH_DECL(388,spurious_match_abort_loop_2,TAMEX4_TIME_DATA,/*sfp*/sfp,/*card*/card/*,time_coarse:member*//*,time_fine:member*//*,time_edge:member*//*,time_channel:member*//*,time_epoch:member*/);
          UNPACK_DECL(388,TAMEX4_TIME_DATA,time,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
          break;
      }
    }
    while (0);
    spurious_match_abort_loop_2:;
  }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bits : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 bits : 24; // 0..23
#endif
    };
    uint32  u32;
  } error_bits;
  READ_FROM_BUFFER_FULL(395,uint32 ,error_bits,error_bits.u32,85);
  CHECK_BITS_EQUAL(394,error_bits.unnamed_24_31,238);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: error_bits ", CT_OUT(BOLD), error_bits.u32, CT_OUT(NORM));
    printf(".bits=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  error_bits.bits, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 187;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 lec : 16; // 0..15
      uint32 buf_no : 1; // 16
      uint32 reserved : 3; // 17..19
      uint32 trigger_type : 4; // 20..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 trigger_type : 4; // 20..23
      uint32 reserved : 3; // 17..19
      uint32 buf_no : 1; // 16
      uint32 lec : 16; // 0..15
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(403,uint32 ,trailer,trailer.u32,86);
  CHECK_BITS_EQUAL(402,trailer.unnamed_24_31,187);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".lec=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.lec, CT_OUT(NORM));
    printf(".buf_no=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.buf_no, CT_OUT(NORM));
    printf(".reserved=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.reserved, CT_OUT(NORM));
    printf(".trigger_type=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.trigger_type, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_SFP::__unpack,uint32 sfp,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
template<typename __data_src_t>
bool TAMEX4_SFP::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA16 trig);
  // MEMBER(DATA32 event_size);
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  MATCH_READ_FROM_BUFFER_FULL(363,uint32 ,indicator,indicator.u32,87);
  MATCH_BITS_EQUAL(358,indicator.unnamed_0_7,52);
  MATCH_BITS_EQUAL(360,indicator.sfp,sfp);
  MATCH_BITS_EQUAL(361,indicator.card,card);
  MATCH_BITS_EQUAL(362,indicator.unnamed_24_31,0);
  // MATCH_END;
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX4_SFP::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX4_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX4_SFP(sfp,card)
template<typename __data_dest_t>
void PACKER_TAMEX4_SFP::__packer(__data_dest_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA16 trig);
  // MEMBER(DATA32 event_size);
  // MEMBER(DATA12 time_coarse[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_fine[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_edge[1024] NO_INDEX_LIST);
  // MEMBER(DATA12 time_channel[1024] NO_INDEX_LIST);
  // MEMBER(DATA32 time_epoch[1024] NO_INDEX_LIST);
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
    // ENCODE(event_size,(value=bytes));
  // }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
    // ENCODE(trig,(value=trigger_type));
  // }
  // list(0<=i<((data_size.bytes / 4) - 3))

  {
    // select

      // epoch = TAMEX4_EPOCH_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                                // time_fine=time_fine,time_edge=time_edge,
                                // time_channel=time_channel,time_epoch=time_epoch);
      // time = TAMEX4_TIME_DATA(sfp=sfp,card=card,time_coarse=time_coarse,
                              // time_fine=time_fine,time_edge=time_edge,
                              // time_channel=time_channel,time_epoch=time_epoch);
    {
      PACK_DECL(385,TAMEX4_EPOCH_DATA,epoch,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
      PACK_DECL(388,TAMEX4_TIME_DATA,time,/*sfp*/sfp,/*card*/card,/*time_coarse*/time_coarse,/*time_fine*/time_fine,/*time_edge*/time_edge,/*time_channel*/time_channel,/*time_epoch*/time_epoch);
    }
  }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 187;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX4_SFP::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: TDC_DATA_V1190
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190()
#if !PACKER_CODE
# define DECLARED_UNPACK_TDC_DATA_V1190
class TDC_DATA_V1190
#else//PACKER_CODE
# define DECLARED_PACKER_TDC_DATA_V1190
class PACKER_TDC_DATA_V1190
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,128,128> data;
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA8,DATA8,128,128> leadOrTrail;
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TDC_DATA_V1190);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190()
template<typename __data_src_t>
void TDC_DATA_V1190::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TDC_DATA_V1190",CT_OUT(NORM));
  }
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 19; // 0..18
      uint32 chn : 7; // 19..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 7; // 19..25
      uint32 tdc : 19; // 0..18
#endif
    };
    uint32  u32;
  } tdc_data;
  READ_FROM_BUFFER_FULL(441,uint32 ,tdc_data,tdc_data.u32,88);
  CHECK_BITS_EQUAL(438,tdc_data.unnamed_27_31,0);
  {
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(439,tdc_data.chn);
      __item.value = tdc_data.tdc;
    }
    {
      typedef __typeof__(*(&(leadOrTrail))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = leadOrTrail.insert_index(440,tdc_data.chn);
      __item.value = tdc_data.lot;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: tdc_data ", CT_OUT(BOLD), tdc_data.u32, CT_OUT(NORM));
    printf(".tdc=%s%5" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.tdc, CT_OUT(NORM));
    printf(".chn=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.chn, CT_OUT(NORM));
    printf(".lot=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  tdc_data.lot, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_DATA_V1190::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190()
template<typename __data_src_t>
bool TDC_DATA_V1190::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tdc : 19; // 0..18
      uint32 chn : 7; // 19..25
      uint32 lot : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 lot : 1; // 26
      uint32 chn : 7; // 19..25
      uint32 tdc : 19; // 0..18
#endif
    };
    uint32  u32;
  } tdc_data;
  MATCH_READ_FROM_BUFFER_FULL(441,uint32 ,tdc_data,tdc_data.u32,89);
  MATCH_BITS_EQUAL(438,tdc_data.unnamed_27_31,0);
  {
  }
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TDC_DATA_V1190::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TDC_DATA_V1190.
 *
 * Do not edit - automatically generated.
 */

// TDC_DATA_V1190()
template<typename __data_dest_t>
void PACKER_TDC_DATA_V1190::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA24 data[128] ZERO_SUPPRESS_MULTI(128));
  // MEMBER(DATA8 leadOrTrail[128] ZERO_SUPPRESS_MULTI(128));
  // UINT32 tdc_data NOENCODE
  // {
    //  0_18: tdc;
    // 19_25: chn;
    //    26: lot;
    // 27_31: 0;
    // ENCODE(data[chn],(value=tdc));
    // ENCODE(leadOrTrail[chn],(value=lot));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TDC_DATA_V1190::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TIMESTAMP_WHITERABBIT",CT_OUT(NORM));
  }
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(509,uint32 ,header,header.u32,90);
  CHECK_BITS_EQUAL(504,header.id,id);
  CHECK_BITS_EQUAL(505,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(507,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".id=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.id, CT_OUT(NORM));
    printf(".error_bit=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.error_bit, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(515,uint32 ,d1,d1.u32,91);
  CHECK_BITS_EQUAL(513,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d1 ", CT_OUT(BOLD), d1.u32, CT_OUT(NORM));
    printf(".t1=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d1.t1, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(521,uint32 ,d2,d2.u32,92);
  CHECK_BITS_EQUAL(519,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d2 ", CT_OUT(BOLD), d2.u32, CT_OUT(NORM));
    printf(".t2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d2.t2, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(527,uint32 ,d3,d3.u32,93);
  CHECK_BITS_EQUAL(525,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d3 ", CT_OUT(BOLD), d3.u32, CT_OUT(NORM));
    printf(".t3=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d3.t3, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(533,uint32 ,d4,d4.u32,94);
  CHECK_BITS_EQUAL(531,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d4 ", CT_OUT(BOLD), d4.u32, CT_OUT(NORM));
    printf(".t4=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d4.t4, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(509,uint32 ,header,header.u32,95);
  MATCH_BITS_EQUAL(504,header.id,id);
  MATCH_BITS_EQUAL(505,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(507,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT_EXTENDED
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT_EXTENDED
class TIMESTAMP_WHITERABBIT_EXTENDED
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
class PACKER_TIMESTAMP_WHITERABBIT_EXTENDED
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 subsystem_id);
  DATA16 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT_EXTENDED);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT_EXTENDED::__unpack(__data_src_t &__buffer,uint32 id)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TIMESTAMP_WHITERABBIT_EXTENDED",CT_OUT(NORM));
  }
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(550,uint32 ,header,header.u32,96);
  CHECK_BITS_EQUAL(545,header.id,id);
  CHECK_BITS_EQUAL(546,header.unnamed_13_15,0);
  CHECK_BITS_EQUAL(548,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".id=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.id, CT_OUT(NORM));
    printf(".error_bit=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.error_bit, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(556,uint32 ,d1,d1.u32,97);
  CHECK_BITS_EQUAL(554,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d1 ", CT_OUT(BOLD), d1.u32, CT_OUT(NORM));
    printf(".t1=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d1.t1, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(562,uint32 ,d2,d2.u32,98);
  CHECK_BITS_EQUAL(560,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d2 ", CT_OUT(BOLD), d2.u32, CT_OUT(NORM));
    printf(".t2=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d2.t2, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(568,uint32 ,d3,d3.u32,99);
  CHECK_BITS_EQUAL(566,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d3 ", CT_OUT(BOLD), d3.u32, CT_OUT(NORM));
    printf(".t3=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d3.t3, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(574,uint32 ,d4,d4.u32,100);
  CHECK_BITS_EQUAL(572,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: d4 ", CT_OUT(BOLD), d4.u32, CT_OUT(NORM));
    printf(".t4=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  d4.t4, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT_EXTENDED::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 13; // 0..12
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_13_15 : 3; // 13..15
      uint32 id : 13; // 0..12
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(550,uint32 ,header,header.u32,101);
  MATCH_BITS_EQUAL(545,header.id,id);
  MATCH_BITS_EQUAL(546,header.unnamed_13_15,0);
  MATCH_BITS_EQUAL(548,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT_EXTENDED::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT_EXTENDED.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT_EXTENDED(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT_EXTENDED::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA16 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_12: id = MATCH(id);
    // 13_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT_EXTENDED::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TPAT_CRATE_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TPAT_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPAT_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_TPAT_CRATE_DATA
class TPAT_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TPAT_CRATE_DATA
class PACKER_TPAT_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 tpat);
  DATA16 tpat;
  // UINT32 w1;
  uint32  w1;
  // UINT32 w2;
  uint32  w2;
  // UINT32 w3;
  uint32  w3;
  // UINT32 trigger_pattern
  // {
    //  0_15: pattern;
    // 16_31: nothing;
    // ENCODE(tpat,(value=pattern));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 pattern : 16; // 0..15
      uint32 nothing : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 nothing : 16; // 16..31
      uint32 pattern : 16; // 0..15
#endif
    };
    uint32  u32;
  } trigger_pattern;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TPAT_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TPAT_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPAT_CRATE_DATA()
template<typename __data_src_t>
void TPAT_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TPAT_CRATE_DATA",CT_OUT(NORM));
  }
  // MEMBER(DATA16 tpat);
  // UINT32 w1;
  READ_FROM_BUFFER(580,uint32 ,w1,102);
  // UINT32 w2;
  READ_FROM_BUFFER(581,uint32 ,w2,103);
  // UINT32 w3;
  READ_FROM_BUFFER(582,uint32 ,w3,104);
  // UINT32 trigger_pattern
  // {
    //  0_15: pattern;
    // 16_31: nothing;
    // ENCODE(tpat,(value=pattern));
  // }
  READ_FROM_BUFFER_FULL(588,uint32 ,trigger_pattern,trigger_pattern.u32,105);
  {
    tpat.value = trigger_pattern.pattern;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trigger_pattern ", CT_OUT(BOLD), trigger_pattern.u32, CT_OUT(NORM));
    printf(".pattern=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trigger_pattern.pattern, CT_OUT(NORM));
    printf(".nothing=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trigger_pattern.nothing, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TPAT_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TPAT_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPAT_CRATE_DATA()
template<typename __data_src_t>
bool TPAT_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA16 tpat);
  // UINT32 w1;
  uint32  __w1;
  MATCH_READ_FROM_BUFFER(580,uint32 ,__w1,106);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TPAT_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TPAT_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPAT_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_TPAT_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA16 tpat);
  // UINT32 w1;
  // UINT32 w2;
  // UINT32 w3;
  // UINT32 trigger_pattern
  // {
    //  0_15: pattern;
    // 16_31: nothing;
    // ENCODE(tpat,(value=pattern));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TPAT_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TPC_CRATE_DATA
//
//
// Generating code for: VME_CAEN_V1190_N
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_N()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_N
class VME_CAEN_V1190_N
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_N
class PACKER_VME_CAEN_V1190_N
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 geo);
  DATA8 geo;
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: seven_f;
    // ENCODE(geo,(value=geom));
  // }
  // if((header.seven_f != 8))

    // UINT32 second1 NOENCODE
    // {
      //  0_31: 0xffffffff;
    // }
    // UINT32 real_header NOENCODE
    // {
      //  0_04: geom;
      //  5_26: event_count;
      // 27_31: 8;
    // }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1190();
    // tdc_error = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  SINGLE(TDC_HEADER,tdc_header);
  SINGLE(TDC_DATA_V1190,measurement);
  SINGLE(TDC_ERROR,tdc_error);
  SINGLE(TDC_TRAILER,tdc_trailer);
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geom;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: whatever;
  // }
  // optional UINT32 eob NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_N);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_N()
template<typename __data_src_t>
void VME_CAEN_V1190_N::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V1190_N",CT_OUT(NORM));
  }
  // MEMBER(DATA8 geo);
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: seven_f;
    // ENCODE(geo,(value=geom));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 seven_f : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 seven_f : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(680,uint32 ,header,header.u32,107);
  {
    geo.value = header.geom;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: header ", CT_OUT(BOLD), header.u32, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.geom, CT_OUT(NORM));
    printf(".event_count=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.event_count, CT_OUT(NORM));
    printf(".seven_f=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  header.seven_f, CT_OUT(NORM));
    printf("\n");
  }
  // if((header.seven_f != 8))

  if ((header.seven_f != 8))
  {
    // UINT32 second1 NOENCODE
    // {
      //  0_31: 0xffffffff;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } second1;
    READ_FROM_BUFFER_FULL(686,uint32 ,second1,second1.u32,108);
    CHECK_BITS_EQUAL(685,second1.unnamed_0_31,0xffffffff);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: second1 ", CT_OUT(BOLD), second1.u32, CT_OUT(NORM));
      printf("\n");
    }
    // UINT32 real_header NOENCODE
    // {
      //  0_04: geom;
      //  5_26: event_count;
      // 27_31: 8;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 geom : 5; // 0..4
        uint32 event_count : 22; // 5..26
        uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_27_31 : 5; // 27..31
        uint32 event_count : 22; // 5..26
        uint32 geom : 5; // 0..4
#endif
      };
      uint32  u32;
    } real_header;
    READ_FROM_BUFFER_FULL(692,uint32 ,real_header,real_header.u32,109);
    CHECK_BITS_EQUAL(691,real_header.unnamed_27_31,8);
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: real_header ", CT_OUT(BOLD), real_header.u32, CT_OUT(NORM));
      printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  real_header.geom, CT_OUT(NORM));
      printf(".event_count=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  real_header.event_count, CT_OUT(NORM));
      printf("\n");
    }
  }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1190();
    // tdc_error = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TDC_HEADER tdc_header: (s32) => (0xf8000000,0x08000000)
    // optimized match 2: TDC_DATA_V1190 measurement: (s32) => (0xf8000000,0x00000000)
    // optimized match 3: TDC_ERROR tdc_error: (s32) => (0xf8000000,0x20000000)
    // optimized match 4: TDC_TRAILER tdc_trailer: (s32) => (0xf8000000,0x18000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(700,uint32,__match_peek);
    // differ = 38000000 : 27 28 29
    uint32 __match_index = 0 | /* 27,29 */ ((__match_peek >> 27) & 0x00000007);
    static const sint8 __match_index_array[8] = { 2, 1, 0, 4, 3, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(696,spurious_match_abort_loop_3,TDC_HEADER);
        UNPACK_DECL(696,TDC_HEADER,tdc_header);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(697,spurious_match_abort_loop_3,TDC_DATA_V1190);
        UNPACK_DECL(697,TDC_DATA_V1190,measurement);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(698,spurious_match_abort_loop_3,TDC_ERROR);
        UNPACK_DECL(698,TDC_ERROR,tdc_error);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(699,spurious_match_abort_loop_3,TDC_TRAILER);
        UNPACK_DECL(699,TDC_TRAILER,tdc_trailer);
        break;
    }
  }
  spurious_match_abort_loop_3:;
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } ext_time_tag;
  if (__buffer.empty()) goto data_done_4;
  PEEK_FROM_BUFFER_FULL(705,uint32 ,ext_time_tag,ext_time_tag.u32,110);
  CHECK_JUMP_BITS_EQUAL(704,ext_time_tag.unnamed_27_31,17,data_done_4);
  __buffer.advance(sizeof(ext_time_tag.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: ext_time_tag ", CT_OUT(BOLD), ext_time_tag.u32, CT_OUT(NORM));
    printf(".time_tag=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  ext_time_tag.time_tag, CT_OUT(NORM));
    printf("\n");
  }
  data_done_4:;
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geom;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: whatever;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 16; // 5..20
      uint32 unused : 3; // 21..23
      uint32 tdc_error : 1; // 24
      uint32 overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 whatever : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 whatever : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 unused : 3; // 21..23
      uint32 word_count : 16; // 5..20
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(715,uint32 ,trailer,trailer.u32,111);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".geom=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.geom, CT_OUT(NORM));
    printf(".word_count=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.word_count, CT_OUT(NORM));
    printf(".unused=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.unused, CT_OUT(NORM));
    printf(".tdc_error=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.tdc_error, CT_OUT(NORM));
    printf(".overflow=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.overflow, CT_OUT(NORM));
    printf(".trigger_lost=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.trigger_lost, CT_OUT(NORM));
    printf(".whatever=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.whatever, CT_OUT(NORM));
    printf("\n");
  }
  // optional UINT32 eob NOENCODE;
  uint32  eob;if (__buffer.empty()) goto data_done_5;
  READ_FROM_BUFFER(716,uint32 ,eob,112);
  data_done_5:;
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1190_N::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_N()
template<typename __data_src_t>
bool VME_CAEN_V1190_N::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA8 geo);
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: seven_f;
    // ENCODE(geo,(value=geom));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_count : 22; // 5..26
      uint32 seven_f : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 seven_f : 5; // 27..31
      uint32 event_count : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  MATCH_READ_FROM_BUFFER_FULL(680,uint32 ,header,header.u32,113);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_CAEN_V1190_N::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_N.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_N()
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_N::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA8 geo);
  // UINT32 header NOENCODE
  // {
    //  0_04: geom;
    //  5_26: event_count;
    // 27_31: seven_f;
    // ENCODE(geo,(value=geom));
  // }
  // if((header.seven_f != 8))

  if ((header.seven_f != 8))
  {
    // UINT32 second1 NOENCODE
    // {
      //  0_31: 0xffffffff;
    // }
    // UINT32 real_header NOENCODE
    // {
      //  0_04: geom;
      //  5_26: event_count;
      // 27_31: 8;
    // }
  }
  // select several

    // tdc_header = TDC_HEADER();
    // measurement = TDC_DATA_V1190();
    // tdc_error = TDC_ERROR();
    // tdc_trailer = TDC_TRAILER();
  {
    PACK_DECL(696,TDC_HEADER,tdc_header);
    PACK_DECL(697,TDC_DATA_V1190,measurement);
    PACK_DECL(698,TDC_ERROR,tdc_error);
    PACK_DECL(699,TDC_TRAILER,tdc_trailer);
  }
  // optional UINT32 ext_time_tag NOENCODE
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_04: geom;
    //  5_20: word_count;
    // 21_23: unused;
    //    24: tdc_error;
    //    25: overflow;
    //    26: trigger_lost;
    // 27_31: whatever;
  // }
  // optional UINT32 eob NOENCODE;
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CAEN_V1190_N::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_TPC_CRATE_DATA
class TPC_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TPC_CRATE_DATA
class PACKER_TPC_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // select several

    // barrier0 = BARRIER();
    // v785 = VME_CAEN_V7X5(geom=8);
    // v775 = VME_CAEN_V7X5(geom=12);
  SINGLE(BARRIER,barrier0);
  SINGLE(VME_CAEN_V7X5,v785);
  SINGLE(VME_CAEN_V7X5,v775);
  // UINT32 aaahhh NOENCODE
  // {
    //  0_31: 0xaaaa1190;
  // }
  // UINT32 exxxxx NOENCODE;
  // barrier[2] = BARRIER();
  // v1190 = VME_CAEN_V1190_N();
  SINGLE(BARRIER,barrier[3]);
  SINGLE(VME_CAEN_V1190_N,v1190);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TPC_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
template<typename __data_src_t>
void TPC_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TPC_CRATE_DATA",CT_OUT(NORM));
  }
  // select several

    // barrier0 = BARRIER();
    // v785 = VME_CAEN_V7X5(geom=8);
    // v775 = VME_CAEN_V7X5(geom=12);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: BARRIER barrier0: (s32) => (0xff000000,0xf5000000)
    // optimized match 2: VME_CAEN_V7X5 v785: (s32) => (0xff00c000,0x42000000)
    // optimized match 3: VME_CAEN_V7X5 v775: (s32) => (0xff00c000,0x62000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(598,uint32,__match_peek);
    // differ = b7000000 : 24 25 26 28 29 31
    uint32 __match_index = 0 | /* 24,26 */ ((__match_peek >> 24) & 0x00000007) | /* 28,29 */ ((__match_peek >> 25) & 0x00000018) | /* 31,31 */ ((__match_peek >> 26) & 0x00000020);
    static const sint8 __match_index_array[64] = { 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(595,spurious_match_abort_loop_4,BARRIER);
        UNPACK_DECL(595,BARRIER,barrier0);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(596,spurious_match_abort_loop_4,VME_CAEN_V7X5,/*geom*/8);
        UNPACK_DECL(596,VME_CAEN_V7X5,v785,/*geom*/8);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(597,spurious_match_abort_loop_4,VME_CAEN_V7X5,/*geom*/12);
        UNPACK_DECL(597,VME_CAEN_V7X5,v775,/*geom*/12);
        break;
    }
  }
  spurious_match_abort_loop_4:;
  // UINT32 aaahhh NOENCODE
  // {
    //  0_31: 0xaaaa1190;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } aaahhh;
  READ_FROM_BUFFER_FULL(602,uint32 ,aaahhh,aaahhh.u32,114);
  CHECK_BITS_EQUAL(601,aaahhh.unnamed_0_31,0xaaaa1190);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: aaahhh ", CT_OUT(BOLD), aaahhh.u32, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 exxxxx NOENCODE;
  uint32  exxxxx;READ_FROM_BUFFER(603,uint32 ,exxxxx,115);
  // barrier[2] = BARRIER();
  UNPACK_DECL(604,BARRIER,barrier[2]);
  // v1190 = VME_CAEN_V1190_N();
  UNPACK_DECL(605,VME_CAEN_V1190_N,v1190);
}
FORCE_IMPL_DATA_SRC_FCN(void,TPC_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
template<typename __data_src_t>
bool TPC_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // select several

    // barrier0 = BARRIER();
    // v785 = VME_CAEN_V7X5(geom=8);
    // v775 = VME_CAEN_V7X5(geom=12);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    MATCH_DECL(595,__match_no,1,BARRIER,barrier0);
    MATCH_DECL(596,__match_no,2,VME_CAEN_V7X5,v785,/*geom*/8);
    MATCH_DECL(597,__match_no,3,VME_CAEN_V7X5,v775,/*geom*/12);
    if (!__match_no) break;
    return true;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TPC_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TPC_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// TPC_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_TPC_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // select several

    // barrier0 = BARRIER();
    // v785 = VME_CAEN_V7X5(geom=8);
    // v775 = VME_CAEN_V7X5(geom=12);
  {
    PACK_DECL(595,BARRIER,barrier0);
    PACK_DECL(596,VME_CAEN_V7X5,v785,/*geom*/8);
    PACK_DECL(597,VME_CAEN_V7X5,v775,/*geom*/12);
  }
  // UINT32 aaahhh NOENCODE
  // {
    //  0_31: 0xaaaa1190;
  // }
  // UINT32 exxxxx NOENCODE;
  // barrier[2] = BARRIER();
  PACK_DECL(604,BARRIER,barrier[2]);
  // v1190 = VME_CAEN_V1190_N();
  PACK_DECL(605,VME_CAEN_V1190_N,v1190);
}
FORCE_IMPL_DATA_SRC_FCN(void,TPC_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TRIG3EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
#if !PACKER_CODE
# define DECLARED_UNPACK_TRIG3EVENT
class TRIG3EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_TRIG3EVENT
class PACKER_TRIG3EVENT
#endif//PACKER_CODE

{
public:
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRIG3EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
template<typename __data_src_t>
void TRIG3EVENT::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "TRIG3EVENT",CT_OUT(NORM));
  }
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } trig3;
  READ_FROM_BUFFER_FULL(653,uint32 ,trig3,trig3.u32,116);
  CHECK_BITS_EQUAL(652,trig3.unnamed_0_31,0x20202020);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trig3 ", CT_OUT(BOLD), trig3.u32, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRIG3EVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
template<typename __data_src_t>
bool TRIG3EVENT::__match(__data_src_t &__buffer)
{
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } trig3;
  MATCH_READ_FROM_BUFFER_FULL(653,uint32 ,trig3,trig3.u32,117);
  MATCH_BITS_EQUAL(652,trig3.unnamed_0_31,0x20202020);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TRIG3EVENT::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRIG3EVENT.
 *
 * Do not edit - automatically generated.
 */

// TRIG3EVENT()
template<typename __data_dest_t>
void PACKER_TRIG3EVENT::__packer(__data_dest_t &__buffer)
{
  // UINT32 trig3 NOENCODE
  // {
    //  0_31: 0x20202020;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRIG3EVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: USER_CRATE_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
#if !PACKER_CODE
# define DECLARED_UNPACK_USER_CRATE_DATA
class USER_CRATE_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_USER_CRATE_DATA
class PACKER_USER_CRATE_DATA
#endif//PACKER_CODE

{
public:
  // barrier0 = BARRIER();
  // v830 = VME_CAEN_V830(geom=6);
  // filler0 = ZERO_FILLER();
  // select several

    // barrier1 = BARRIER();
    // v775[0] = VME_CAEN_V7X5(geom=8);
    // v775[1] = VME_CAEN_V7X5(geom=9);
    // v785[0] = VME_CAEN_V7X5(geom=10);
    // v785[1] = VME_CAEN_V7X5(geom=12);
  SINGLE(BARRIER,barrier1);
  SINGLE(VME_CAEN_V7X5,v775[2]);
  SINGLE(VME_CAEN_V7X5,v785[2]);
  SINGLE(BARRIER,barrier0);
  SINGLE(VME_CAEN_V830,v830);
  SINGLE(ZERO_FILLER,filler0);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(USER_CRATE_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
template<typename __data_src_t>
void USER_CRATE_DATA::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "USER_CRATE_DATA",CT_OUT(NORM));
  }
  // barrier0 = BARRIER();
  UNPACK_DECL(658,BARRIER,barrier0);
  // v830 = VME_CAEN_V830(geom=6);
  UNPACK_DECL(659,VME_CAEN_V830,v830,/*geom*/6);
  // filler0 = ZERO_FILLER();
  UNPACK_DECL(660,ZERO_FILLER,filler0);
  // select several

    // barrier1 = BARRIER();
    // v775[0] = VME_CAEN_V7X5(geom=8);
    // v775[1] = VME_CAEN_V7X5(geom=9);
    // v785[0] = VME_CAEN_V7X5(geom=10);
    // v785[1] = VME_CAEN_V7X5(geom=12);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: BARRIER barrier1: (s32) => (0xff000000,0xf5000000)
    // optimized match 2: VME_CAEN_V7X5 v775[0]: (s32) => (0xff00c000,0x42000000)
    // optimized match 3: VME_CAEN_V7X5 v775[1]: (s32) => (0xff00c000,0x4a000000)
    // optimized match 4: VME_CAEN_V7X5 v785[0]: (s32) => (0xff00c000,0x52000000)
    // optimized match 5: VME_CAEN_V7X5 v785[1]: (s32) => (0xff00c000,0x62000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(668,uint32,__match_peek);
    // differ = bf000000 : 24 25 26 27 28 29 31
    uint32 __match_index = 0 | /* 24,29 */ ((__match_peek >> 24) & 0x0000003f) | /* 31,31 */ ((__match_peek >> 25) & 0x00000040);
    static const sint8 __match_index_array[128] = { 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(663,spurious_match_abort_loop_5,BARRIER);
        UNPACK_DECL(663,BARRIER,barrier1);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(664,spurious_match_abort_loop_5,VME_CAEN_V7X5,/*geom*/8);
        UNPACK_DECL(664,VME_CAEN_V7X5,v775[0],/*geom*/8);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(665,spurious_match_abort_loop_5,VME_CAEN_V7X5,/*geom*/9);
        UNPACK_DECL(665,VME_CAEN_V7X5,v775[1],/*geom*/9);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(666,spurious_match_abort_loop_5,VME_CAEN_V7X5,/*geom*/10);
        UNPACK_DECL(666,VME_CAEN_V7X5,v785[0],/*geom*/10);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(667,spurious_match_abort_loop_5,VME_CAEN_V7X5,/*geom*/12);
        UNPACK_DECL(667,VME_CAEN_V7X5,v785[1],/*geom*/12);
        break;
    }
  }
  spurious_match_abort_loop_5:;
}
FORCE_IMPL_DATA_SRC_FCN(void,USER_CRATE_DATA::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
template<typename __data_src_t>
bool USER_CRATE_DATA::__match(__data_src_t &__buffer)
{
  // barrier0 = BARRIER();
  MATCH_SUB_DECL(658,BARRIER,barrier0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,USER_CRATE_DATA::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for USER_CRATE_DATA.
 *
 * Do not edit - automatically generated.
 */

// USER_CRATE_DATA()
template<typename __data_dest_t>
void PACKER_USER_CRATE_DATA::__packer(__data_dest_t &__buffer)
{
  // barrier0 = BARRIER();
  PACK_DECL(658,BARRIER,barrier0);
  // v830 = VME_CAEN_V830(geom=6);
  PACK_DECL(659,VME_CAEN_V830,v830,/*geom*/6);
  // filler0 = ZERO_FILLER();
  PACK_DECL(660,ZERO_FILLER,filler0);
  // select several

    // barrier1 = BARRIER();
    // v775[0] = VME_CAEN_V7X5(geom=8);
    // v775[1] = VME_CAEN_V7X5(geom=9);
    // v785[0] = VME_CAEN_V7X5(geom=10);
    // v785[1] = VME_CAEN_V7X5(geom=12);
  {
    PACK_DECL(663,BARRIER,barrier1);
    PACK_DECL(664,VME_CAEN_V7X5,v775[0],/*geom*/8);
    PACK_DECL(665,VME_CAEN_V7X5,v775[1],/*geom*/9);
    PACK_DECL(666,VME_CAEN_V7X5,v785[0],/*geom*/10);
    PACK_DECL(667,VME_CAEN_V7X5,v785[1],/*geom*/12);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,USER_CRATE_DATA::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1751
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1751.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1751(board)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1751
class VME_CAEN_V1751
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1751
class PACKER_VME_CAEN_V1751
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 board_id);
  DATA8 board_id;
  // MEMBER(DATA8 channels);
  DATA8 channels;
  // MEMBER(DATA32 board_time);
  DATA32 board_time;
  // MEMBER(DATA32 channel_time[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,64> channel_time;
  // MEMBER(DATA16 chan_ext_time[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,64> chan_ext_time;
  // MEMBER(DATA12 chan_fine_time[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA12,DATA12,64> chan_fine_time;
  // MEMBER(DATA16 qshort[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,64> qshort;
  // MEMBER(DATA16 qlong[64] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,64> qlong;
  // UINT32 board_agg_size NOENCODE
  // {
    //  0_27: event_size;
    // 28_31: 10;
  // }
  // UINT32 board_details NOENCODE
  // {
    //  0_07: channels;
    //  8_23: pattern;
    // 24_25: empty;
    //    26: board_fail;
    // 27_31: id = MATCH(board);
    // ENCODE(channels,(value=channels));
    // ENCODE(board_id,(value=id));
  // }
  // UINT32 board_agg_counter NOENCODE
  // {
    //  0_22: counter;
    // 23_31: empty;
  // }
  // UINT32 board_agg_timetag NOENCODE
  // {
    //  0_31: time_tag;
    // ENCODE(board_time,(value=time_tag));
  // }
  // if((board_agg_size.event_size > 4))

    // list(0<=index<((board_agg_size.event_size - 4) / 6))

      // UINT32 channel_agg_size NOENCODE
      // {
        //  0_21: size;
        // 22_27: empty;
        // 28_31: format;
      // }
      // UINT32 format_one NOENCODE
      // {
        //  0_15: no_wave_samples;
        // 16_17: empty;
        //    18: ed;
        // 19_21: dp1;
        // 22_24: dp2;
        // 25_26: ap;
        //    27: es;
        //    28: ee;
        //    29: et;
        //    30: eq;
        //    31: dt;
      // }
      // if((channel_agg_size.format == 4))

      // else

        // UINT32 format_two NOENCODE
        // {
          //  0_02: ex;
          //     3: pp;
          //     4: dm;
          //  5_07: interp;
          //  8_31: empty;
        // }
        // if((format_one.et == 1))

          // UINT32 channel_time_tag NOENCODE
          // {
            //  0_31: time_tag;
            // ENCODE(channel_time APPEND_LIST,(value=time_tag));
          // }
        // if(((format_one.ee == 1) && (channel_agg_size.format == 4)))

          // if((format_two.ex == 0))

          // else

            // UINT32 extras NOENCODE
            // {
              //  0_15: baseline;
              // 16_31: ext_time;
              // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
            // }
            // if((format_two.ex == 1))

            // else

              // UINT32 extras NOENCODE
              // {
                //  0_15: flags;
                // 16_31: ext_time;
                // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
              // }
              // if((format_two.ex == 2))

              // else

                // UINT32 extras NOENCODE
                // {
                  //  0_09: fine_time;
                  // 10_15: flags;
                  // 16_31: ext_time;
                  // ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
                // }
                // if((format_two.ex == 4))

                // else

                  // UINT32 extras NOENCODE
                  // {
                    //  0_15: baseline;
                    // 16_26: fine_time;
                    // 27_31: flags;
                    // ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  // }
                  // if((format_two.ex == 5))

                    // UINT32 extras NOENCODE
                    // {
                      //  0_09: midscale;
                      // 10_19: sazc;
                      // 20_29: sbzc;
                      //    30: pp;
                      //    31: dm;
                    // }
        // if((format_one.et == 1))

          // UINT32 channel_time_tag NOENCODE
          // {
            //  0_31: time_tag;
            // ENCODE(channel_time APPEND_LIST,(value=time_tag));
          // }
      // if((format_one.eq == 1))

        // UINT32 qdata NOENCODE
        // {
          //  0_14: qshort;
          //    15: empty;
          // 16_31: qlong;
          // ENCODE(qshort APPEND_LIST,(value=qshort));
          // ENCODE(qlong APPEND_LIST,(value=qlong));
        // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 board);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 board);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 board);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1751);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1751.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1751(board)
template<typename __data_src_t>
void VME_CAEN_V1751::__unpack(__data_src_t &__buffer,uint32 board)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "VME_CAEN_V1751",CT_OUT(NORM));
  }
  // MEMBER(DATA8 board_id);
  // MEMBER(DATA8 channels);
  // MEMBER(DATA32 board_time);
  // MEMBER(DATA32 channel_time[64] NO_INDEX_LIST);
  // MEMBER(DATA16 chan_ext_time[64] NO_INDEX_LIST);
  // MEMBER(DATA12 chan_fine_time[64] NO_INDEX_LIST);
  // MEMBER(DATA16 qshort[64] NO_INDEX_LIST);
  // MEMBER(DATA16 qlong[64] NO_INDEX_LIST);
  // UINT32 board_agg_size NOENCODE
  // {
    //  0_27: event_size;
    // 28_31: 10;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_size : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 event_size : 28; // 0..27
#endif
    };
    uint32  u32;
  } board_agg_size;
  READ_FROM_BUFFER_FULL(767,uint32 ,board_agg_size,board_agg_size.u32,118);
  CHECK_BITS_EQUAL(766,board_agg_size.unnamed_28_31,10);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: board_agg_size ", CT_OUT(BOLD), board_agg_size.u32, CT_OUT(NORM));
    printf(".event_size=%s%7" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_agg_size.event_size, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 board_details NOENCODE
  // {
    //  0_07: channels;
    //  8_23: pattern;
    // 24_25: empty;
    //    26: board_fail;
    // 27_31: id = MATCH(board);
    // ENCODE(channels,(value=channels));
    // ENCODE(board_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 channels : 8; // 0..7
      uint32 pattern : 16; // 8..23
      uint32 empty : 2; // 24..25
      uint32 board_fail : 1; // 26
      uint32 id : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 5; // 27..31
      uint32 board_fail : 1; // 26
      uint32 empty : 2; // 24..25
      uint32 pattern : 16; // 8..23
      uint32 channels : 8; // 0..7
#endif
    };
    uint32  u32;
  } board_details;
  READ_FROM_BUFFER_FULL(777,uint32 ,board_details,board_details.u32,119);
  CHECK_BITS_EQUAL(774,board_details.id,board);
  {
    {
      channels.value = board_details.channels;
    }
    {
      board_id.value = board_details.id;
    }
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: board_details ", CT_OUT(BOLD), board_details.u32, CT_OUT(NORM));
    printf(".channels=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_details.channels, CT_OUT(NORM));
    printf(".pattern=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_details.pattern, CT_OUT(NORM));
    printf(".empty=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_details.empty, CT_OUT(NORM));
    printf(".board_fail=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_details.board_fail, CT_OUT(NORM));
    printf(".id=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_details.id, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 board_agg_counter NOENCODE
  // {
    //  0_22: counter;
    // 23_31: empty;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 23; // 0..22
      uint32 empty : 9; // 23..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 empty : 9; // 23..31
      uint32 counter : 23; // 0..22
#endif
    };
    uint32  u32;
  } board_agg_counter;
  READ_FROM_BUFFER_FULL(782,uint32 ,board_agg_counter,board_agg_counter.u32,120);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: board_agg_counter ", CT_OUT(BOLD), board_agg_counter.u32, CT_OUT(NORM));
    printf(".counter=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_agg_counter.counter, CT_OUT(NORM));
    printf(".empty=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_agg_counter.empty, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 board_agg_timetag NOENCODE
  // {
    //  0_31: time_tag;
    // ENCODE(board_time,(value=time_tag));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time_tag : 32; // 0..31
#endif
    };
    uint32  u32;
  } board_agg_timetag;
  READ_FROM_BUFFER_FULL(787,uint32 ,board_agg_timetag,board_agg_timetag.u32,121);
  {
    board_time.value = board_agg_timetag.time_tag;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: board_agg_timetag ", CT_OUT(BOLD), board_agg_timetag.u32, CT_OUT(NORM));
    printf(".time_tag=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  board_agg_timetag.time_tag, CT_OUT(NORM));
    printf("\n");
  }
  // if((board_agg_size.event_size > 4))

  if ((board_agg_size.event_size > 4))
  {
    // list(0<=index<((board_agg_size.event_size - 4) / 6))

    for (uint32 index = 0; index < (uint32) (((board_agg_size.event_size - 4) / 6)); ++index)
    {
      // UINT32 channel_agg_size NOENCODE
      // {
        //  0_21: size;
        // 22_27: empty;
        // 28_31: format;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 size : 22; // 0..21
          uint32 empty : 6; // 22..27
          uint32 format : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 format : 4; // 28..31
          uint32 empty : 6; // 22..27
          uint32 size : 22; // 0..21
#endif
        };
        uint32  u32;
      } channel_agg_size;
      READ_FROM_BUFFER_FULL(797,uint32 ,channel_agg_size,channel_agg_size.u32,122);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: channel_agg_size ", CT_OUT(BOLD), channel_agg_size.u32, CT_OUT(NORM));
        printf(".size=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_agg_size.size, CT_OUT(NORM));
        printf(".empty=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_agg_size.empty, CT_OUT(NORM));
        printf(".format=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_agg_size.format, CT_OUT(NORM));
        printf("\n");
      }
      // UINT32 format_one NOENCODE
      // {
        //  0_15: no_wave_samples;
        // 16_17: empty;
        //    18: ed;
        // 19_21: dp1;
        // 22_24: dp2;
        // 25_26: ap;
        //    27: es;
        //    28: ee;
        //    29: et;
        //    30: eq;
        //    31: dt;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 no_wave_samples : 16; // 0..15
          uint32 empty : 2; // 16..17
          uint32 ed : 1; // 18
          uint32 dp1 : 3; // 19..21
          uint32 dp2 : 3; // 22..24
          uint32 ap : 2; // 25..26
          uint32 es : 1; // 27
          uint32 ee : 1; // 28
          uint32 et : 1; // 29
          uint32 eq : 1; // 30
          uint32 dt : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 dt : 1; // 31
          uint32 eq : 1; // 30
          uint32 et : 1; // 29
          uint32 ee : 1; // 28
          uint32 es : 1; // 27
          uint32 ap : 2; // 25..26
          uint32 dp2 : 3; // 22..24
          uint32 dp1 : 3; // 19..21
          uint32 ed : 1; // 18
          uint32 empty : 2; // 16..17
          uint32 no_wave_samples : 16; // 0..15
#endif
        };
        uint32  u32;
      } format_one;
      READ_FROM_BUFFER_FULL(811,uint32 ,format_one,format_one.u32,123);
      if (__buffer.is_memberdump())
      {
        printf("%s%08" PRIx32 "%s: format_one ", CT_OUT(BOLD), format_one.u32, CT_OUT(NORM));
        printf(".no_wave_samples=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.no_wave_samples, CT_OUT(NORM));
        printf(".empty=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.empty, CT_OUT(NORM));
        printf(".ed=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.ed, CT_OUT(NORM));
        printf(".dp1=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.dp1, CT_OUT(NORM));
        printf(".dp2=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.dp2, CT_OUT(NORM));
        printf(".ap=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.ap, CT_OUT(NORM));
        printf(".es=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.es, CT_OUT(NORM));
        printf(".ee=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.ee, CT_OUT(NORM));
        printf(".et=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.et, CT_OUT(NORM));
        printf(".eq=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.eq, CT_OUT(NORM));
        printf(".dt=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_one.dt, CT_OUT(NORM));
        printf("\n");
      }
      // if((channel_agg_size.format == 4))

      // else

      if ((channel_agg_size.format == 4))
      {
        // UINT32 format_two NOENCODE
        // {
          //  0_02: ex;
          //     3: pp;
          //     4: dm;
          //  5_07: interp;
          //  8_31: empty;
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 ex : 3; // 0..2
            uint32 pp : 1; // 3
            uint32 dm : 1; // 4
            uint32 interp : 3; // 5..7
            uint32 empty : 24; // 8..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 empty : 24; // 8..31
            uint32 interp : 3; // 5..7
            uint32 dm : 1; // 4
            uint32 pp : 1; // 3
            uint32 ex : 3; // 0..2
#endif
          };
          uint32  u32;
        } format_two;
        READ_FROM_BUFFER_FULL(821,uint32 ,format_two,format_two.u32,124);
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: format_two ", CT_OUT(BOLD), format_two.u32, CT_OUT(NORM));
          printf(".ex=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_two.ex, CT_OUT(NORM));
          printf(".pp=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_two.pp, CT_OUT(NORM));
          printf(".dm=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_two.dm, CT_OUT(NORM));
          printf(".interp=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_two.interp, CT_OUT(NORM));
          printf(".empty=%s%6" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  format_two.empty, CT_OUT(NORM));
          printf("\n");
        }
        // if((format_one.et == 1))

        if ((format_one.et == 1))
        {
          // UINT32 channel_time_tag NOENCODE
          // {
            //  0_31: time_tag;
            // ENCODE(channel_time APPEND_LIST,(value=time_tag));
          // }
          union
          {
            struct
            {
#if __BYTE_ORDER == __LITTLE_ENDIAN
              uint32 time_tag : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
              uint32 time_tag : 32; // 0..31
#endif
            };
            uint32  u32;
          } channel_time_tag;
          READ_FROM_BUFFER_FULL(828,uint32 ,channel_time_tag,channel_time_tag.u32,125);
          {
            typedef __typeof__(*(&(channel_time))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = channel_time.append_item(827);
            __item.value = channel_time_tag.time_tag;
          }
          if (__buffer.is_memberdump())
          {
            printf("%s%08" PRIx32 "%s: channel_time_tag ", CT_OUT(BOLD), channel_time_tag.u32, CT_OUT(NORM));
            printf(".time_tag=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_time_tag.time_tag, CT_OUT(NORM));
            printf("\n");
          }
        }
        // if(((format_one.ee == 1) && (channel_agg_size.format == 4)))

        if (((format_one.ee == 1) && (channel_agg_size.format == 4)))
        {
          // if((format_two.ex == 0))

          // else

          if ((format_two.ex == 0))
          {
            // UINT32 extras NOENCODE
            // {
              //  0_15: baseline;
              // 16_31: ext_time;
              // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
            // }
            union
            {
              struct
              {
#if __BYTE_ORDER == __LITTLE_ENDIAN
                uint32 baseline : 16; // 0..15
                uint32 ext_time : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
                uint32 ext_time : 16; // 16..31
                uint32 baseline : 16; // 0..15
#endif
              };
              uint32  u32;
            } extras;
            READ_FROM_BUFFER_FULL(839,uint32 ,extras,extras.u32,126);
            {
              typedef __typeof__(*(&(chan_ext_time))) __array_t;
              typedef typename __array_t::item_t __item_t;
              __item_t &__item = chan_ext_time.append_item(838);
              __item.value = extras.ext_time;
            }
            if (__buffer.is_memberdump())
            {
              printf("%s%08" PRIx32 "%s: extras ", CT_OUT(BOLD), extras.u32, CT_OUT(NORM));
              printf(".baseline=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.baseline, CT_OUT(NORM));
              printf(".ext_time=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.ext_time, CT_OUT(NORM));
              printf("\n");
            }
          }

          else
          {
            // if((format_two.ex == 1))

            // else

            if ((format_two.ex == 1))
            {
              // UINT32 extras NOENCODE
              // {
                //  0_15: flags;
                // 16_31: ext_time;
                // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
              // }
              union
              {
                struct
                {
#if __BYTE_ORDER == __LITTLE_ENDIAN
                  uint32 flags : 16; // 0..15
                  uint32 ext_time : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
                  uint32 ext_time : 16; // 16..31
                  uint32 flags : 16; // 0..15
#endif
                };
                uint32  u32;
              } extras;
              READ_FROM_BUFFER_FULL(850,uint32 ,extras,extras.u32,127);
              {
                typedef __typeof__(*(&(chan_ext_time))) __array_t;
                typedef typename __array_t::item_t __item_t;
                __item_t &__item = chan_ext_time.append_item(849);
                __item.value = extras.ext_time;
              }
              if (__buffer.is_memberdump())
              {
                printf("%s%08" PRIx32 "%s: extras ", CT_OUT(BOLD), extras.u32, CT_OUT(NORM));
                printf(".flags=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.flags, CT_OUT(NORM));
                printf(".ext_time=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.ext_time, CT_OUT(NORM));
                printf("\n");
              }
            }

            else
            {
              // if((format_two.ex == 2))

              // else

              if ((format_two.ex == 2))
              {
                // UINT32 extras NOENCODE
                // {
                  //  0_09: fine_time;
                  // 10_15: flags;
                  // 16_31: ext_time;
                  // ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
                // }
                union
                {
                  struct
                  {
#if __BYTE_ORDER == __LITTLE_ENDIAN
                    uint32 fine_time : 10; // 0..9
                    uint32 flags : 6; // 10..15
                    uint32 ext_time : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
                    uint32 ext_time : 16; // 16..31
                    uint32 flags : 6; // 10..15
                    uint32 fine_time : 10; // 0..9
#endif
                  };
                  uint32  u32;
                } extras;
                READ_FROM_BUFFER_FULL(863,uint32 ,extras,extras.u32,128);
                {
                  {
                    typedef __typeof__(*(&(chan_fine_time))) __array_t;
                    typedef typename __array_t::item_t __item_t;
                    __item_t &__item = chan_fine_time.append_item(861);
                    __item.value = extras.fine_time;
                  }
                  {
                    typedef __typeof__(*(&(chan_ext_time))) __array_t;
                    typedef typename __array_t::item_t __item_t;
                    __item_t &__item = chan_ext_time.append_item(862);
                    __item.value = extras.ext_time;
                  }
                }
                if (__buffer.is_memberdump())
                {
                  printf("%s%08" PRIx32 "%s: extras ", CT_OUT(BOLD), extras.u32, CT_OUT(NORM));
                  printf(".fine_time=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.fine_time, CT_OUT(NORM));
                  printf(".flags=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.flags, CT_OUT(NORM));
                  printf(".ext_time=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.ext_time, CT_OUT(NORM));
                  printf("\n");
                }
              }

              else
              {
                // if((format_two.ex == 4))

                // else

                if ((format_two.ex == 4))
                {
                  // UINT32 extras NOENCODE
                  // {
                    //  0_15: baseline;
                    // 16_26: fine_time;
                    // 27_31: flags;
                    // ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  // }
                  union
                  {
                    struct
                    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
                      uint32 baseline : 16; // 0..15
                      uint32 fine_time : 11; // 16..26
                      uint32 flags : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
                      uint32 flags : 5; // 27..31
                      uint32 fine_time : 11; // 16..26
                      uint32 baseline : 16; // 0..15
#endif
                    };
                    uint32  u32;
                  } extras;
                  READ_FROM_BUFFER_FULL(875,uint32 ,extras,extras.u32,129);
                  {
                    typedef __typeof__(*(&(chan_fine_time))) __array_t;
                    typedef typename __array_t::item_t __item_t;
                    __item_t &__item = chan_fine_time.append_item(874);
                    __item.value = extras.fine_time;
                  }
                  if (__buffer.is_memberdump())
                  {
                    printf("%s%08" PRIx32 "%s: extras ", CT_OUT(BOLD), extras.u32, CT_OUT(NORM));
                    printf(".baseline=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.baseline, CT_OUT(NORM));
                    printf(".fine_time=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.fine_time, CT_OUT(NORM));
                    printf(".flags=%s%2" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.flags, CT_OUT(NORM));
                    printf("\n");
                  }
                }

                else
                {
                  // if((format_two.ex == 5))

                  if ((format_two.ex == 5))
                  {
                    // UINT32 extras NOENCODE
                    // {
                      //  0_09: midscale;
                      // 10_19: sazc;
                      // 20_29: sbzc;
                      //    30: pp;
                      //    31: dm;
                    // }
                    union
                    {
                      struct
                      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
                        uint32 midscale : 10; // 0..9
                        uint32 sazc : 10; // 10..19
                        uint32 sbzc : 10; // 20..29
                        uint32 pp : 1; // 30
                        uint32 dm : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
                        uint32 dm : 1; // 31
                        uint32 pp : 1; // 30
                        uint32 sbzc : 10; // 20..29
                        uint32 sazc : 10; // 10..19
                        uint32 midscale : 10; // 0..9
#endif
                      };
                      uint32  u32;
                    } extras;
                    READ_FROM_BUFFER_FULL(888,uint32 ,extras,extras.u32,130);
                    if (__buffer.is_memberdump())
                    {
                      printf("%s%08" PRIx32 "%s: extras ", CT_OUT(BOLD), extras.u32, CT_OUT(NORM));
                      printf(".midscale=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.midscale, CT_OUT(NORM));
                      printf(".sazc=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.sazc, CT_OUT(NORM));
                      printf(".sbzc=%s%3" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.sbzc, CT_OUT(NORM));
                      printf(".pp=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.pp, CT_OUT(NORM));
                      printf(".dm=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  extras.dm, CT_OUT(NORM));
                      printf("\n");
                    }
                  }
                }
              }
            }
          }
        }
      }

      else
      {
        // if((format_one.et == 1))

        if ((format_one.et == 1))
        {
          // UINT32 channel_time_tag NOENCODE
          // {
            //  0_31: time_tag;
            // ENCODE(channel_time APPEND_LIST,(value=time_tag));
          // }
          union
          {
            struct
            {
#if __BYTE_ORDER == __LITTLE_ENDIAN
              uint32 time_tag : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
              uint32 time_tag : 32; // 0..31
#endif
            };
            uint32  u32;
          } channel_time_tag;
          READ_FROM_BUFFER_FULL(904,uint32 ,channel_time_tag,channel_time_tag.u32,131);
          {
            typedef __typeof__(*(&(channel_time))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = channel_time.append_item(903);
            __item.value = channel_time_tag.time_tag;
          }
          if (__buffer.is_memberdump())
          {
            printf("%s%08" PRIx32 "%s: channel_time_tag ", CT_OUT(BOLD), channel_time_tag.u32, CT_OUT(NORM));
            printf(".time_tag=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  channel_time_tag.time_tag, CT_OUT(NORM));
            printf("\n");
          }
        }
      }
      // if((format_one.eq == 1))

      if ((format_one.eq == 1))
      {
        // UINT32 qdata NOENCODE
        // {
          //  0_14: qshort;
          //    15: empty;
          // 16_31: qlong;
          // ENCODE(qshort APPEND_LIST,(value=qshort));
          // ENCODE(qlong APPEND_LIST,(value=qlong));
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 qshort : 15; // 0..14
            uint32 empty : 1; // 15
            uint32 qlong : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 qlong : 16; // 16..31
            uint32 empty : 1; // 15
            uint32 qshort : 15; // 0..14
#endif
          };
          uint32  u32;
        } qdata;
        READ_FROM_BUFFER_FULL(916,uint32 ,qdata,qdata.u32,132);
        {
          {
            typedef __typeof__(*(&(qshort))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = qshort.append_item(914);
            __item.value = qdata.qshort;
          }
          {
            typedef __typeof__(*(&(qlong))) __array_t;
            typedef typename __array_t::item_t __item_t;
            __item_t &__item = qlong.append_item(915);
            __item.value = qdata.qlong;
          }
        }
        if (__buffer.is_memberdump())
        {
          printf("%s%08" PRIx32 "%s: qdata ", CT_OUT(BOLD), qdata.u32, CT_OUT(NORM));
          printf(".qshort=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  qdata.qshort, CT_OUT(NORM));
          printf(".empty=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  qdata.empty, CT_OUT(NORM));
          printf(".qlong=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  qdata.qlong, CT_OUT(NORM));
          printf("\n");
        }
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1751::__unpack,uint32 board);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1751.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1751(board)
template<typename __data_src_t>
bool VME_CAEN_V1751::__match(__data_src_t &__buffer,uint32 board)
{
  // MEMBER(DATA8 board_id);
  // MEMBER(DATA8 channels);
  // MEMBER(DATA32 board_time);
  // MEMBER(DATA32 channel_time[64] NO_INDEX_LIST);
  // MEMBER(DATA16 chan_ext_time[64] NO_INDEX_LIST);
  // MEMBER(DATA12 chan_fine_time[64] NO_INDEX_LIST);
  // MEMBER(DATA16 qshort[64] NO_INDEX_LIST);
  // MEMBER(DATA16 qlong[64] NO_INDEX_LIST);
  // UINT32 board_agg_size NOENCODE
  // {
    //  0_27: event_size;
    // 28_31: 10;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_size : 28; // 0..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 event_size : 28; // 0..27
#endif
    };
    uint32  u32;
  } board_agg_size;
  MATCH_READ_FROM_BUFFER_FULL(767,uint32 ,board_agg_size,board_agg_size.u32,133);
  MATCH_BITS_EQUAL(766,board_agg_size.unnamed_28_31,10);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1751::__match,uint32 board);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1751.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1751(board)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1751::__packer(__data_dest_t &__buffer,uint32 board)
{
  // MEMBER(DATA8 board_id);
  // MEMBER(DATA8 channels);
  // MEMBER(DATA32 board_time);
  // MEMBER(DATA32 channel_time[64] NO_INDEX_LIST);
  // MEMBER(DATA16 chan_ext_time[64] NO_INDEX_LIST);
  // MEMBER(DATA12 chan_fine_time[64] NO_INDEX_LIST);
  // MEMBER(DATA16 qshort[64] NO_INDEX_LIST);
  // MEMBER(DATA16 qlong[64] NO_INDEX_LIST);
  // UINT32 board_agg_size NOENCODE
  // {
    //  0_27: event_size;
    // 28_31: 10;
  // }
  // UINT32 board_details NOENCODE
  // {
    //  0_07: channels;
    //  8_23: pattern;
    // 24_25: empty;
    //    26: board_fail;
    // 27_31: id = MATCH(board);
    // ENCODE(channels,(value=channels));
    // ENCODE(board_id,(value=id));
  // }
  // UINT32 board_agg_counter NOENCODE
  // {
    //  0_22: counter;
    // 23_31: empty;
  // }
  // UINT32 board_agg_timetag NOENCODE
  // {
    //  0_31: time_tag;
    // ENCODE(board_time,(value=time_tag));
  // }
  // if((board_agg_size.event_size > 4))

  if ((board_agg_size.event_size > 4))
  {
    // list(0<=index<((board_agg_size.event_size - 4) / 6))

    {
      // UINT32 channel_agg_size NOENCODE
      // {
        //  0_21: size;
        // 22_27: empty;
        // 28_31: format;
      // }
      // UINT32 format_one NOENCODE
      // {
        //  0_15: no_wave_samples;
        // 16_17: empty;
        //    18: ed;
        // 19_21: dp1;
        // 22_24: dp2;
        // 25_26: ap;
        //    27: es;
        //    28: ee;
        //    29: et;
        //    30: eq;
        //    31: dt;
      // }
      // if((channel_agg_size.format == 4))

      // else

      if ((channel_agg_size.format == 4))
      {
        // UINT32 format_two NOENCODE
        // {
          //  0_02: ex;
          //     3: pp;
          //     4: dm;
          //  5_07: interp;
          //  8_31: empty;
        // }
        // if((format_one.et == 1))

        if ((format_one.et == 1))
        {
          // UINT32 channel_time_tag NOENCODE
          // {
            //  0_31: time_tag;
            // ENCODE(channel_time APPEND_LIST,(value=time_tag));
          // }
        }
        // if(((format_one.ee == 1) && (channel_agg_size.format == 4)))

        if (((format_one.ee == 1) && (channel_agg_size.format == 4)))
        {
          // if((format_two.ex == 0))

          // else

          if ((format_two.ex == 0))
          {
            // UINT32 extras NOENCODE
            // {
              //  0_15: baseline;
              // 16_31: ext_time;
              // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
            // }
          }

          else
          {
            // if((format_two.ex == 1))

            // else

            if ((format_two.ex == 1))
            {
              // UINT32 extras NOENCODE
              // {
                //  0_15: flags;
                // 16_31: ext_time;
                // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
              // }
            }

            else
            {
              // if((format_two.ex == 2))

              // else

              if ((format_two.ex == 2))
              {
                // UINT32 extras NOENCODE
                // {
                  //  0_09: fine_time;
                  // 10_15: flags;
                  // 16_31: ext_time;
                  // ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  // ENCODE(chan_ext_time APPEND_LIST,(value=ext_time));
                // }
              }

              else
              {
                // if((format_two.ex == 4))

                // else

                if ((format_two.ex == 4))
                {
                  // UINT32 extras NOENCODE
                  // {
                    //  0_15: baseline;
                    // 16_26: fine_time;
                    // 27_31: flags;
                    // ENCODE(chan_fine_time APPEND_LIST,(value=fine_time));
                  // }
                }

                else
                {
                  // if((format_two.ex == 5))

                  if ((format_two.ex == 5))
                  {
                    // UINT32 extras NOENCODE
                    // {
                      //  0_09: midscale;
                      // 10_19: sazc;
                      // 20_29: sbzc;
                      //    30: pp;
                      //    31: dm;
                    // }
                  }
                }
              }
            }
          }
        }
      }

      else
      {
        // if((format_one.et == 1))

        if ((format_one.et == 1))
        {
          // UINT32 channel_time_tag NOENCODE
          // {
            //  0_31: time_tag;
            // ENCODE(channel_time APPEND_LIST,(value=time_tag));
          // }
        }
      }
      // if((format_one.eq == 1))

      if ((format_one.eq == 1))
      {
        // UINT32 qdata NOENCODE
        // {
          //  0_14: qshort;
          //    15: empty;
          // 16_31: qlong;
          // ENCODE(qshort APPEND_LIST,(value=qshort));
          // ENCODE(qlong APPEND_LIST,(value=qlong));
        // }
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1751::__packer,uint32 board);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_BLUE),  "WR_MULTI",CT_OUT(NORM));
  }
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(998,uint32 ,hi,hi.u32,134);
  {
    time_hi.value = hi.time;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: hi ", CT_OUT(BOLD), hi.u32, CT_OUT(NORM));
    printf(".time=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hi.time, CT_OUT(NORM));
    printf("\n");
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(1003,uint32 ,lo,lo.u32,135);
  {
    time_lo.value = lo.time;
  }
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: lo ", CT_OUT(BOLD), lo.u32, CT_OUT(NORM));
    printf(".time=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  lo.time, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  MATCH_READ_FROM_BUFFER_FULL(998,uint32 ,hi,hi.u32,136);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: aida_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_aida_subev
class aida_subev
#else//PACKER_CODE
# define DECLARED_PACKER_aida_subev
class PACKER_aida_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  // external data = EXT_AIDA();
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  SINGLE(EXT_AIDA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(aida_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
template<typename __data_src_t>
void aida_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "aida_subev",CT_OUT(NORM));
  }
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  UNPACK_DECL(1016,TIMESTAMP_WHITERABBIT,ts,/*id*/0x700);
  // external data = EXT_AIDA();
  UNPACK_DECL(1017,EXT_AIDA,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,aida_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for aida_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(aida_subev)
template<typename __data_dest_t>
void PACKER_aida_subev::__packer(__data_dest_t &__buffer)
{
  // ts = TIMESTAMP_WHITERABBIT(id=0x700);
  PACK_DECL(1016,TIMESTAMP_WHITERABBIT,ts,/*id*/0x700);
  // external data = EXT_AIDA();
  PACK_DECL(1017,EXT_AIDA,data);
}
FORCE_IMPL_DATA_SRC_FCN(void,aida_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: bgo_tamex_subevent
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for bgo_tamex_subevent.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bgo_tamex_subevent)
#if !PACKER_CODE
# define DECLARED_UNPACK_bgo_tamex_subevent
class bgo_tamex_subevent
#else//PACKER_CODE
# define DECLARED_PACKER_bgo_tamex_subevent
class PACKER_bgo_tamex_subevent
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1900);
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  // optional UINT32 be
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 b : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 b : 32; // 0..31
#endif
    };
    uint32  u32;
  } be;
  // select optional

    // trigger_window = TAMEX4_HEADER();
  SINGLE(TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  SINGLE(TAMEX4_PADDING,padding);
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=1,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=1,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=1,card=2);
  SINGLE(TAMEX4_SFP,tamex[3]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(bgo_tamex_subevent);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for bgo_tamex_subevent.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bgo_tamex_subevent)
template<typename __data_src_t>
void bgo_tamex_subevent::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "bgo_tamex_subevent",CT_OUT(NORM));
  }
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1900);
  do
  {
    if (__buffer.empty()) goto no_match_2;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT_EXTENDED ts: (s32) => (0xfffeffff,0x00001900)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1025,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_2;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1024,spurious_match_abort_loop_6,TIMESTAMP_WHITERABBIT_EXTENDED,/*id*/0x1900);
        UNPACK_DECL(1024,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1900);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_6:;
    no_match_2:;
  // optional UINT32 be
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 b : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 b : 32; // 0..31
#endif
    };
    uint32  u32;
  } __be;
  if (__buffer.empty()) goto data_done_6;
  PEEK_FROM_BUFFER_FULL(1029,uint32 ,be,__be.u32,137);
  CHECK_JUMP_BITS_EQUAL(1028,__be.b,0xbad00bad,data_done_6);
  be.u32 = __be.u32;
  __buffer.advance(sizeof(__be.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: be ", CT_OUT(BOLD), __be.u32, CT_OUT(NORM));
    printf(".b=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  __be.b, CT_OUT(NORM));
    printf("\n");
  }
  data_done_6:;
  // select optional

    // trigger_window = TAMEX4_HEADER();
  do
  {
    if (__buffer.empty()) goto no_match_3;
    int __match_no = 0;
    // optimized match 1: TAMEX4_HEADER trigger_window: (s32) => (0x00000000,0x00000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1033,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_3;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1032,spurious_match_abort_loop_7,TAMEX4_HEADER);
        UNPACK_DECL(1032,TAMEX4_HEADER,trigger_window);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_7:;
    no_match_3:;
  // select several

    // padding = TAMEX4_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1037,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1036,spurious_match_abort_loop_8,TAMEX4_PADDING);
        UNPACK_DECL(1036,TAMEX4_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_8:;
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=1,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=1,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=1,card=2);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_SFP tamex[0]: (s32) => (0xfffff0ff,0x00001034)
    // optimized match 2: TAMEX4_SFP tamex[1]: (s32) => (0xfffff0ff,0x00011034)
    // optimized match 3: TAMEX4_SFP tamex[2]: (s32) => (0xfffff0ff,0x00021034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1043,uint32,__match_peek);
    // differ = 00030000 : 16 17
    uint32 __match_index = 0 | /* 16,17 */ ((__match_peek >> 16) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1040,TAMEX4_SFP,tamex[0],/*sfp*/1,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(1041,TAMEX4_SFP,tamex[1],/*sfp*/1,/*card*/1);
        break;
      case 3:
        UNPACK_DECL(1042,TAMEX4_SFP,tamex[2],/*sfp*/1,/*card*/2);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bgo_tamex_subevent::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for bgo_tamex_subevent.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bgo_tamex_subevent)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for bgo_tamex_subevent.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bgo_tamex_subevent)
template<typename __data_dest_t>
void PACKER_bgo_tamex_subevent::__packer(__data_dest_t &__buffer)
{
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1900);
  {
    PACK_DECL(1024,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1900);
  }
  // optional UINT32 be
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  // select optional

    // trigger_window = TAMEX4_HEADER();
  {
    PACK_DECL(1032,TAMEX4_HEADER,trigger_window);
  }
  // select several

    // padding = TAMEX4_PADDING();
  {
    PACK_DECL(1036,TAMEX4_PADDING,padding);
  }
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=1,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=1,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=1,card=2);
  {
    PACK_DECL(1040,TAMEX4_SFP,tamex[0],/*sfp*/1,/*card*/0);
    PACK_DECL(1041,TAMEX4_SFP,tamex[1],/*sfp*/1,/*card*/1);
    PACK_DECL(1042,TAMEX4_SFP,tamex[2],/*sfp*/1,/*card*/2);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bgo_tamex_subevent::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: bm_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for bm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bm_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_bm_subev
class bm_subev
#else//PACKER_CODE
# define DECLARED_PACKER_bm_subev
class PACKER_bm_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // MEMBER(DATA32 dataS2[100000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,100000> dataS2;
  // MEMBER(DATA32 dataS4[100000] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,100000> dataS4;
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1700);
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  // UINT32 headS2 NOENCODE
  // {
    //  0_12: l_hit_ct;
    // 13_15: reserved;
    // 16_31: l_id = MATCH(0xaaaa);
  // }
  // list(0<=l_i<headS2.l_hit_ct)

    // UINT32 hit NOENCODE
    // {
      //  0_31: data;
      // ENCODE(dataS2 APPEND_LIST,(value=data));
    // }
  // UINT32 headS4 NOENCODE
  // {
    //  0_12: l_hit_ct;
    // 13_15: reserved;
    // 16_31: l_id = MATCH(0xbbbb);
  // }
  // list(0<=l_i<headS4.l_hit_ct)

    // UINT32 hit NOENCODE
    // {
      //  0_31: data;
      // ENCODE(dataS4 APPEND_LIST,(value=data));
    // }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: reserved;
    // 16_31: l_id = MATCH(0xcccc);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(bm_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for bm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bm_subev)
template<typename __data_src_t>
void bm_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "bm_subev",CT_OUT(NORM));
  }
  // MEMBER(DATA32 dataS2[100000] NO_INDEX_LIST);
  // MEMBER(DATA32 dataS4[100000] NO_INDEX_LIST);
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1700);
  do
  {
    if (__buffer.empty()) goto no_match_4;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT_EXTENDED ts: (s32) => (0xfffeffff,0x00001700)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1053,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_4;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1052,spurious_match_abort_loop_9,TIMESTAMP_WHITERABBIT_EXTENDED,/*id*/0x1700);
        UNPACK_DECL(1052,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1700);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_9:;
    no_match_4:;
  // UINT32 headS2 NOENCODE
  // {
    //  0_12: l_hit_ct;
    // 13_15: reserved;
    // 16_31: l_id = MATCH(0xaaaa);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 l_hit_ct : 13; // 0..12
      uint32 reserved : 3; // 13..15
      uint32 l_id : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 l_id : 16; // 16..31
      uint32 reserved : 3; // 13..15
      uint32 l_hit_ct : 13; // 0..12
#endif
    };
    uint32  u32;
  } headS2;
  READ_FROM_BUFFER_FULL(1059,uint32 ,headS2,headS2.u32,138);
  CHECK_BITS_EQUAL(1058,headS2.l_id,0xaaaa);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: headS2 ", CT_OUT(BOLD), headS2.u32, CT_OUT(NORM));
    printf(".l_hit_ct=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  headS2.l_hit_ct, CT_OUT(NORM));
    printf(".reserved=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  headS2.reserved, CT_OUT(NORM));
    printf(".l_id=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  headS2.l_id, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=l_i<headS2.l_hit_ct)

  for (uint32 l_i = 0; l_i < (uint32) (headS2.l_hit_ct); ++l_i)
  {
    // UINT32 hit NOENCODE
    // {
      //  0_31: data;
      // ENCODE(dataS2 APPEND_LIST,(value=data));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 data : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 data : 32; // 0..31
#endif
      };
      uint32  u32;
    } hit;
    READ_FROM_BUFFER_FULL(1066,uint32 ,hit,hit.u32,139);
    {
      typedef __typeof__(*(&(dataS2))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = dataS2.append_item(1065);
      __item.value = hit.data;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: hit ", CT_OUT(BOLD), hit.u32, CT_OUT(NORM));
      printf(".data=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hit.data, CT_OUT(NORM));
      printf("\n");
    }
  }
  // UINT32 headS4 NOENCODE
  // {
    //  0_12: l_hit_ct;
    // 13_15: reserved;
    // 16_31: l_id = MATCH(0xbbbb);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 l_hit_ct : 13; // 0..12
      uint32 reserved : 3; // 13..15
      uint32 l_id : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 l_id : 16; // 16..31
      uint32 reserved : 3; // 13..15
      uint32 l_hit_ct : 13; // 0..12
#endif
    };
    uint32  u32;
  } headS4;
  READ_FROM_BUFFER_FULL(1073,uint32 ,headS4,headS4.u32,140);
  CHECK_BITS_EQUAL(1072,headS4.l_id,0xbbbb);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: headS4 ", CT_OUT(BOLD), headS4.u32, CT_OUT(NORM));
    printf(".l_hit_ct=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  headS4.l_hit_ct, CT_OUT(NORM));
    printf(".reserved=%s%1" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  headS4.reserved, CT_OUT(NORM));
    printf(".l_id=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  headS4.l_id, CT_OUT(NORM));
    printf("\n");
  }
  // list(0<=l_i<headS4.l_hit_ct)

  for (uint32 l_i = 0; l_i < (uint32) (headS4.l_hit_ct); ++l_i)
  {
    // UINT32 hit NOENCODE
    // {
      //  0_31: data;
      // ENCODE(dataS4 APPEND_LIST,(value=data));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 data : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 data : 32; // 0..31
#endif
      };
      uint32  u32;
    } hit;
    READ_FROM_BUFFER_FULL(1080,uint32 ,hit,hit.u32,141);
    {
      typedef __typeof__(*(&(dataS4))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = dataS4.append_item(1079);
      __item.value = hit.data;
    }
    if (__buffer.is_memberdump())
    {
      printf("%s%08" PRIx32 "%s: hit ", CT_OUT(BOLD), hit.u32, CT_OUT(NORM));
      printf(".data=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  hit.data, CT_OUT(NORM));
      printf("\n");
    }
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: reserved;
    // 16_31: l_id = MATCH(0xcccc);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 reserved : 16; // 0..15
      uint32 l_id : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 l_id : 16; // 16..31
      uint32 reserved : 16; // 0..15
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(1086,uint32 ,trailer,trailer.u32,142);
  CHECK_BITS_EQUAL(1085,trailer.l_id,0xcccc);
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: trailer ", CT_OUT(BOLD), trailer.u32, CT_OUT(NORM));
    printf(".reserved=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.reserved, CT_OUT(NORM));
    printf(".l_id=%s%4" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  trailer.l_id, CT_OUT(NORM));
    printf("\n");
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bm_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for bm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bm_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for bm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bm_subev)
template<typename __data_dest_t>
void PACKER_bm_subev::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 dataS2[100000] NO_INDEX_LIST);
  // MEMBER(DATA32 dataS4[100000] NO_INDEX_LIST);
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1700);
  {
    PACK_DECL(1052,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1700);
  }
  // UINT32 headS2 NOENCODE
  // {
    //  0_12: l_hit_ct;
    // 13_15: reserved;
    // 16_31: l_id = MATCH(0xaaaa);
  // }
  // list(0<=l_i<headS2.l_hit_ct)

  {
    // UINT32 hit NOENCODE
    // {
      //  0_31: data;
      // ENCODE(dataS2 APPEND_LIST,(value=data));
    // }
  }
  // UINT32 headS4 NOENCODE
  // {
    //  0_12: l_hit_ct;
    // 13_15: reserved;
    // 16_31: l_id = MATCH(0xbbbb);
  // }
  // list(0<=l_i<headS4.l_hit_ct)

  {
    // UINT32 hit NOENCODE
    // {
      //  0_31: data;
      // ENCODE(dataS4 APPEND_LIST,(value=data));
    // }
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_15: reserved;
    // 16_31: l_id = MATCH(0xcccc);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,bm_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: bplast_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_bplast_subev
class bplast_subev
#else//PACKER_CODE
# define DECLARED_PACKER_bplast_subev
class PACKER_bplast_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select optional

    // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  // select optional

    // trigger_window = TAMEX4_HEADER();
  SINGLE(TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  SINGLE(TAMEX4_PADDING,padding);
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    // tamex[4] = TAMEX4_SFP(sfp=0,card=4);
    // tamex[5] = TAMEX4_SFP(sfp=0,card=5);
    // tamex[6] = TAMEX4_SFP(sfp=0,card=6);
    // tamex[7] = TAMEX4_SFP(sfp=0,card=7);
    // tamex[8] = TAMEX4_SFP(sfp=0,card=8);
  SINGLE(TAMEX4_SFP,tamex[9]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(bplast_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
template<typename __data_src_t>
void bplast_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "bplast_subev",CT_OUT(NORM));
  }
  // select optional

    // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  do
  {
    if (__buffer.empty()) goto no_match_5;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT ts: (s32) => (0xfffeffff,0x00000500)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1094,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_5;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1093,spurious_match_abort_loop_10,TIMESTAMP_WHITERABBIT,/*id*/0x500);
        UNPACK_DECL(1093,TIMESTAMP_WHITERABBIT,ts,/*id*/0x500);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_10:;
    no_match_5:;
  // select optional

    // trigger_window = TAMEX4_HEADER();
  do
  {
    if (__buffer.empty()) goto no_match_6;
    int __match_no = 0;
    // optimized match 1: TAMEX4_HEADER trigger_window: (s32) => (0x00000000,0x00000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1098,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_6;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1097,spurious_match_abort_loop_11,TAMEX4_HEADER);
        UNPACK_DECL(1097,TAMEX4_HEADER,trigger_window);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_11:;
    no_match_6:;
  // select several

    // padding = TAMEX4_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1102,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1101,spurious_match_abort_loop_12,TAMEX4_PADDING);
        UNPACK_DECL(1101,TAMEX4_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_12:;
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    // tamex[4] = TAMEX4_SFP(sfp=0,card=4);
    // tamex[5] = TAMEX4_SFP(sfp=0,card=5);
    // tamex[6] = TAMEX4_SFP(sfp=0,card=6);
    // tamex[7] = TAMEX4_SFP(sfp=0,card=7);
    // tamex[8] = TAMEX4_SFP(sfp=0,card=8);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_SFP tamex[0]: (s32) => (0xfffff0ff,0x00000034)
    // optimized match 2: TAMEX4_SFP tamex[1]: (s32) => (0xfffff0ff,0x00010034)
    // optimized match 3: TAMEX4_SFP tamex[2]: (s32) => (0xfffff0ff,0x00020034)
    // optimized match 4: TAMEX4_SFP tamex[3]: (s32) => (0xfffff0ff,0x00030034)
    // optimized match 5: TAMEX4_SFP tamex[4]: (s32) => (0xfffff0ff,0x00040034)
    // optimized match 6: TAMEX4_SFP tamex[5]: (s32) => (0xfffff0ff,0x00050034)
    // optimized match 7: TAMEX4_SFP tamex[6]: (s32) => (0xfffff0ff,0x00060034)
    // optimized match 8: TAMEX4_SFP tamex[7]: (s32) => (0xfffff0ff,0x00070034)
    // optimized match 9: TAMEX4_SFP tamex[8]: (s32) => (0xfffff0ff,0x00080034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1114,uint32,__match_peek);
    // differ = 000f0000 : 16 17 18 19
    uint32 __match_index = 0 | /* 16,19 */ ((__match_peek >> 16) & 0x0000000f);
    static const sint8 __match_index_array[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1105,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(1106,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
        break;
      case 3:
        UNPACK_DECL(1107,TAMEX4_SFP,tamex[2],/*sfp*/0,/*card*/2);
        break;
      case 4:
        UNPACK_DECL(1108,TAMEX4_SFP,tamex[3],/*sfp*/0,/*card*/3);
        break;
      case 5:
        UNPACK_DECL(1109,TAMEX4_SFP,tamex[4],/*sfp*/0,/*card*/4);
        break;
      case 6:
        UNPACK_DECL(1110,TAMEX4_SFP,tamex[5],/*sfp*/0,/*card*/5);
        break;
      case 7:
        UNPACK_DECL(1111,TAMEX4_SFP,tamex[6],/*sfp*/0,/*card*/6);
        break;
      case 8:
        UNPACK_DECL(1112,TAMEX4_SFP,tamex[7],/*sfp*/0,/*card*/7);
        break;
      case 9:
        UNPACK_DECL(1113,TAMEX4_SFP,tamex[8],/*sfp*/0,/*card*/8);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bplast_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for bplast_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(bplast_subev)
template<typename __data_dest_t>
void PACKER_bplast_subev::__packer(__data_dest_t &__buffer)
{
  // select optional

    // ts = TIMESTAMP_WHITERABBIT(id=0x500);
  {
    PACK_DECL(1093,TIMESTAMP_WHITERABBIT,ts,/*id*/0x500);
  }
  // select optional

    // trigger_window = TAMEX4_HEADER();
  {
    PACK_DECL(1097,TAMEX4_HEADER,trigger_window);
  }
  // select several

    // padding = TAMEX4_PADDING();
  {
    PACK_DECL(1101,TAMEX4_PADDING,padding);
  }
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
    // tamex[4] = TAMEX4_SFP(sfp=0,card=4);
    // tamex[5] = TAMEX4_SFP(sfp=0,card=5);
    // tamex[6] = TAMEX4_SFP(sfp=0,card=6);
    // tamex[7] = TAMEX4_SFP(sfp=0,card=7);
    // tamex[8] = TAMEX4_SFP(sfp=0,card=8);
  {
    PACK_DECL(1105,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
    PACK_DECL(1106,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
    PACK_DECL(1107,TAMEX4_SFP,tamex[2],/*sfp*/0,/*card*/2);
    PACK_DECL(1108,TAMEX4_SFP,tamex[3],/*sfp*/0,/*card*/3);
    PACK_DECL(1109,TAMEX4_SFP,tamex[4],/*sfp*/0,/*card*/4);
    PACK_DECL(1110,TAMEX4_SFP,tamex[5],/*sfp*/0,/*card*/5);
    PACK_DECL(1111,TAMEX4_SFP,tamex[6],/*sfp*/0,/*card*/6);
    PACK_DECL(1112,TAMEX4_SFP,tamex[7],/*sfp*/0,/*card*/7);
    PACK_DECL(1113,TAMEX4_SFP,tamex[8],/*sfp*/0,/*card*/8);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,bplast_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: fatima_tamex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_fatima_tamex_subev
class fatima_tamex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_fatima_tamex_subev
class PACKER_fatima_tamex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  // select optional

    // trigger_window = TAMEX4_HEADER();
  SINGLE(TAMEX4_HEADER,trigger_window);
  // select several

    // padding = TAMEX4_PADDING();
  SINGLE(TAMEX4_PADDING,padding);
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
  SINGLE(TAMEX4_SFP,tamex[4]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(fatima_tamex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
template<typename __data_src_t>
void fatima_tamex_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "fatima_tamex_subev",CT_OUT(NORM));
  }
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  do
  {
    if (__buffer.empty()) goto no_match_7;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT_EXTENDED ts: (s32) => (0xfffeffff,0x00001600)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1122,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_7;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1121,spurious_match_abort_loop_13,TIMESTAMP_WHITERABBIT_EXTENDED,/*id*/0x1600);
        UNPACK_DECL(1121,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1600);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_13:;
    no_match_7:;
  // select optional

    // trigger_window = TAMEX4_HEADER();
  do
  {
    if (__buffer.empty()) goto no_match_8;
    int __match_no = 0;
    // optimized match 1: TAMEX4_HEADER trigger_window: (s32) => (0x00000000,0x00000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1126,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_8;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1125,spurious_match_abort_loop_14,TAMEX4_HEADER);
        UNPACK_DECL(1125,TAMEX4_HEADER,trigger_window);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_14:;
    no_match_8:;
  // select several

    // padding = TAMEX4_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1130,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1129,spurious_match_abort_loop_15,TAMEX4_PADDING);
        UNPACK_DECL(1129,TAMEX4_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_15:;
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX4_SFP tamex[0]: (s32) => (0xfffff0ff,0x00000034)
    // optimized match 2: TAMEX4_SFP tamex[1]: (s32) => (0xfffff0ff,0x00010034)
    // optimized match 3: TAMEX4_SFP tamex[2]: (s32) => (0xfffff0ff,0x00020034)
    // optimized match 4: TAMEX4_SFP tamex[3]: (s32) => (0xfffff0ff,0x00030034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1137,uint32,__match_peek);
    // differ = 00030000 : 16 17
    uint32 __match_index = 0 | /* 16,17 */ ((__match_peek >> 16) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1133,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(1134,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
        break;
      case 3:
        UNPACK_DECL(1135,TAMEX4_SFP,tamex[2],/*sfp*/0,/*card*/2);
        break;
      case 4:
        UNPACK_DECL(1136,TAMEX4_SFP,tamex[3],/*sfp*/0,/*card*/3);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_tamex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for fatima_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_tamex_subev)
template<typename __data_dest_t>
void PACKER_fatima_tamex_subev::__packer(__data_dest_t &__buffer)
{
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1600);
  {
    PACK_DECL(1121,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1600);
  }
  // select optional

    // trigger_window = TAMEX4_HEADER();
  {
    PACK_DECL(1125,TAMEX4_HEADER,trigger_window);
  }
  // select several

    // padding = TAMEX4_PADDING();
  {
    PACK_DECL(1129,TAMEX4_PADDING,padding);
  }
  // select several

    // tamex[0] = TAMEX4_SFP(sfp=0,card=0);
    // tamex[1] = TAMEX4_SFP(sfp=0,card=1);
    // tamex[2] = TAMEX4_SFP(sfp=0,card=2);
    // tamex[3] = TAMEX4_SFP(sfp=0,card=3);
  {
    PACK_DECL(1133,TAMEX4_SFP,tamex[0],/*sfp*/0,/*card*/0);
    PACK_DECL(1134,TAMEX4_SFP,tamex[1],/*sfp*/0,/*card*/1);
    PACK_DECL(1135,TAMEX4_SFP,tamex[2],/*sfp*/0,/*card*/2);
    PACK_DECL(1136,TAMEX4_SFP,tamex[3],/*sfp*/0,/*card*/3);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_tamex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: fatima_vme_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_fatima_vme_subev
class fatima_vme_subev
#else//PACKER_CODE
# define DECLARED_PACKER_fatima_vme_subev
class PACKER_fatima_vme_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  SINGLE(TIMESTAMP_WHITERABBIT_EXTENDED,ts);
  // select several

    // error1 = ERR_WORD_SIX();
  SINGLE(ERR_WORD_SIX,error1);
  // select optional

    // scalers = FATIMA_VME_SCALERS();
  SINGLE(FATIMA_VME_SCALERS,scalers);
  // select optional

    // qdc1 = VME_CAEN_V1751(board=6);
  SINGLE(VME_CAEN_V1751,qdc1);
  // select optional

    // qdc2 = VME_CAEN_V1751(board=7);
  SINGLE(VME_CAEN_V1751,qdc2);
  // select optional

    // qdc3 = VME_CAEN_V1751(board=8);
  SINGLE(VME_CAEN_V1751,qdc3);
  // select optional

    // qdc4 = VME_CAEN_V1751(board=9);
  SINGLE(VME_CAEN_V1751,qdc4);
  // select optional

    // qdc5 = VME_CAEN_V1751(board=10);
  SINGLE(VME_CAEN_V1751,qdc5);
  // select several

    // error2 = ERR_WORD_SIX();
  SINGLE(ERR_WORD_SIX,error2);
  // select optional

    // tdc1 = VME_CAEN_V1290_N();
  SINGLE(VME_CAEN_V1290_N,tdc1);
  // select several

    // error3 = ERR_WORD_SIX();
  SINGLE(ERR_WORD_SIX,error3);
  // select optional

    // tdc2 = VME_CAEN_V1290_N();
  SINGLE(VME_CAEN_V1290_N,tdc2);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(fatima_vme_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
template<typename __data_src_t>
void fatima_vme_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "fatima_vme_subev",CT_OUT(NORM));
  }
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  do
  {
    if (__buffer.empty()) goto no_match_9;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT_EXTENDED ts: (s32) => (0xfffeffff,0x00001500)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1145,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_9;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1144,spurious_match_abort_loop_16,TIMESTAMP_WHITERABBIT_EXTENDED,/*id*/0x1500);
        UNPACK_DECL(1144,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1500);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_16:;
    no_match_9:;
  // select several

    // error1 = ERR_WORD_SIX();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: ERR_WORD_SIX error1: (s32) => (0xffffffff,0x06000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1149,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1148,spurious_match_abort_loop_17,ERR_WORD_SIX);
        UNPACK_DECL(1148,ERR_WORD_SIX,error1);
        break;
    }
  }
  spurious_match_abort_loop_17:;
  // select optional

    // scalers = FATIMA_VME_SCALERS();
  do
  {
    if (__buffer.empty()) goto no_match_10;
    int __match_no = 0;
    // optimized match 1: FATIMA_VME_SCALERS scalers: (s32) => (0xf8000000,0x78000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1153,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_10;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1152,spurious_match_abort_loop_18,FATIMA_VME_SCALERS);
        UNPACK_DECL(1152,FATIMA_VME_SCALERS,scalers);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_18:;
    no_match_10:;
  // select optional

    // qdc1 = VME_CAEN_V1751(board=6);
  do
  {
    if (__buffer.empty()) goto no_match_11;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1751 qdc1: (s32) => (0xf0000000,0xa0000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1157,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_11;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1156,spurious_match_abort_loop_19,VME_CAEN_V1751,/*board*/6);
        UNPACK_DECL(1156,VME_CAEN_V1751,qdc1,/*board*/6);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_19:;
    no_match_11:;
  // select optional

    // qdc2 = VME_CAEN_V1751(board=7);
  do
  {
    if (__buffer.empty()) goto no_match_12;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1751 qdc2: (s32) => (0xf0000000,0xa0000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1161,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_12;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1160,spurious_match_abort_loop_20,VME_CAEN_V1751,/*board*/7);
        UNPACK_DECL(1160,VME_CAEN_V1751,qdc2,/*board*/7);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_20:;
    no_match_12:;
  // select optional

    // qdc3 = VME_CAEN_V1751(board=8);
  do
  {
    if (__buffer.empty()) goto no_match_13;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1751 qdc3: (s32) => (0xf0000000,0xa0000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1165,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_13;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1164,spurious_match_abort_loop_21,VME_CAEN_V1751,/*board*/8);
        UNPACK_DECL(1164,VME_CAEN_V1751,qdc3,/*board*/8);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_21:;
    no_match_13:;
  // select optional

    // qdc4 = VME_CAEN_V1751(board=9);
  do
  {
    if (__buffer.empty()) goto no_match_14;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1751 qdc4: (s32) => (0xf0000000,0xa0000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1169,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_14;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1168,spurious_match_abort_loop_22,VME_CAEN_V1751,/*board*/9);
        UNPACK_DECL(1168,VME_CAEN_V1751,qdc4,/*board*/9);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_22:;
    no_match_14:;
  // select optional

    // qdc5 = VME_CAEN_V1751(board=10);
  do
  {
    if (__buffer.empty()) goto no_match_15;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1751 qdc5: (s32) => (0xf0000000,0xa0000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1173,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_15;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1172,spurious_match_abort_loop_23,VME_CAEN_V1751,/*board*/10);
        UNPACK_DECL(1172,VME_CAEN_V1751,qdc5,/*board*/10);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_23:;
    no_match_15:;
  // select several

    // error2 = ERR_WORD_SIX();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: ERR_WORD_SIX error2: (s32) => (0xffffffff,0x06000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1177,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1176,spurious_match_abort_loop_24,ERR_WORD_SIX);
        UNPACK_DECL(1176,ERR_WORD_SIX,error2);
        break;
    }
  }
  spurious_match_abort_loop_24:;
  // select optional

    // tdc1 = VME_CAEN_V1290_N();
  do
  {
    if (__buffer.empty()) goto no_match_16;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_N tdc1: (s32) => (0xf8000000,0x40000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1181,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_16;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1180,spurious_match_abort_loop_25,VME_CAEN_V1290_N);
        UNPACK_DECL(1180,VME_CAEN_V1290_N,tdc1);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_25:;
    no_match_16:;
  // select several

    // error3 = ERR_WORD_SIX();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: ERR_WORD_SIX error3: (s32) => (0xffffffff,0x06000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1185,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1184,spurious_match_abort_loop_26,ERR_WORD_SIX);
        UNPACK_DECL(1184,ERR_WORD_SIX,error3);
        break;
    }
  }
  spurious_match_abort_loop_26:;
  // select optional

    // tdc2 = VME_CAEN_V1290_N();
  do
  {
    if (__buffer.empty()) goto no_match_17;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_N tdc2: (s32) => (0xf8000000,0x40000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1189,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) goto no_match_17;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1188,VME_CAEN_V1290_N,tdc2);
        break;
    }
  }
  while (0);
    no_match_17:;
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_vme_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for fatima_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fatima_vme_subev)
template<typename __data_dest_t>
void PACKER_fatima_vme_subev::__packer(__data_dest_t &__buffer)
{
  // select optional

    // ts = TIMESTAMP_WHITERABBIT_EXTENDED(id=0x1500);
  {
    PACK_DECL(1144,TIMESTAMP_WHITERABBIT_EXTENDED,ts,/*id*/0x1500);
  }
  // select several

    // error1 = ERR_WORD_SIX();
  {
    PACK_DECL(1148,ERR_WORD_SIX,error1);
  }
  // select optional

    // scalers = FATIMA_VME_SCALERS();
  {
    PACK_DECL(1152,FATIMA_VME_SCALERS,scalers);
  }
  // select optional

    // qdc1 = VME_CAEN_V1751(board=6);
  {
    PACK_DECL(1156,VME_CAEN_V1751,qdc1,/*board*/6);
  }
  // select optional

    // qdc2 = VME_CAEN_V1751(board=7);
  {
    PACK_DECL(1160,VME_CAEN_V1751,qdc2,/*board*/7);
  }
  // select optional

    // qdc3 = VME_CAEN_V1751(board=8);
  {
    PACK_DECL(1164,VME_CAEN_V1751,qdc3,/*board*/8);
  }
  // select optional

    // qdc4 = VME_CAEN_V1751(board=9);
  {
    PACK_DECL(1168,VME_CAEN_V1751,qdc4,/*board*/9);
  }
  // select optional

    // qdc5 = VME_CAEN_V1751(board=10);
  {
    PACK_DECL(1172,VME_CAEN_V1751,qdc5,/*board*/10);
  }
  // select several

    // error2 = ERR_WORD_SIX();
  {
    PACK_DECL(1176,ERR_WORD_SIX,error2);
  }
  // select optional

    // tdc1 = VME_CAEN_V1290_N();
  {
    PACK_DECL(1180,VME_CAEN_V1290_N,tdc1);
  }
  // select several

    // error3 = ERR_WORD_SIX();
  {
    PACK_DECL(1184,ERR_WORD_SIX,error3);
  }
  // select optional

    // tdc2 = VME_CAEN_V1290_N();
  {
    PACK_DECL(1188,VME_CAEN_V1290_N,tdc2);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fatima_vme_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: febex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_febex_subev
class febex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_febex_subev
class PACKER_febex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select optional

    // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  SINGLE(TIMESTAMP_WHITERABBIT,ts);
  // select several

    // padding = FEBEX_PADDING();
  SINGLE(FEBEX_PADDING,padding);
  // select several

    // data[0] = FEBEX_EVENT(card=0);
    // data[1] = FEBEX_EVENT(card=1);
    // data[2] = FEBEX_EVENT(card=2);
    // data[3] = FEBEX_EVENT(card=3);
  SINGLE(FEBEX_EVENT,data[4]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(febex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
template<typename __data_src_t>
void febex_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "febex_subev",CT_OUT(NORM));
  }
  // select optional

    // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  do
  {
    if (__buffer.empty()) goto no_match_18;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT ts: (s32) => (0xfffeffff,0x00000400)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1197,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_18;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1196,spurious_match_abort_loop_27,TIMESTAMP_WHITERABBIT,/*id*/0x400);
        UNPACK_DECL(1196,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_27:;
    no_match_18:;
  // select several

    // padding = FEBEX_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1201,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1200,spurious_match_abort_loop_28,FEBEX_PADDING);
        UNPACK_DECL(1200,FEBEX_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_28:;
  // select several

    // data[0] = FEBEX_EVENT(card=0);
    // data[1] = FEBEX_EVENT(card=1);
    // data[2] = FEBEX_EVENT(card=2);
    // data[3] = FEBEX_EVENT(card=3);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_EVENT data[0]: (s32) => (0xffff00ff,0xff000034)
    // optimized match 2: FEBEX_EVENT data[1]: (s32) => (0xffff00ff,0xff010034)
    // optimized match 3: FEBEX_EVENT data[2]: (s32) => (0xffff00ff,0xff020034)
    // optimized match 4: FEBEX_EVENT data[3]: (s32) => (0xffff00ff,0xff030034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1208,uint32,__match_peek);
    // differ = 00030000 : 16 17
    uint32 __match_index = 0 | /* 16,17 */ ((__match_peek >> 16) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1204,FEBEX_EVENT,data[0],/*card*/0);
        break;
      case 2:
        UNPACK_DECL(1205,FEBEX_EVENT,data[1],/*card*/1);
        break;
      case 3:
        UNPACK_DECL(1206,FEBEX_EVENT,data[2],/*card*/2);
        break;
      case 4:
        UNPACK_DECL(1207,FEBEX_EVENT,data[3],/*card*/3);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,febex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(febex_subev)
template<typename __data_dest_t>
void PACKER_febex_subev::__packer(__data_dest_t &__buffer)
{
  // select optional

    // ts = TIMESTAMP_WHITERABBIT(id=0x400);
  {
    PACK_DECL(1196,TIMESTAMP_WHITERABBIT,ts,/*id*/0x400);
  }
  // select several

    // padding = FEBEX_PADDING();
  {
    PACK_DECL(1200,FEBEX_PADDING,padding);
  }
  // select several

    // data[0] = FEBEX_EVENT(card=0);
    // data[1] = FEBEX_EVENT(card=1);
    // data[2] = FEBEX_EVENT(card=2);
    // data[3] = FEBEX_EVENT(card=3);
  {
    PACK_DECL(1204,FEBEX_EVENT,data[0],/*card*/0);
    PACK_DECL(1205,FEBEX_EVENT,data[1],/*card*/1);
    PACK_DECL(1206,FEBEX_EVENT,data[2],/*card*/2);
    PACK_DECL(1207,FEBEX_EVENT,data[3],/*card*/3);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,febex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_main_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_main_subev
class frs_main_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_main_subev
class PACKER_frs_main_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // spill_on = SPILL_ON();
  SINGLE(SPILL_ON,spill_on);
  // select several

    // spill_off = SPILL_OFF();
  SINGLE(SPILL_OFF,spill_off);
  // select optional

    // data = MAIN_CRATE_DATA();
  SINGLE(MAIN_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_main_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
template<typename __data_src_t>
void frs_main_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_main_subev",CT_OUT(NORM));
  }
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1216,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1215,spurious_match_abort_loop_29,TRIG3EVENT);
        UNPACK_DECL(1215,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_29:;
  // select several

    // spill_on = SPILL_ON();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SPILL_ON spill_on: (s32) => (0xffffffff,0x30303030)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1220,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1219,spurious_match_abort_loop_30,SPILL_ON);
        UNPACK_DECL(1219,SPILL_ON,spill_on);
        break;
    }
  }
  spurious_match_abort_loop_30:;
  // select several

    // spill_off = SPILL_OFF();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SPILL_OFF spill_off: (s32) => (0xffffffff,0x4040400a)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1224,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1223,spurious_match_abort_loop_31,SPILL_OFF);
        UNPACK_DECL(1223,SPILL_OFF,spill_off);
        break;
    }
  }
  spurious_match_abort_loop_31:;
  // select optional

    // data = MAIN_CRATE_DATA();
  do
  {
    if (__buffer.empty()) goto no_match_19;
    int __match_no = 0;
    // optimized match 1: MAIN_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1227,__match_no,1,MAIN_CRATE_DATA,data);
    if (!__match_no) goto no_match_19;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1227,MAIN_CRATE_DATA,data);
        break;
    }
  }
  while (0);
    no_match_19:;
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_main_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_main_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_main_subev)
template<typename __data_dest_t>
void PACKER_frs_main_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1215,TRIG3EVENT,trig3);
  }
  // select several

    // spill_on = SPILL_ON();
  {
    PACK_DECL(1219,SPILL_ON,spill_on);
  }
  // select several

    // spill_off = SPILL_OFF();
  {
    PACK_DECL(1223,SPILL_OFF,spill_off);
  }
  // select optional

    // data = MAIN_CRATE_DATA();
  {
    PACK_DECL(1227,MAIN_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_main_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_tpat_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_tpat_subev
class frs_tpat_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_tpat_subev
class PACKER_frs_tpat_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select optional

    // wr = TIMESTAMP_WHITERABBIT(id=0x100);
  SINGLE(TIMESTAMP_WHITERABBIT,wr);
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select optional

    // data = TPAT_CRATE_DATA();
  SINGLE(TPAT_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_tpat_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
template<typename __data_src_t>
void frs_tpat_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_tpat_subev",CT_OUT(NORM));
  }
  // select optional

    // wr = TIMESTAMP_WHITERABBIT(id=0x100);
  do
  {
    if (__buffer.empty()) goto no_match_20;
    int __match_no = 0;
    // optimized match 1: TIMESTAMP_WHITERABBIT wr: (s32) => (0xfffeffff,0x00000100)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1236,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) goto no_match_20;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1235,spurious_match_abort_loop_32,TIMESTAMP_WHITERABBIT,/*id*/0x100);
        UNPACK_DECL(1235,TIMESTAMP_WHITERABBIT,wr,/*id*/0x100);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_32:;
    no_match_20:;
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1240,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1239,spurious_match_abort_loop_33,TRIG3EVENT);
        UNPACK_DECL(1239,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_33:;
  // select optional

    // data = TPAT_CRATE_DATA();
  do
  {
    if (__buffer.empty()) goto no_match_21;
    int __match_no = 0;
    // optimized match 1: TPAT_CRATE_DATA data: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1244,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) goto no_match_21;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1243,TPAT_CRATE_DATA,data);
        break;
    }
  }
  while (0);
    no_match_21:;
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpat_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpat_subev)
template<typename __data_dest_t>
void PACKER_frs_tpat_subev::__packer(__data_dest_t &__buffer)
{
  // select optional

    // wr = TIMESTAMP_WHITERABBIT(id=0x100);
  {
    PACK_DECL(1235,TIMESTAMP_WHITERABBIT,wr,/*id*/0x100);
  }
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1239,TRIG3EVENT,trig3);
  }
  // select optional

    // data = TPAT_CRATE_DATA();
  {
    PACK_DECL(1243,TPAT_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpat_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_tpc_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_tpc_subev
class frs_tpc_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_tpc_subev
class PACKER_frs_tpc_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // optional UINT32 be
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 b : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 b : 32; // 0..31
#endif
    };
    uint32  u32;
  } be;
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // spill_on = SPILL_ON();
  SINGLE(SPILL_ON,spill_on);
  // select several

    // spill_off = SPILL_OFF();
  SINGLE(SPILL_OFF,spill_off);
  // select optional

    // data = TPC_CRATE_DATA();
  SINGLE(TPC_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_tpc_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
template<typename __data_src_t>
void frs_tpc_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_tpc_subev",CT_OUT(NORM));
  }
  // optional UINT32 be
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 b : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 b : 32; // 0..31
#endif
    };
    uint32  u32;
  } __be;
  if (__buffer.empty()) goto data_done_7;
  PEEK_FROM_BUFFER_FULL(1252,uint32 ,be,__be.u32,143);
  CHECK_JUMP_BITS_EQUAL(1251,__be.b,0xbad00bad,data_done_7);
  be.u32 = __be.u32;
  __buffer.advance(sizeof(__be.u32));
  if (__buffer.is_memberdump())
  {
    printf("%s%08" PRIx32 "%s: be ", CT_OUT(BOLD), __be.u32, CT_OUT(NORM));
    printf(".b=%s%8" PRIx64 "%s ", CT_OUT(BOLD), (uint64_t)  __be.b, CT_OUT(NORM));
    printf("\n");
  }
  data_done_7:;
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1256,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1255,spurious_match_abort_loop_34,TRIG3EVENT);
        UNPACK_DECL(1255,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_34:;
  // select several

    // spill_on = SPILL_ON();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SPILL_ON spill_on: (s32) => (0xffffffff,0x30303030)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1260,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1259,spurious_match_abort_loop_35,SPILL_ON);
        UNPACK_DECL(1259,SPILL_ON,spill_on);
        break;
    }
  }
  spurious_match_abort_loop_35:;
  // select several

    // spill_off = SPILL_OFF();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SPILL_OFF spill_off: (s32) => (0xffffffff,0x4040400a)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1264,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1263,spurious_match_abort_loop_36,SPILL_OFF);
        UNPACK_DECL(1263,SPILL_OFF,spill_off);
        break;
    }
  }
  spurious_match_abort_loop_36:;
  // select optional

    // data = TPC_CRATE_DATA();
  do
  {
    if (__buffer.empty()) goto no_match_22;
    int __match_no = 0;
    // optimized match 1: TPC_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1267,__match_no,1,TPC_CRATE_DATA,data);
    if (!__match_no) goto no_match_22;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1267,TPC_CRATE_DATA,data);
        break;
    }
  }
  while (0);
    no_match_22:;
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpc_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_tpc_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_tpc_subev)
template<typename __data_dest_t>
void PACKER_frs_tpc_subev::__packer(__data_dest_t &__buffer)
{
  // optional UINT32 be
  // {
    //  0_31: b = MATCH(0xbad00bad);
  // }
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1255,TRIG3EVENT,trig3);
  }
  // select several

    // spill_on = SPILL_ON();
  {
    PACK_DECL(1259,SPILL_ON,spill_on);
  }
  // select several

    // spill_off = SPILL_OFF();
  {
    PACK_DECL(1263,SPILL_OFF,spill_off);
  }
  // select optional

    // data = TPC_CRATE_DATA();
  {
    PACK_DECL(1267,TPC_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_tpc_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: frs_user_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_frs_user_subev
class frs_user_subev
#else//PACKER_CODE
# define DECLARED_PACKER_frs_user_subev
class PACKER_frs_user_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // trig3 = TRIG3EVENT();
  SINGLE(TRIG3EVENT,trig3);
  // select several

    // spill_on = SPILL_ON();
  SINGLE(SPILL_ON,spill_on);
  // select several

    // spill_off = SPILL_OFF();
  SINGLE(SPILL_OFF,spill_off);
  // select optional

    // data = USER_CRATE_DATA();
  SINGLE(USER_CRATE_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(frs_user_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
template<typename __data_src_t>
void frs_user_subev::__unpack(__data_src_t &__buffer)
{
  if (__buffer.is_memberdump())
  {
    printf("          %s%s%s: \n", CT_OUT(BOLD_MAGENTA),  "frs_user_subev",CT_OUT(NORM));
  }
  // select several

    // trig3 = TRIG3EVENT();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRIG3EVENT trig3: (s32) => (0xffffffff,0x20202020)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1276,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1275,spurious_match_abort_loop_37,TRIG3EVENT);
        UNPACK_DECL(1275,TRIG3EVENT,trig3);
        break;
    }
  }
  spurious_match_abort_loop_37:;
  // select several

    // spill_on = SPILL_ON();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SPILL_ON spill_on: (s32) => (0xffffffff,0x30303030)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1280,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1279,spurious_match_abort_loop_38,SPILL_ON);
        UNPACK_DECL(1279,SPILL_ON,spill_on);
        break;
    }
  }
  spurious_match_abort_loop_38:;
  // select several

    // spill_off = SPILL_OFF();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SPILL_OFF spill_off: (s32) => (0xffffffff,0x4040400a)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1284,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1283,spurious_match_abort_loop_39,SPILL_OFF);
        UNPACK_DECL(1283,SPILL_OFF,spill_off);
        break;
    }
  }
  spurious_match_abort_loop_39:;
  // select optional

    // data = USER_CRATE_DATA();
  do
  {
    if (__buffer.empty()) goto no_match_23;
    int __match_no = 0;
    // optimized match 1: USER_CRATE_DATA data: could not get bits
    __buffer.peeking();
    MATCH_DECL(1287,__match_no,1,USER_CRATE_DATA,data);
    if (!__match_no) goto no_match_23;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1287,USER_CRATE_DATA,data);
        break;
    }
  }
  while (0);
    no_match_23:;
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_user_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for frs_user_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(frs_user_subev)
template<typename __data_dest_t>
void PACKER_frs_user_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // trig3 = TRIG3EVENT();
  {
    PACK_DECL(1275,TRIG3EVENT,trig3);
  }
  // select several

    // spill_on = SPILL_ON();
  {
    PACK_DECL(1279,SPILL_ON,spill_on);
  }
  // select several

    // spill_off = SPILL_OFF();
  {
    PACK_DECL(1283,SPILL_OFF,spill_off);
  }
  // select optional

    // data = USER_CRATE_DATA();
  {
    PACK_DECL(1287,USER_CRATE_DATA,data);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,frs_user_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // germanium = febex_subev(type=10,subtype=1,procid=60,control=20);
  // fatima = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20);
  // fatimavme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20);
  // bgo = bgo_tamex_subevent(procid=100);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frstpat = frs_tpat_subev(procid=15);
  // beammonitor = bm_subev(procid=1);
  // ignore_unknown_subevent;
SINGLE(aida_subev,aida);
SINGLE(febex_subev,germanium);
SINGLE(fatima_tamex_subev,fatima);
SINGLE(fatima_vme_subev,fatimavme);
SINGLE(bplast_subev,bplast);
SINGLE(bgo_tamex_subevent,bgo);
SINGLE(frs_main_subev,frsmain);
SINGLE(frs_tpc_subev,frstpc);
SINGLE(frs_user_subev,frsuser);
SINGLE(frs_tpat_subev,frstpat);
SINGLE(bm_subev,beammonitor);
public:
#ifndef __PSDC__
  bitsone<12> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // germanium = febex_subev(type=10,subtype=1,procid=60,control=20);
  // fatima = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20);
  // fatimavme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20);
  // bgo = bgo_tamex_subevent(procid=100);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frstpat = frs_tpat_subev(procid=15);
  // beammonitor = bm_subev(procid=1);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1297,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==37)&&(VES10_1_procid==90)),aida);
  MATCH_SUBEVENT_DECL(1298,__match_no,2,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==60)),germanium);
  MATCH_SUBEVENT_DECL(1299,__match_no,3,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==75)),fatima);
  MATCH_SUBEVENT_DECL(1300,__match_no,4,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==70)),fatimavme);
  MATCH_SUBEVENT_DECL(1301,__match_no,5,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==80)),bplast);
  MATCH_SUBEVENT_DECL(1302,__match_no,6,((VES10_1_procid==100)),bgo);
  MATCH_SUBEVENT_DECL(1303,__match_no,7,((VES10_1_procid==10)),frsmain);
  MATCH_SUBEVENT_DECL(1304,__match_no,8,((VES10_1_procid==20)),frstpc);
  MATCH_SUBEVENT_DECL(1305,__match_no,9,((VES10_1_procid==30)),frsuser);
  MATCH_SUBEVENT_DECL(1306,__match_no,10,((VES10_1_procid==15)),frstpat);
  MATCH_SUBEVENT_DECL(1307,__match_no,11,((VES10_1_procid==1)),beammonitor);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_DECL(1297,0,aida_subev,aida);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1298,febex_subev,germanium,0);
      UNPACK_SUBEVENT_DECL(1298,0,febex_subev,germanium);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1299,fatima_tamex_subev,fatima,1);
      UNPACK_SUBEVENT_DECL(1299,0,fatima_tamex_subev,fatima);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1300,fatima_vme_subev,fatimavme,2);
      UNPACK_SUBEVENT_DECL(1300,0,fatima_vme_subev,fatimavme);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1301,bplast_subev,bplast,3);
      UNPACK_SUBEVENT_DECL(1301,0,bplast_subev,bplast);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1302,bgo_tamex_subevent,bgo,4);
      UNPACK_SUBEVENT_DECL(1302,0,bgo_tamex_subevent,bgo);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1303,frs_main_subev,frsmain,5);
      UNPACK_SUBEVENT_DECL(1303,0,frs_main_subev,frsmain);
      break;
    case 8:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1304,frs_tpc_subev,frstpc,6);
      UNPACK_SUBEVENT_DECL(1304,0,frs_tpc_subev,frstpc);
      break;
    case 9:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1305,frs_user_subev,frsuser,7);
      UNPACK_SUBEVENT_DECL(1305,0,frs_user_subev,frsuser);
      break;
    case 10:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1306,frs_tpat_subev,frstpat,8);
      UNPACK_SUBEVENT_DECL(1306,0,frs_tpat_subev,frstpat);
      break;
    case 11:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1307,bm_subev,beammonitor,9);
      UNPACK_SUBEVENT_DECL(1307,0,bm_subev,beammonitor);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // germanium = febex_subev(type=10,subtype=1,procid=60,control=20);
  // fatima = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20);
  // fatimavme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20);
  // bgo = bgo_tamex_subevent(procid=100);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frstpat = frs_tpat_subev(procid=15);
  // beammonitor = bm_subev(procid=1);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // revisit aida = aida_subev(type=10,subtype=1,procid=90,control=37);
  // germanium = febex_subev(type=10,subtype=1,procid=60,control=20);
  // fatima = fatima_tamex_subev(type=10,subtype=1,procid=75,control=20);
  // fatimavme = fatima_vme_subev(type=10,subtype=1,procid=70,control=20);
  // bplast = bplast_subev(type=10,subtype=1,procid=80,control=20);
  // bgo = bgo_tamex_subevent(procid=100);
  // frsmain = frs_main_subev(procid=10);
  // frstpc = frs_tpc_subev(procid=20);
  // frsuser = frs_user_subev(procid=30);
  // frstpat = frs_tpat_subev(procid=15);
  // beammonitor = bm_subev(procid=1);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1297,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==37)&&(VES10_1_procid==90)),aida);
  MATCH_SUBEVENT_DECL(1298,__match_no,2,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==60)),germanium);
  MATCH_SUBEVENT_DECL(1299,__match_no,3,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==75)),fatima);
  MATCH_SUBEVENT_DECL(1300,__match_no,4,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==70)),fatimavme);
  MATCH_SUBEVENT_DECL(1301,__match_no,5,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==20)&&(VES10_1_procid==80)),bplast);
  MATCH_SUBEVENT_DECL(1302,__match_no,6,((VES10_1_procid==100)),bgo);
  MATCH_SUBEVENT_DECL(1303,__match_no,7,((VES10_1_procid==10)),frsmain);
  MATCH_SUBEVENT_DECL(1304,__match_no,8,((VES10_1_procid==20)),frstpc);
  MATCH_SUBEVENT_DECL(1305,__match_no,9,((VES10_1_procid==30)),frsuser);
  MATCH_SUBEVENT_DECL(1306,__match_no,10,((VES10_1_procid==15)),frstpat);
  MATCH_SUBEVENT_DECL(1307,__match_no,11,((VES10_1_procid==1)),beammonitor);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      REVOKE_SUBEVENT_DECL(1297,0,aida_subev,aida);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1298,febex_subev,germanium,0);
      REVOKE_SUBEVENT_DECL(1298,0,febex_subev,germanium);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1299,fatima_tamex_subev,fatima,1);
      REVOKE_SUBEVENT_DECL(1299,0,fatima_tamex_subev,fatima);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1300,fatima_vme_subev,fatimavme,2);
      REVOKE_SUBEVENT_DECL(1300,0,fatima_vme_subev,fatimavme);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1301,bplast_subev,bplast,3);
      REVOKE_SUBEVENT_DECL(1301,0,bplast_subev,bplast);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1302,bgo_tamex_subevent,bgo,4);
      REVOKE_SUBEVENT_DECL(1302,0,bgo_tamex_subevent,bgo);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1303,frs_main_subev,frsmain,5);
      REVOKE_SUBEVENT_DECL(1303,0,frs_main_subev,frsmain);
      break;
    case 8:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1304,frs_tpc_subev,frstpc,6);
      REVOKE_SUBEVENT_DECL(1304,0,frs_tpc_subev,frstpc);
      break;
    case 9:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1305,frs_user_subev,frsuser,7);
      REVOKE_SUBEVENT_DECL(1305,0,frs_user_subev,frsuser);
      break;
    case 10:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1306,frs_tpat_subev,frstpat,8);
      REVOKE_SUBEVENT_DECL(1306,0,frs_tpat_subev,frstpat);
      break;
    case 11:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1307,bm_subev,beammonitor,9);
      REVOKE_SUBEVENT_DECL(1307,0,bm_subev,beammonitor);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "aida", "type=10:subtype=1:procid=90:control=37" },
{ "germanium", "type=10:subtype=1:procid=60:control=20" },
{ "fatima", "type=10:subtype=1:procid=75:control=20" },
{ "fatimavme", "type=10:subtype=1:procid=70:control=20" },
{ "bplast", "type=10:subtype=1:procid=80:control=20" },
{ "bgo", "procid=100" },
{ "frsmain", "procid=10" },
{ "frstpc", "procid=20" },
{ "frsuser", "procid=30" },
{ "frstpat", "procid=15" },
{ "beammonitor", "procid=1" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

//DUMPY: 2 0
class raw_event_MUSIC
{
public:
//DUMPY: 8 1
  raw_array_zero_suppress<DATA24,DATA24,8> E;
//DUMPY: 8 4
  raw_array_multi_zero_suppress<DATA8,DATA8,8,128> LOT;
//DUMPY: 8 4
  raw_array_multi_zero_suppress<DATA24,DATA24,8,128> T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_MUSIC);
#endif//!__PSDC__
} ;

class raw_event_SCI_MHTDC
{
public:
//DUMPY: 16 4
  raw_array_multi_zero_suppress<DATA8,DATA8,16,128> LOT;
//DUMPY: 16 4
  raw_array_multi_zero_suppress<DATA24,DATA24,16,128> T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_SCI_MHTDC);
#endif//!__PSDC__
} ;

class raw_event_SCI_TAC
{
public:
//DUMPY: 16 1
  raw_array_zero_suppress<DATA24,DATA24,16> DE;
//DUMPY: 16 1
  raw_array_zero_suppress<DATA24,DATA24,16> DT;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_SCI_TAC);
#endif//!__PSDC__
} ;

class raw_event_SCI
{
public:
  raw_event_SCI_MHTDC
  /* {
  public:
//DUMPY: 16 4
    raw_array_multi_zero_suppress<DATA8,DATA8,16,128> LOT;
//DUMPY: 16 4
    raw_array_multi_zero_suppress<DATA24,DATA24,16,128> T;
  } */ MHTDC;
  raw_event_SCI_TAC
  /* {
  public:
//DUMPY: 16 1
    raw_array_zero_suppress<DATA24,DATA24,16> DE;
//DUMPY: 16 1
    raw_array_zero_suppress<DATA24,DATA24,16> DT;
  } */ TAC;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_SCI);
#endif//!__PSDC__
} ;

class raw_event_SPILL
{
public:
  DATA8 OFF;
  DATA8 ON;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_SPILL);
#endif//!__PSDC__
} ;

class raw_event_TPC_TDC
{
public:
//DUMPY: 128 4
  raw_array_multi_zero_suppress<DATA8,DATA8,128,128> LOT;
//DUMPY: 128 4
  raw_array_multi_zero_suppress<DATA24,DATA24,128,128> T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TPC_TDC);
#endif//!__PSDC__
} ;

class raw_event_TPC
{
public:
//DUMPY: 7 0
//DUMPY: 32 1
  raw_array_zero_suppress<DATA24,DATA24,32> ADC[7];
  raw_event_TPC_TDC
  /* {
  public:
//DUMPY: 128 4
    raw_array_multi_zero_suppress<DATA8,DATA8,128,128> LOT;
//DUMPY: 128 4
    raw_array_multi_zero_suppress<DATA24,DATA24,128,128> T;
  } */ TDC;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TPC);
#endif//!__PSDC__
} ;

class raw_event_WR
{
public:
  DATA12 ID;
//DUMPY: 4 0
  DATA16 T[4];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_WR);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
//DUMPY: 2 0
  raw_event_MUSIC
  /* {
  public:
//DUMPY: 8 1
    raw_array_zero_suppress<DATA24,DATA24,8> E;
//DUMPY: 8 4
    raw_array_multi_zero_suppress<DATA8,DATA8,8,128> LOT;
//DUMPY: 8 4
    raw_array_multi_zero_suppress<DATA24,DATA24,8,128> T;
  } */ MUSIC[2];
//DUMPY: 2 0
//DUMPY: 32 1
  raw_array_zero_suppress<DATA32,DATA32,32> SCALERS[2];
  raw_event_SCI
  /* {
  public:
    raw_event_SCI_MHTDC
    {
    public:
//DUMPY: 16 4
      raw_array_multi_zero_suppress<DATA8,DATA8,16,128> LOT;
//DUMPY: 16 4
      raw_array_multi_zero_suppress<DATA24,DATA24,16,128> T;
    } MHTDC;
    raw_event_SCI_TAC
    {
    public:
//DUMPY: 16 1
      raw_array_zero_suppress<DATA24,DATA24,16> DE;
//DUMPY: 16 1
      raw_array_zero_suppress<DATA24,DATA24,16> DT;
    } TAC;
  } */ SCI;
  raw_event_SPILL
  /* {
  public:
    DATA8 OFF;
    DATA8 ON;
  } */ SPILL;
  DATA16 TPAT;
  raw_event_TPC
  /* {
  public:
//DUMPY: 7 0
//DUMPY: 32 1
    raw_array_zero_suppress<DATA24,DATA24,32> ADC[7];
    raw_event_TPC_TDC
    {
    public:
//DUMPY: 128 4
      raw_array_multi_zero_suppress<DATA8,DATA8,128,128> LOT;
//DUMPY: 128 4
      raw_array_multi_zero_suppress<DATA24,DATA24,128,128> T;
    } TDC;
  } */ TPC;
  raw_event_WR
  /* {
  public:
    DATA12 ID;
//DUMPY: 4 0
    DATA16 T[4];
  } */ WR;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA24,MUSIC1E1,frsuser.data.v785[0].data[0],MUSIC[0].E[0]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,0)*/
SIGNAL_MAPPING(DATA24,MUSIC1E2,frsuser.data.v785[0].data[1],MUSIC[0].E[1]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,1)*/
SIGNAL_MAPPING(DATA24,MUSIC1E3,frsuser.data.v785[0].data[2],MUSIC[0].E[2]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,2)*/
SIGNAL_MAPPING(DATA24,MUSIC1E4,frsuser.data.v785[0].data[3],MUSIC[0].E[3]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,3)*/
SIGNAL_MAPPING(DATA24,MUSIC1E5,frsuser.data.v785[0].data[4],MUSIC[0].E[4]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,4)*/
SIGNAL_MAPPING(DATA24,MUSIC1E6,frsuser.data.v785[0].data[5],MUSIC[0].E[5]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,5)*/
SIGNAL_MAPPING(DATA24,MUSIC1E7,frsuser.data.v785[0].data[6],MUSIC[0].E[6]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,6)*/
SIGNAL_MAPPING(DATA24,MUSIC1E8,frsuser.data.v785[0].data[7],MUSIC[0].E[7]);/*,ZERO_SUPPRESS_ITEM(MUSIC[0].E,7)*/
SIGNAL_MAPPING(DATA8,MUSIC1LOT1,frsmain.data.v1290.measurement.leadOrTrail[16],MUSIC[0].LOT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT2,frsmain.data.v1290.measurement.leadOrTrail[17],MUSIC[0].LOT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT3,frsmain.data.v1290.measurement.leadOrTrail[18],MUSIC[0].LOT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT4,frsmain.data.v1290.measurement.leadOrTrail[19],MUSIC[0].LOT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT5,frsmain.data.v1290.measurement.leadOrTrail[20],MUSIC[0].LOT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT6,frsmain.data.v1290.measurement.leadOrTrail[21],MUSIC[0].LOT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT7,frsmain.data.v1290.measurement.leadOrTrail[22],MUSIC[0].LOT[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC1LOT8,frsmain.data.v1290.measurement.leadOrTrail[23],MUSIC[0].LOT[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T1,frsmain.data.v1290.measurement.data[16],MUSIC[0].T[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T2,frsmain.data.v1290.measurement.data[17],MUSIC[0].T[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T3,frsmain.data.v1290.measurement.data[18],MUSIC[0].T[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T4,frsmain.data.v1290.measurement.data[19],MUSIC[0].T[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T5,frsmain.data.v1290.measurement.data[20],MUSIC[0].T[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T6,frsmain.data.v1290.measurement.data[21],MUSIC[0].T[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T7,frsmain.data.v1290.measurement.data[22],MUSIC[0].T[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC1T8,frsmain.data.v1290.measurement.data[23],MUSIC[0].T[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2E1,frsuser.data.v785[0].data[8],MUSIC[1].E[0]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,0)*/
SIGNAL_MAPPING(DATA24,MUSIC2E2,frsuser.data.v785[0].data[9],MUSIC[1].E[1]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,1)*/
SIGNAL_MAPPING(DATA24,MUSIC2E3,frsuser.data.v785[0].data[10],MUSIC[1].E[2]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,2)*/
SIGNAL_MAPPING(DATA24,MUSIC2E4,frsuser.data.v785[0].data[11],MUSIC[1].E[3]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,3)*/
SIGNAL_MAPPING(DATA24,MUSIC2E5,frsuser.data.v785[0].data[12],MUSIC[1].E[4]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,4)*/
SIGNAL_MAPPING(DATA24,MUSIC2E6,frsuser.data.v785[0].data[13],MUSIC[1].E[5]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,5)*/
SIGNAL_MAPPING(DATA24,MUSIC2E7,frsuser.data.v785[0].data[14],MUSIC[1].E[6]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,6)*/
SIGNAL_MAPPING(DATA24,MUSIC2E8,frsuser.data.v785[0].data[15],MUSIC[1].E[7]);/*,ZERO_SUPPRESS_ITEM(MUSIC[1].E,7)*/
SIGNAL_MAPPING(DATA8,MUSIC2LOT1,frsmain.data.v1290.measurement.leadOrTrail[24],MUSIC[1].LOT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT2,frsmain.data.v1290.measurement.leadOrTrail[25],MUSIC[1].LOT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT3,frsmain.data.v1290.measurement.leadOrTrail[26],MUSIC[1].LOT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT4,frsmain.data.v1290.measurement.leadOrTrail[27],MUSIC[1].LOT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT5,frsmain.data.v1290.measurement.leadOrTrail[28],MUSIC[1].LOT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT6,frsmain.data.v1290.measurement.leadOrTrail[29],MUSIC[1].LOT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT7,frsmain.data.v1290.measurement.leadOrTrail[30],MUSIC[1].LOT[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,MUSIC2LOT8,frsmain.data.v1290.measurement.leadOrTrail[31],MUSIC[1].LOT[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T1,frsmain.data.v1290.measurement.data[24],MUSIC[1].T[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T2,frsmain.data.v1290.measurement.data[25],MUSIC[1].T[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T3,frsmain.data.v1290.measurement.data[26],MUSIC[1].T[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T4,frsmain.data.v1290.measurement.data[27],MUSIC[1].T[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T5,frsmain.data.v1290.measurement.data[28],MUSIC[1].T[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T6,frsmain.data.v1290.measurement.data[29],MUSIC[1].T[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T7,frsmain.data.v1290.measurement.data[30],MUSIC[1].T[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,MUSIC2T8,frsmain.data.v1290.measurement.data[31],MUSIC[1].T[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA32,SCALERS1_1,frsmain.data.v830.data[0],SCALERS[0][0]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],0)*/
SIGNAL_MAPPING(DATA32,SCALERS1_10,frsmain.data.v830.data[9],SCALERS[0][9]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],9)*/
SIGNAL_MAPPING(DATA32,SCALERS1_11,frsmain.data.v830.data[10],SCALERS[0][10]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],10)*/
SIGNAL_MAPPING(DATA32,SCALERS1_12,frsmain.data.v830.data[11],SCALERS[0][11]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],11)*/
SIGNAL_MAPPING(DATA32,SCALERS1_13,frsmain.data.v830.data[12],SCALERS[0][12]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],12)*/
SIGNAL_MAPPING(DATA32,SCALERS1_14,frsmain.data.v830.data[13],SCALERS[0][13]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],13)*/
SIGNAL_MAPPING(DATA32,SCALERS1_15,frsmain.data.v830.data[14],SCALERS[0][14]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],14)*/
SIGNAL_MAPPING(DATA32,SCALERS1_16,frsmain.data.v830.data[15],SCALERS[0][15]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],15)*/
SIGNAL_MAPPING(DATA32,SCALERS1_17,frsmain.data.v830.data[16],SCALERS[0][16]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],16)*/
SIGNAL_MAPPING(DATA32,SCALERS1_18,frsmain.data.v830.data[17],SCALERS[0][17]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],17)*/
SIGNAL_MAPPING(DATA32,SCALERS1_19,frsmain.data.v830.data[18],SCALERS[0][18]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],18)*/
SIGNAL_MAPPING(DATA32,SCALERS1_2,frsmain.data.v830.data[1],SCALERS[0][1]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],1)*/
SIGNAL_MAPPING(DATA32,SCALERS1_20,frsmain.data.v830.data[19],SCALERS[0][19]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],19)*/
SIGNAL_MAPPING(DATA32,SCALERS1_21,frsmain.data.v830.data[20],SCALERS[0][20]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],20)*/
SIGNAL_MAPPING(DATA32,SCALERS1_22,frsmain.data.v830.data[21],SCALERS[0][21]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],21)*/
SIGNAL_MAPPING(DATA32,SCALERS1_23,frsmain.data.v830.data[22],SCALERS[0][22]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],22)*/
SIGNAL_MAPPING(DATA32,SCALERS1_24,frsmain.data.v830.data[23],SCALERS[0][23]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],23)*/
SIGNAL_MAPPING(DATA32,SCALERS1_25,frsmain.data.v830.data[24],SCALERS[0][24]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],24)*/
SIGNAL_MAPPING(DATA32,SCALERS1_26,frsmain.data.v830.data[25],SCALERS[0][25]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],25)*/
SIGNAL_MAPPING(DATA32,SCALERS1_27,frsmain.data.v830.data[26],SCALERS[0][26]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],26)*/
SIGNAL_MAPPING(DATA32,SCALERS1_28,frsmain.data.v830.data[27],SCALERS[0][27]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],27)*/
SIGNAL_MAPPING(DATA32,SCALERS1_29,frsmain.data.v830.data[28],SCALERS[0][28]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],28)*/
SIGNAL_MAPPING(DATA32,SCALERS1_3,frsmain.data.v830.data[2],SCALERS[0][2]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],2)*/
SIGNAL_MAPPING(DATA32,SCALERS1_30,frsmain.data.v830.data[29],SCALERS[0][29]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],29)*/
SIGNAL_MAPPING(DATA32,SCALERS1_31,frsmain.data.v830.data[30],SCALERS[0][30]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],30)*/
SIGNAL_MAPPING(DATA32,SCALERS1_32,frsmain.data.v830.data[31],SCALERS[0][31]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],31)*/
SIGNAL_MAPPING(DATA32,SCALERS1_4,frsmain.data.v830.data[3],SCALERS[0][3]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],3)*/
SIGNAL_MAPPING(DATA32,SCALERS1_5,frsmain.data.v830.data[4],SCALERS[0][4]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],4)*/
SIGNAL_MAPPING(DATA32,SCALERS1_6,frsmain.data.v830.data[5],SCALERS[0][5]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],5)*/
SIGNAL_MAPPING(DATA32,SCALERS1_7,frsmain.data.v830.data[6],SCALERS[0][6]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],6)*/
SIGNAL_MAPPING(DATA32,SCALERS1_8,frsmain.data.v830.data[7],SCALERS[0][7]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],7)*/
SIGNAL_MAPPING(DATA32,SCALERS1_9,frsmain.data.v830.data[8],SCALERS[0][8]);/*,ZERO_SUPPRESS_ITEM(SCALERS[0],8)*/
SIGNAL_MAPPING(DATA32,SCALERS2_1,frsuser.data.v830.data[0],SCALERS[1][0]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],0)*/
SIGNAL_MAPPING(DATA32,SCALERS2_10,frsuser.data.v830.data[9],SCALERS[1][9]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],9)*/
SIGNAL_MAPPING(DATA32,SCALERS2_11,frsuser.data.v830.data[10],SCALERS[1][10]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],10)*/
SIGNAL_MAPPING(DATA32,SCALERS2_12,frsuser.data.v830.data[11],SCALERS[1][11]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],11)*/
SIGNAL_MAPPING(DATA32,SCALERS2_13,frsuser.data.v830.data[12],SCALERS[1][12]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],12)*/
SIGNAL_MAPPING(DATA32,SCALERS2_14,frsuser.data.v830.data[13],SCALERS[1][13]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],13)*/
SIGNAL_MAPPING(DATA32,SCALERS2_15,frsuser.data.v830.data[14],SCALERS[1][14]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],14)*/
SIGNAL_MAPPING(DATA32,SCALERS2_16,frsuser.data.v830.data[15],SCALERS[1][15]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],15)*/
SIGNAL_MAPPING(DATA32,SCALERS2_17,frsuser.data.v830.data[16],SCALERS[1][16]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],16)*/
SIGNAL_MAPPING(DATA32,SCALERS2_18,frsuser.data.v830.data[17],SCALERS[1][17]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],17)*/
SIGNAL_MAPPING(DATA32,SCALERS2_19,frsuser.data.v830.data[18],SCALERS[1][18]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],18)*/
SIGNAL_MAPPING(DATA32,SCALERS2_2,frsuser.data.v830.data[1],SCALERS[1][1]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],1)*/
SIGNAL_MAPPING(DATA32,SCALERS2_20,frsuser.data.v830.data[19],SCALERS[1][19]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],19)*/
SIGNAL_MAPPING(DATA32,SCALERS2_21,frsuser.data.v830.data[20],SCALERS[1][20]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],20)*/
SIGNAL_MAPPING(DATA32,SCALERS2_22,frsuser.data.v830.data[21],SCALERS[1][21]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],21)*/
SIGNAL_MAPPING(DATA32,SCALERS2_23,frsuser.data.v830.data[22],SCALERS[1][22]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],22)*/
SIGNAL_MAPPING(DATA32,SCALERS2_24,frsuser.data.v830.data[23],SCALERS[1][23]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],23)*/
SIGNAL_MAPPING(DATA32,SCALERS2_25,frsuser.data.v830.data[24],SCALERS[1][24]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],24)*/
SIGNAL_MAPPING(DATA32,SCALERS2_26,frsuser.data.v830.data[25],SCALERS[1][25]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],25)*/
SIGNAL_MAPPING(DATA32,SCALERS2_27,frsuser.data.v830.data[26],SCALERS[1][26]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],26)*/
SIGNAL_MAPPING(DATA32,SCALERS2_28,frsuser.data.v830.data[27],SCALERS[1][27]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],27)*/
SIGNAL_MAPPING(DATA32,SCALERS2_29,frsuser.data.v830.data[28],SCALERS[1][28]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],28)*/
SIGNAL_MAPPING(DATA32,SCALERS2_3,frsuser.data.v830.data[2],SCALERS[1][2]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],2)*/
SIGNAL_MAPPING(DATA32,SCALERS2_30,frsuser.data.v830.data[29],SCALERS[1][29]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],29)*/
SIGNAL_MAPPING(DATA32,SCALERS2_31,frsuser.data.v830.data[30],SCALERS[1][30]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],30)*/
SIGNAL_MAPPING(DATA32,SCALERS2_32,frsuser.data.v830.data[31],SCALERS[1][31]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],31)*/
SIGNAL_MAPPING(DATA32,SCALERS2_4,frsuser.data.v830.data[3],SCALERS[1][3]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],3)*/
SIGNAL_MAPPING(DATA32,SCALERS2_5,frsuser.data.v830.data[4],SCALERS[1][4]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],4)*/
SIGNAL_MAPPING(DATA32,SCALERS2_6,frsuser.data.v830.data[5],SCALERS[1][5]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],5)*/
SIGNAL_MAPPING(DATA32,SCALERS2_7,frsuser.data.v830.data[6],SCALERS[1][6]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],6)*/
SIGNAL_MAPPING(DATA32,SCALERS2_8,frsuser.data.v830.data[7],SCALERS[1][7]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],7)*/
SIGNAL_MAPPING(DATA32,SCALERS2_9,frsuser.data.v830.data[8],SCALERS[1][8]);/*,ZERO_SUPPRESS_ITEM(SCALERS[1],8)*/
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT1,frsmain.data.v1290.measurement.leadOrTrail[0],SCI.MHTDC.LOT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT10,frsmain.data.v1290.measurement.leadOrTrail[9],SCI.MHTDC.LOT[9]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT11,frsmain.data.v1290.measurement.leadOrTrail[10],SCI.MHTDC.LOT[10]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT12,frsmain.data.v1290.measurement.leadOrTrail[11],SCI.MHTDC.LOT[11]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT13,frsmain.data.v1290.measurement.leadOrTrail[12],SCI.MHTDC.LOT[12]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT14,frsmain.data.v1290.measurement.leadOrTrail[13],SCI.MHTDC.LOT[13]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT15,frsmain.data.v1290.measurement.leadOrTrail[14],SCI.MHTDC.LOT[14]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT16,frsmain.data.v1290.measurement.leadOrTrail[15],SCI.MHTDC.LOT[15]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT2,frsmain.data.v1290.measurement.leadOrTrail[1],SCI.MHTDC.LOT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT3,frsmain.data.v1290.measurement.leadOrTrail[2],SCI.MHTDC.LOT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT4,frsmain.data.v1290.measurement.leadOrTrail[3],SCI.MHTDC.LOT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT5,frsmain.data.v1290.measurement.leadOrTrail[4],SCI.MHTDC.LOT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT6,frsmain.data.v1290.measurement.leadOrTrail[5],SCI.MHTDC.LOT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT7,frsmain.data.v1290.measurement.leadOrTrail[6],SCI.MHTDC.LOT[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT8,frsmain.data.v1290.measurement.leadOrTrail[7],SCI.MHTDC.LOT[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,SCI_MHTDC_LOT9,frsmain.data.v1290.measurement.leadOrTrail[8],SCI.MHTDC.LOT[8]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T1,frsmain.data.v1290.measurement.data[0],SCI.MHTDC.T[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T10,frsmain.data.v1290.measurement.data[9],SCI.MHTDC.T[9]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T11,frsmain.data.v1290.measurement.data[10],SCI.MHTDC.T[10]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T12,frsmain.data.v1290.measurement.data[11],SCI.MHTDC.T[11]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T13,frsmain.data.v1290.measurement.data[12],SCI.MHTDC.T[12]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T14,frsmain.data.v1290.measurement.data[13],SCI.MHTDC.T[13]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T15,frsmain.data.v1290.measurement.data[14],SCI.MHTDC.T[14]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T16,frsmain.data.v1290.measurement.data[15],SCI.MHTDC.T[15]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T2,frsmain.data.v1290.measurement.data[1],SCI.MHTDC.T[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T3,frsmain.data.v1290.measurement.data[2],SCI.MHTDC.T[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T4,frsmain.data.v1290.measurement.data[3],SCI.MHTDC.T[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T5,frsmain.data.v1290.measurement.data[4],SCI.MHTDC.T[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T6,frsmain.data.v1290.measurement.data[5],SCI.MHTDC.T[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T7,frsmain.data.v1290.measurement.data[6],SCI.MHTDC.T[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T8,frsmain.data.v1290.measurement.data[7],SCI.MHTDC.T[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_MHTDC_T9,frsmain.data.v1290.measurement.data[8],SCI.MHTDC.T[8]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,SCI_TAC_DE1,frsmain.data.v792.data[0],SCI.TAC.DE[0]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,0)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE10,frsmain.data.v792.data[9],SCI.TAC.DE[9]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,9)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE11,frsmain.data.v792.data[10],SCI.TAC.DE[10]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,10)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE12,frsmain.data.v792.data[11],SCI.TAC.DE[11]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,11)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE13,frsmain.data.v792.data[12],SCI.TAC.DE[12]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,12)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE14,frsmain.data.v792.data[13],SCI.TAC.DE[13]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,13)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE15,frsmain.data.v792.data[14],SCI.TAC.DE[14]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,14)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE16,frsmain.data.v792.data[15],SCI.TAC.DE[15]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,15)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE2,frsmain.data.v792.data[1],SCI.TAC.DE[1]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,1)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE3,frsmain.data.v792.data[2],SCI.TAC.DE[2]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,2)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE4,frsmain.data.v792.data[3],SCI.TAC.DE[3]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,3)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE5,frsmain.data.v792.data[4],SCI.TAC.DE[4]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,4)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE6,frsmain.data.v792.data[5],SCI.TAC.DE[5]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,5)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE7,frsmain.data.v792.data[6],SCI.TAC.DE[6]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,6)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE8,frsmain.data.v792.data[7],SCI.TAC.DE[7]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,7)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DE9,frsmain.data.v792.data[8],SCI.TAC.DE[8]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DE,8)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT1,frsuser.data.v785[1].data[0],SCI.TAC.DT[0]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,0)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT10,frsuser.data.v785[1].data[9],SCI.TAC.DT[9]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,9)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT11,frsuser.data.v785[1].data[10],SCI.TAC.DT[10]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,10)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT12,frsuser.data.v785[1].data[11],SCI.TAC.DT[11]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,11)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT13,frsuser.data.v785[1].data[12],SCI.TAC.DT[12]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,12)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT14,frsuser.data.v785[1].data[13],SCI.TAC.DT[13]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,13)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT15,frsuser.data.v785[1].data[14],SCI.TAC.DT[14]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,14)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT16,frsuser.data.v785[1].data[15],SCI.TAC.DT[15]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,15)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT2,frsuser.data.v785[1].data[1],SCI.TAC.DT[1]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,1)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT3,frsuser.data.v785[1].data[2],SCI.TAC.DT[2]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,2)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT4,frsuser.data.v785[1].data[3],SCI.TAC.DT[3]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,3)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT5,frsuser.data.v785[1].data[4],SCI.TAC.DT[4]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,4)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT6,frsuser.data.v785[1].data[5],SCI.TAC.DT[5]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,5)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT7,frsuser.data.v785[1].data[6],SCI.TAC.DT[6]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,6)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT8,frsuser.data.v785[1].data[7],SCI.TAC.DT[7]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,7)*/
SIGNAL_MAPPING(DATA24,SCI_TAC_DT9,frsuser.data.v785[1].data[8],SCI.TAC.DT[8]);/*,ZERO_SUPPRESS_ITEM(SCI.TAC.DT,8)*/
SIGNAL_MAPPING(DATA8,SPILL_OFF,frsmain.spill_off.spilloff,SPILL.OFF);
SIGNAL_MAPPING(DATA8,SPILL_ON,frsmain.spill_on.spillon,SPILL.ON);
SIGNAL_MAPPING(DATA16,TPAT,frstpat.data.tpat,TPAT);
SIGNAL_MAPPING(DATA24,TPC_ADC1_1,frstpc.data.v775.data[0],TPC.ADC[0][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_2,frstpc.data.v775.data[1],TPC.ADC[0][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_3,frstpc.data.v775.data[2],TPC.ADC[0][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_4,frstpc.data.v775.data[3],TPC.ADC[0][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_5,frstpc.data.v775.data[4],TPC.ADC[0][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_6,frstpc.data.v775.data[5],TPC.ADC[0][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_7,frstpc.data.v775.data[6],TPC.ADC[0][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC1_8,frstpc.data.v775.data[7],TPC.ADC[0][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[0],7)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_1,frstpc.data.v775.data[8],TPC.ADC[1][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_2,frstpc.data.v775.data[9],TPC.ADC[1][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_3,frstpc.data.v775.data[10],TPC.ADC[1][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_4,frstpc.data.v775.data[11],TPC.ADC[1][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_5,frstpc.data.v775.data[12],TPC.ADC[1][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_6,frstpc.data.v775.data[13],TPC.ADC[1][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_7,frstpc.data.v775.data[14],TPC.ADC[1][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC2_8,frstpc.data.v775.data[15],TPC.ADC[1][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[1],7)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_1,frstpc.data.v775.data[16],TPC.ADC[2][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_2,frstpc.data.v775.data[17],TPC.ADC[2][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_3,frstpc.data.v775.data[18],TPC.ADC[2][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_4,frstpc.data.v775.data[19],TPC.ADC[2][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_5,frstpc.data.v775.data[20],TPC.ADC[2][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_6,frstpc.data.v775.data[21],TPC.ADC[2][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_7,frstpc.data.v775.data[22],TPC.ADC[2][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC3_8,frstpc.data.v775.data[23],TPC.ADC[2][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[2],7)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_1,frstpc.data.v775.data[24],TPC.ADC[3][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_2,frstpc.data.v775.data[25],TPC.ADC[3][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_3,frstpc.data.v775.data[26],TPC.ADC[3][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_4,frstpc.data.v775.data[27],TPC.ADC[3][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_5,frstpc.data.v775.data[28],TPC.ADC[3][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_6,frstpc.data.v775.data[29],TPC.ADC[3][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_7,frstpc.data.v775.data[30],TPC.ADC[3][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC4_8,frstpc.data.v775.data[31],TPC.ADC[3][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[3],7)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_1,frstpc.data.v785.data[0],TPC.ADC[4][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_2,frstpc.data.v785.data[1],TPC.ADC[4][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_3,frstpc.data.v785.data[2],TPC.ADC[4][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_4,frstpc.data.v785.data[3],TPC.ADC[4][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_5,frstpc.data.v785.data[4],TPC.ADC[4][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_6,frstpc.data.v785.data[5],TPC.ADC[4][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_7,frstpc.data.v785.data[6],TPC.ADC[4][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC5_8,frstpc.data.v785.data[7],TPC.ADC[4][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[4],7)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_1,frstpc.data.v785.data[8],TPC.ADC[5][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_2,frstpc.data.v785.data[9],TPC.ADC[5][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_3,frstpc.data.v785.data[10],TPC.ADC[5][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_4,frstpc.data.v785.data[11],TPC.ADC[5][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_5,frstpc.data.v785.data[12],TPC.ADC[5][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_6,frstpc.data.v785.data[13],TPC.ADC[5][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_7,frstpc.data.v785.data[14],TPC.ADC[5][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC6_8,frstpc.data.v785.data[15],TPC.ADC[5][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[5],7)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_1,frstpc.data.v785.data[16],TPC.ADC[6][0]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],0)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_2,frstpc.data.v785.data[17],TPC.ADC[6][1]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],1)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_3,frstpc.data.v785.data[18],TPC.ADC[6][2]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],2)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_4,frstpc.data.v785.data[19],TPC.ADC[6][3]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],3)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_5,frstpc.data.v785.data[20],TPC.ADC[6][4]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],4)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_6,frstpc.data.v785.data[21],TPC.ADC[6][5]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],5)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_7,frstpc.data.v785.data[22],TPC.ADC[6][6]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],6)*/
SIGNAL_MAPPING(DATA24,TPC_ADC7_8,frstpc.data.v785.data[23],TPC.ADC[6][7]);/*,ZERO_SUPPRESS_ITEM(TPC.ADC[6],7)*/
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT1,frstpc.data.v1190.measurement.leadOrTrail[0],TPC.TDC.LOT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT10,frstpc.data.v1190.measurement.leadOrTrail[9],TPC.TDC.LOT[9]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT100,frstpc.data.v1190.measurement.leadOrTrail[99],TPC.TDC.LOT[99]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT101,frstpc.data.v1190.measurement.leadOrTrail[100],TPC.TDC.LOT[100]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT102,frstpc.data.v1190.measurement.leadOrTrail[101],TPC.TDC.LOT[101]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT103,frstpc.data.v1190.measurement.leadOrTrail[102],TPC.TDC.LOT[102]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT104,frstpc.data.v1190.measurement.leadOrTrail[103],TPC.TDC.LOT[103]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT105,frstpc.data.v1190.measurement.leadOrTrail[104],TPC.TDC.LOT[104]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT106,frstpc.data.v1190.measurement.leadOrTrail[105],TPC.TDC.LOT[105]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT107,frstpc.data.v1190.measurement.leadOrTrail[106],TPC.TDC.LOT[106]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT108,frstpc.data.v1190.measurement.leadOrTrail[107],TPC.TDC.LOT[107]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT109,frstpc.data.v1190.measurement.leadOrTrail[108],TPC.TDC.LOT[108]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT11,frstpc.data.v1190.measurement.leadOrTrail[10],TPC.TDC.LOT[10]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT110,frstpc.data.v1190.measurement.leadOrTrail[109],TPC.TDC.LOT[109]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT111,frstpc.data.v1190.measurement.leadOrTrail[110],TPC.TDC.LOT[110]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT112,frstpc.data.v1190.measurement.leadOrTrail[111],TPC.TDC.LOT[111]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT113,frstpc.data.v1190.measurement.leadOrTrail[112],TPC.TDC.LOT[112]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT114,frstpc.data.v1190.measurement.leadOrTrail[113],TPC.TDC.LOT[113]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT115,frstpc.data.v1190.measurement.leadOrTrail[114],TPC.TDC.LOT[114]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT116,frstpc.data.v1190.measurement.leadOrTrail[115],TPC.TDC.LOT[115]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT117,frstpc.data.v1190.measurement.leadOrTrail[116],TPC.TDC.LOT[116]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT118,frstpc.data.v1190.measurement.leadOrTrail[117],TPC.TDC.LOT[117]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT119,frstpc.data.v1190.measurement.leadOrTrail[118],TPC.TDC.LOT[118]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT12,frstpc.data.v1190.measurement.leadOrTrail[11],TPC.TDC.LOT[11]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT120,frstpc.data.v1190.measurement.leadOrTrail[119],TPC.TDC.LOT[119]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT121,frstpc.data.v1190.measurement.leadOrTrail[120],TPC.TDC.LOT[120]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT122,frstpc.data.v1190.measurement.leadOrTrail[121],TPC.TDC.LOT[121]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT123,frstpc.data.v1190.measurement.leadOrTrail[122],TPC.TDC.LOT[122]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT124,frstpc.data.v1190.measurement.leadOrTrail[123],TPC.TDC.LOT[123]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT125,frstpc.data.v1190.measurement.leadOrTrail[124],TPC.TDC.LOT[124]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT126,frstpc.data.v1190.measurement.leadOrTrail[125],TPC.TDC.LOT[125]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT127,frstpc.data.v1190.measurement.leadOrTrail[126],TPC.TDC.LOT[126]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT128,frstpc.data.v1190.measurement.leadOrTrail[127],TPC.TDC.LOT[127]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT13,frstpc.data.v1190.measurement.leadOrTrail[12],TPC.TDC.LOT[12]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT14,frstpc.data.v1190.measurement.leadOrTrail[13],TPC.TDC.LOT[13]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT15,frstpc.data.v1190.measurement.leadOrTrail[14],TPC.TDC.LOT[14]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT16,frstpc.data.v1190.measurement.leadOrTrail[15],TPC.TDC.LOT[15]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT17,frstpc.data.v1190.measurement.leadOrTrail[16],TPC.TDC.LOT[16]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT18,frstpc.data.v1190.measurement.leadOrTrail[17],TPC.TDC.LOT[17]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT19,frstpc.data.v1190.measurement.leadOrTrail[18],TPC.TDC.LOT[18]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT2,frstpc.data.v1190.measurement.leadOrTrail[1],TPC.TDC.LOT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT20,frstpc.data.v1190.measurement.leadOrTrail[19],TPC.TDC.LOT[19]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT21,frstpc.data.v1190.measurement.leadOrTrail[20],TPC.TDC.LOT[20]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT22,frstpc.data.v1190.measurement.leadOrTrail[21],TPC.TDC.LOT[21]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT23,frstpc.data.v1190.measurement.leadOrTrail[22],TPC.TDC.LOT[22]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT24,frstpc.data.v1190.measurement.leadOrTrail[23],TPC.TDC.LOT[23]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT25,frstpc.data.v1190.measurement.leadOrTrail[24],TPC.TDC.LOT[24]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT26,frstpc.data.v1190.measurement.leadOrTrail[25],TPC.TDC.LOT[25]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT27,frstpc.data.v1190.measurement.leadOrTrail[26],TPC.TDC.LOT[26]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT28,frstpc.data.v1190.measurement.leadOrTrail[27],TPC.TDC.LOT[27]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT29,frstpc.data.v1190.measurement.leadOrTrail[28],TPC.TDC.LOT[28]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT3,frstpc.data.v1190.measurement.leadOrTrail[2],TPC.TDC.LOT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT30,frstpc.data.v1190.measurement.leadOrTrail[29],TPC.TDC.LOT[29]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT31,frstpc.data.v1190.measurement.leadOrTrail[30],TPC.TDC.LOT[30]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT32,frstpc.data.v1190.measurement.leadOrTrail[31],TPC.TDC.LOT[31]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT33,frstpc.data.v1190.measurement.leadOrTrail[32],TPC.TDC.LOT[32]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT34,frstpc.data.v1190.measurement.leadOrTrail[33],TPC.TDC.LOT[33]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT35,frstpc.data.v1190.measurement.leadOrTrail[34],TPC.TDC.LOT[34]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT36,frstpc.data.v1190.measurement.leadOrTrail[35],TPC.TDC.LOT[35]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT37,frstpc.data.v1190.measurement.leadOrTrail[36],TPC.TDC.LOT[36]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT38,frstpc.data.v1190.measurement.leadOrTrail[37],TPC.TDC.LOT[37]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT39,frstpc.data.v1190.measurement.leadOrTrail[38],TPC.TDC.LOT[38]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT4,frstpc.data.v1190.measurement.leadOrTrail[3],TPC.TDC.LOT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT40,frstpc.data.v1190.measurement.leadOrTrail[39],TPC.TDC.LOT[39]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT41,frstpc.data.v1190.measurement.leadOrTrail[40],TPC.TDC.LOT[40]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT42,frstpc.data.v1190.measurement.leadOrTrail[41],TPC.TDC.LOT[41]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT43,frstpc.data.v1190.measurement.leadOrTrail[42],TPC.TDC.LOT[42]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT44,frstpc.data.v1190.measurement.leadOrTrail[43],TPC.TDC.LOT[43]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT45,frstpc.data.v1190.measurement.leadOrTrail[44],TPC.TDC.LOT[44]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT46,frstpc.data.v1190.measurement.leadOrTrail[45],TPC.TDC.LOT[45]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT47,frstpc.data.v1190.measurement.leadOrTrail[46],TPC.TDC.LOT[46]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT48,frstpc.data.v1190.measurement.leadOrTrail[47],TPC.TDC.LOT[47]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT49,frstpc.data.v1190.measurement.leadOrTrail[48],TPC.TDC.LOT[48]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT5,frstpc.data.v1190.measurement.leadOrTrail[4],TPC.TDC.LOT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT50,frstpc.data.v1190.measurement.leadOrTrail[49],TPC.TDC.LOT[49]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT51,frstpc.data.v1190.measurement.leadOrTrail[50],TPC.TDC.LOT[50]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT52,frstpc.data.v1190.measurement.leadOrTrail[51],TPC.TDC.LOT[51]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT53,frstpc.data.v1190.measurement.leadOrTrail[52],TPC.TDC.LOT[52]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT54,frstpc.data.v1190.measurement.leadOrTrail[53],TPC.TDC.LOT[53]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT55,frstpc.data.v1190.measurement.leadOrTrail[54],TPC.TDC.LOT[54]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT56,frstpc.data.v1190.measurement.leadOrTrail[55],TPC.TDC.LOT[55]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT57,frstpc.data.v1190.measurement.leadOrTrail[56],TPC.TDC.LOT[56]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT58,frstpc.data.v1190.measurement.leadOrTrail[57],TPC.TDC.LOT[57]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT59,frstpc.data.v1190.measurement.leadOrTrail[58],TPC.TDC.LOT[58]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT6,frstpc.data.v1190.measurement.leadOrTrail[5],TPC.TDC.LOT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT60,frstpc.data.v1190.measurement.leadOrTrail[59],TPC.TDC.LOT[59]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT61,frstpc.data.v1190.measurement.leadOrTrail[60],TPC.TDC.LOT[60]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT62,frstpc.data.v1190.measurement.leadOrTrail[61],TPC.TDC.LOT[61]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT63,frstpc.data.v1190.measurement.leadOrTrail[62],TPC.TDC.LOT[62]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT64,frstpc.data.v1190.measurement.leadOrTrail[63],TPC.TDC.LOT[63]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT65,frstpc.data.v1190.measurement.leadOrTrail[64],TPC.TDC.LOT[64]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT66,frstpc.data.v1190.measurement.leadOrTrail[65],TPC.TDC.LOT[65]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT67,frstpc.data.v1190.measurement.leadOrTrail[66],TPC.TDC.LOT[66]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT68,frstpc.data.v1190.measurement.leadOrTrail[67],TPC.TDC.LOT[67]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT69,frstpc.data.v1190.measurement.leadOrTrail[68],TPC.TDC.LOT[68]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT7,frstpc.data.v1190.measurement.leadOrTrail[6],TPC.TDC.LOT[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT70,frstpc.data.v1190.measurement.leadOrTrail[69],TPC.TDC.LOT[69]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT71,frstpc.data.v1190.measurement.leadOrTrail[70],TPC.TDC.LOT[70]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT72,frstpc.data.v1190.measurement.leadOrTrail[71],TPC.TDC.LOT[71]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT73,frstpc.data.v1190.measurement.leadOrTrail[72],TPC.TDC.LOT[72]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT74,frstpc.data.v1190.measurement.leadOrTrail[73],TPC.TDC.LOT[73]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT75,frstpc.data.v1190.measurement.leadOrTrail[74],TPC.TDC.LOT[74]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT76,frstpc.data.v1190.measurement.leadOrTrail[75],TPC.TDC.LOT[75]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT77,frstpc.data.v1190.measurement.leadOrTrail[76],TPC.TDC.LOT[76]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT78,frstpc.data.v1190.measurement.leadOrTrail[77],TPC.TDC.LOT[77]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT79,frstpc.data.v1190.measurement.leadOrTrail[78],TPC.TDC.LOT[78]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT8,frstpc.data.v1190.measurement.leadOrTrail[7],TPC.TDC.LOT[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT80,frstpc.data.v1190.measurement.leadOrTrail[79],TPC.TDC.LOT[79]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT81,frstpc.data.v1190.measurement.leadOrTrail[80],TPC.TDC.LOT[80]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT82,frstpc.data.v1190.measurement.leadOrTrail[81],TPC.TDC.LOT[81]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT83,frstpc.data.v1190.measurement.leadOrTrail[82],TPC.TDC.LOT[82]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT84,frstpc.data.v1190.measurement.leadOrTrail[83],TPC.TDC.LOT[83]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT85,frstpc.data.v1190.measurement.leadOrTrail[84],TPC.TDC.LOT[84]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT86,frstpc.data.v1190.measurement.leadOrTrail[85],TPC.TDC.LOT[85]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT87,frstpc.data.v1190.measurement.leadOrTrail[86],TPC.TDC.LOT[86]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT88,frstpc.data.v1190.measurement.leadOrTrail[87],TPC.TDC.LOT[87]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT89,frstpc.data.v1190.measurement.leadOrTrail[88],TPC.TDC.LOT[88]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT9,frstpc.data.v1190.measurement.leadOrTrail[8],TPC.TDC.LOT[8]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT90,frstpc.data.v1190.measurement.leadOrTrail[89],TPC.TDC.LOT[89]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT91,frstpc.data.v1190.measurement.leadOrTrail[90],TPC.TDC.LOT[90]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT92,frstpc.data.v1190.measurement.leadOrTrail[91],TPC.TDC.LOT[91]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT93,frstpc.data.v1190.measurement.leadOrTrail[92],TPC.TDC.LOT[92]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT94,frstpc.data.v1190.measurement.leadOrTrail[93],TPC.TDC.LOT[93]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT95,frstpc.data.v1190.measurement.leadOrTrail[94],TPC.TDC.LOT[94]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT96,frstpc.data.v1190.measurement.leadOrTrail[95],TPC.TDC.LOT[95]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT97,frstpc.data.v1190.measurement.leadOrTrail[96],TPC.TDC.LOT[96]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT98,frstpc.data.v1190.measurement.leadOrTrail[97],TPC.TDC.LOT[97]/*multi:*/[0]);
SIGNAL_MAPPING(DATA8,TPC_TDC_LOT99,frstpc.data.v1190.measurement.leadOrTrail[98],TPC.TDC.LOT[98]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T1,frstpc.data.v1190.measurement.data[0],TPC.TDC.T[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T10,frstpc.data.v1190.measurement.data[9],TPC.TDC.T[9]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T100,frstpc.data.v1190.measurement.data[99],TPC.TDC.T[99]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T101,frstpc.data.v1190.measurement.data[100],TPC.TDC.T[100]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T102,frstpc.data.v1190.measurement.data[101],TPC.TDC.T[101]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T103,frstpc.data.v1190.measurement.data[102],TPC.TDC.T[102]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T104,frstpc.data.v1190.measurement.data[103],TPC.TDC.T[103]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T105,frstpc.data.v1190.measurement.data[104],TPC.TDC.T[104]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T106,frstpc.data.v1190.measurement.data[105],TPC.TDC.T[105]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T107,frstpc.data.v1190.measurement.data[106],TPC.TDC.T[106]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T108,frstpc.data.v1190.measurement.data[107],TPC.TDC.T[107]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T109,frstpc.data.v1190.measurement.data[108],TPC.TDC.T[108]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T11,frstpc.data.v1190.measurement.data[10],TPC.TDC.T[10]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T110,frstpc.data.v1190.measurement.data[109],TPC.TDC.T[109]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T111,frstpc.data.v1190.measurement.data[110],TPC.TDC.T[110]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T112,frstpc.data.v1190.measurement.data[111],TPC.TDC.T[111]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T113,frstpc.data.v1190.measurement.data[112],TPC.TDC.T[112]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T114,frstpc.data.v1190.measurement.data[113],TPC.TDC.T[113]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T115,frstpc.data.v1190.measurement.data[114],TPC.TDC.T[114]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T116,frstpc.data.v1190.measurement.data[115],TPC.TDC.T[115]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T117,frstpc.data.v1190.measurement.data[116],TPC.TDC.T[116]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T118,frstpc.data.v1190.measurement.data[117],TPC.TDC.T[117]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T119,frstpc.data.v1190.measurement.data[118],TPC.TDC.T[118]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T12,frstpc.data.v1190.measurement.data[11],TPC.TDC.T[11]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T120,frstpc.data.v1190.measurement.data[119],TPC.TDC.T[119]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T121,frstpc.data.v1190.measurement.data[120],TPC.TDC.T[120]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T122,frstpc.data.v1190.measurement.data[121],TPC.TDC.T[121]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T123,frstpc.data.v1190.measurement.data[122],TPC.TDC.T[122]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T124,frstpc.data.v1190.measurement.data[123],TPC.TDC.T[123]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T125,frstpc.data.v1190.measurement.data[124],TPC.TDC.T[124]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T126,frstpc.data.v1190.measurement.data[125],TPC.TDC.T[125]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T127,frstpc.data.v1190.measurement.data[126],TPC.TDC.T[126]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T128,frstpc.data.v1190.measurement.data[127],TPC.TDC.T[127]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T13,frstpc.data.v1190.measurement.data[12],TPC.TDC.T[12]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T14,frstpc.data.v1190.measurement.data[13],TPC.TDC.T[13]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T15,frstpc.data.v1190.measurement.data[14],TPC.TDC.T[14]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T16,frstpc.data.v1190.measurement.data[15],TPC.TDC.T[15]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T17,frstpc.data.v1190.measurement.data[16],TPC.TDC.T[16]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T18,frstpc.data.v1190.measurement.data[17],TPC.TDC.T[17]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T19,frstpc.data.v1190.measurement.data[18],TPC.TDC.T[18]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T2,frstpc.data.v1190.measurement.data[1],TPC.TDC.T[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T20,frstpc.data.v1190.measurement.data[19],TPC.TDC.T[19]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T21,frstpc.data.v1190.measurement.data[20],TPC.TDC.T[20]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T22,frstpc.data.v1190.measurement.data[21],TPC.TDC.T[21]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T23,frstpc.data.v1190.measurement.data[22],TPC.TDC.T[22]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T24,frstpc.data.v1190.measurement.data[23],TPC.TDC.T[23]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T25,frstpc.data.v1190.measurement.data[24],TPC.TDC.T[24]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T26,frstpc.data.v1190.measurement.data[25],TPC.TDC.T[25]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T27,frstpc.data.v1190.measurement.data[26],TPC.TDC.T[26]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T28,frstpc.data.v1190.measurement.data[27],TPC.TDC.T[27]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T29,frstpc.data.v1190.measurement.data[28],TPC.TDC.T[28]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T3,frstpc.data.v1190.measurement.data[2],TPC.TDC.T[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T30,frstpc.data.v1190.measurement.data[29],TPC.TDC.T[29]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T31,frstpc.data.v1190.measurement.data[30],TPC.TDC.T[30]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T32,frstpc.data.v1190.measurement.data[31],TPC.TDC.T[31]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T33,frstpc.data.v1190.measurement.data[32],TPC.TDC.T[32]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T34,frstpc.data.v1190.measurement.data[33],TPC.TDC.T[33]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T35,frstpc.data.v1190.measurement.data[34],TPC.TDC.T[34]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T36,frstpc.data.v1190.measurement.data[35],TPC.TDC.T[35]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T37,frstpc.data.v1190.measurement.data[36],TPC.TDC.T[36]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T38,frstpc.data.v1190.measurement.data[37],TPC.TDC.T[37]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T39,frstpc.data.v1190.measurement.data[38],TPC.TDC.T[38]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T4,frstpc.data.v1190.measurement.data[3],TPC.TDC.T[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T40,frstpc.data.v1190.measurement.data[39],TPC.TDC.T[39]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T41,frstpc.data.v1190.measurement.data[40],TPC.TDC.T[40]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T42,frstpc.data.v1190.measurement.data[41],TPC.TDC.T[41]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T43,frstpc.data.v1190.measurement.data[42],TPC.TDC.T[42]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T44,frstpc.data.v1190.measurement.data[43],TPC.TDC.T[43]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T45,frstpc.data.v1190.measurement.data[44],TPC.TDC.T[44]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T46,frstpc.data.v1190.measurement.data[45],TPC.TDC.T[45]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T47,frstpc.data.v1190.measurement.data[46],TPC.TDC.T[46]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T48,frstpc.data.v1190.measurement.data[47],TPC.TDC.T[47]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T49,frstpc.data.v1190.measurement.data[48],TPC.TDC.T[48]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T5,frstpc.data.v1190.measurement.data[4],TPC.TDC.T[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T50,frstpc.data.v1190.measurement.data[49],TPC.TDC.T[49]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T51,frstpc.data.v1190.measurement.data[50],TPC.TDC.T[50]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T52,frstpc.data.v1190.measurement.data[51],TPC.TDC.T[51]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T53,frstpc.data.v1190.measurement.data[52],TPC.TDC.T[52]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T54,frstpc.data.v1190.measurement.data[53],TPC.TDC.T[53]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T55,frstpc.data.v1190.measurement.data[54],TPC.TDC.T[54]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T56,frstpc.data.v1190.measurement.data[55],TPC.TDC.T[55]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T57,frstpc.data.v1190.measurement.data[56],TPC.TDC.T[56]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T58,frstpc.data.v1190.measurement.data[57],TPC.TDC.T[57]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T59,frstpc.data.v1190.measurement.data[58],TPC.TDC.T[58]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T6,frstpc.data.v1190.measurement.data[5],TPC.TDC.T[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T60,frstpc.data.v1190.measurement.data[59],TPC.TDC.T[59]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T61,frstpc.data.v1190.measurement.data[60],TPC.TDC.T[60]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T62,frstpc.data.v1190.measurement.data[61],TPC.TDC.T[61]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T63,frstpc.data.v1190.measurement.data[62],TPC.TDC.T[62]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T64,frstpc.data.v1190.measurement.data[63],TPC.TDC.T[63]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T65,frstpc.data.v1190.measurement.data[64],TPC.TDC.T[64]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T66,frstpc.data.v1190.measurement.data[65],TPC.TDC.T[65]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T67,frstpc.data.v1190.measurement.data[66],TPC.TDC.T[66]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T68,frstpc.data.v1190.measurement.data[67],TPC.TDC.T[67]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T69,frstpc.data.v1190.measurement.data[68],TPC.TDC.T[68]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T7,frstpc.data.v1190.measurement.data[6],TPC.TDC.T[6]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T70,frstpc.data.v1190.measurement.data[69],TPC.TDC.T[69]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T71,frstpc.data.v1190.measurement.data[70],TPC.TDC.T[70]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T72,frstpc.data.v1190.measurement.data[71],TPC.TDC.T[71]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T73,frstpc.data.v1190.measurement.data[72],TPC.TDC.T[72]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T74,frstpc.data.v1190.measurement.data[73],TPC.TDC.T[73]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T75,frstpc.data.v1190.measurement.data[74],TPC.TDC.T[74]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T76,frstpc.data.v1190.measurement.data[75],TPC.TDC.T[75]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T77,frstpc.data.v1190.measurement.data[76],TPC.TDC.T[76]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T78,frstpc.data.v1190.measurement.data[77],TPC.TDC.T[77]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T79,frstpc.data.v1190.measurement.data[78],TPC.TDC.T[78]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T8,frstpc.data.v1190.measurement.data[7],TPC.TDC.T[7]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T80,frstpc.data.v1190.measurement.data[79],TPC.TDC.T[79]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T81,frstpc.data.v1190.measurement.data[80],TPC.TDC.T[80]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T82,frstpc.data.v1190.measurement.data[81],TPC.TDC.T[81]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T83,frstpc.data.v1190.measurement.data[82],TPC.TDC.T[82]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T84,frstpc.data.v1190.measurement.data[83],TPC.TDC.T[83]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T85,frstpc.data.v1190.measurement.data[84],TPC.TDC.T[84]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T86,frstpc.data.v1190.measurement.data[85],TPC.TDC.T[85]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T87,frstpc.data.v1190.measurement.data[86],TPC.TDC.T[86]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T88,frstpc.data.v1190.measurement.data[87],TPC.TDC.T[87]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T89,frstpc.data.v1190.measurement.data[88],TPC.TDC.T[88]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T9,frstpc.data.v1190.measurement.data[8],TPC.TDC.T[8]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T90,frstpc.data.v1190.measurement.data[89],TPC.TDC.T[89]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T91,frstpc.data.v1190.measurement.data[90],TPC.TDC.T[90]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T92,frstpc.data.v1190.measurement.data[91],TPC.TDC.T[91]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T93,frstpc.data.v1190.measurement.data[92],TPC.TDC.T[92]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T94,frstpc.data.v1190.measurement.data[93],TPC.TDC.T[93]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T95,frstpc.data.v1190.measurement.data[94],TPC.TDC.T[94]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T96,frstpc.data.v1190.measurement.data[95],TPC.TDC.T[95]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T97,frstpc.data.v1190.measurement.data[96],TPC.TDC.T[96]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T98,frstpc.data.v1190.measurement.data[97],TPC.TDC.T[97]/*multi:*/[0]);
SIGNAL_MAPPING(DATA24,TPC_TDC_T99,frstpc.data.v1190.measurement.data[98],TPC.TDC.T[98]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,WR_ID,frstpat.wr.subsystem_id,WR.ID);
SIGNAL_MAPPING(DATA16,WR_T1,frstpat.wr.t1,WR.T[0]);
SIGNAL_MAPPING(DATA16,WR_T2,frstpat.wr.t2,WR.T[1]);
SIGNAL_MAPPING(DATA16,WR_T3,frstpat.wr.t3,WR.T[2]);
SIGNAL_MAPPING(DATA16,WR_T4,frstpat.wr.t4,WR.T[3]);

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 0, "gen_s100/reparse.uce" },
  { 3, 0, "<built-in>" },
  { 4, 0, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 0, "<command-line>" },
  { 7, 1, "gen_s100/reparse.uce" },
  { 8, 12, "gen_s100/reparse.uce" },
  { 1311, 1323, "gen_s100/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/


/** BEGIN_ACCOUNT_IDS **************************************************
 *
 * Structure and identifier for raw data items.
 *
 * Do not edit - automatically generated.
 */

account_id _account_ids[] =
{ 
  { 0, "BAD_EVENT", "be" },
  { 1, "BAD_EVENT", "be" },
  { 2, "BARRIER", "barrier" },
  { 3, "BARRIER", "barrier" },
  { 4, "DUMMY", "no" },
  { 5, "DUMMY", "no" },
  { 6, "ERR_WORD_SIX", "err" },
  { 7, "ERR_WORD_SIX", "err" },
  { 8, "FATIMA_VME_SCALERS", "sc_header" },
  { 9, "FATIMA_VME_SCALERS", "sc_data" },
  { 10, "FATIMA_VME_SCALERS", "scaler_trailer" },
  { 11, "FATIMA_VME_SCALERS", "sc_header" },
  { 12, "FEBEX_EVENT", "sumchannel" },
  { 13, "FEBEX_EVENT", "channel_size" },
  { 14, "FEBEX_EVENT", "event_timestamp_hi" },
  { 15, "FEBEX_EVENT", "event_timestamp_lo" },
  { 16, "FEBEX_EVENT", "hp" },
  { 17, "FEBEX_EVENT", "deadbeef" },
  { 18, "FEBEX_EVENT", "channelids" },
  { 19, "FEBEX_EVENT", "channel_ts" },
  { 20, "FEBEX_EVENT", "chan_enrgy" },
  { 21, "FEBEX_EVENT", "future_use" },
  { 22, "FEBEX_EVENT", "sumchannel" },
  { 23, "TRACE", "header" },
  { 24, "TRACE", "tracesize" },
  { 25, "TRACE", "tracehead" },
  { 26, "TRACE", "channel_trace" },
  { 27, "TRACE", "trace_trailer" },
  { 28, "TRACE", "header" },
  { 29, "FEBEX_EVENT_TRACES", "sumchannel" },
  { 30, "FEBEX_EVENT_TRACES", "channel_size" },
  { 31, "FEBEX_EVENT_TRACES", "event_timestamp_hi" },
  { 32, "FEBEX_EVENT_TRACES", "event_timestamp_lo" },
  { 33, "FEBEX_EVENT_TRACES", "hp" },
  { 34, "FEBEX_EVENT_TRACES", "deadbeef" },
  { 35, "FEBEX_EVENT_TRACES", "channelids" },
  { 36, "FEBEX_EVENT_TRACES", "channel_ts" },
  { 37, "FEBEX_EVENT_TRACES", "chan_enrgy" },
  { 38, "FEBEX_EVENT_TRACES", "future_use" },
  { 39, "FEBEX_EVENT_TRACES", "dummy" },
  { 40, "FEBEX_EVENT_TRACES", "sumchannel" },
  { 41, "FEBEX_PADDING", "pads_data" },
  { 42, "FEBEX_PADDING", "pads_data" },
  { 43, "VME_CAEN_V830", "header" },
  { 44, "VME_CAEN_V830", "ch_data" },
  { 45, "VME_CAEN_V830", "header" },
  { 46, "ZERO_FILLER", "filler" },
  { 47, "ZERO_FILLER", "filler" },
  { 48, "VME_CAEN_V7X5", "header" },
  { 49, "VME_CAEN_V7X5", "ch_data" },
  { 50, "VME_CAEN_V7X5", "eob" },
  { 51, "VME_CAEN_V7X5", "eob2" },
  { 52, "VME_CAEN_V7X5", "header" },
  { 53, "TDC_HEADER", "tdc_header" },
  { 54, "TDC_HEADER", "tdc_header" },
  { 55, "TDC_DATA_V1290", "tdc_data" },
  { 56, "TDC_DATA_V1290", "tdc_data" },
  { 57, "TDC_ERROR", "tdc_err" },
  { 58, "TDC_ERROR", "tdc_err" },
  { 59, "TDC_TRAILER", "tdc_trailer" },
  { 60, "TDC_TRAILER", "tdc_trailer" },
  { 61, "VME_CAEN_V1290_N", "header" },
  { 62, "VME_CAEN_V1290_N", "ext_time_tag" },
  { 63, "VME_CAEN_V1290_N", "trailer" },
  { 64, "VME_CAEN_V1290_N", "header" },
  { 65, "MAIN_CRATE_DATA", "aaahhh" },
  { 66, "MAIN_CRATE_DATA", "exxxxx" },
  { 67, "MAIN_CRATE_DATA", "eodb" },
  { 68, "SPILL_OFF", "off1" },
  { 69, "SPILL_OFF", "off2" },
  { 70, "SPILL_OFF", "off3" },
  { 71, "SPILL_OFF", "off1" },
  { 72, "SPILL_ON", "on" },
  { 73, "SPILL_ON", "on" },
  { 74, "TAMEX4_EPOCH_DATA", "data" },
  { 75, "TAMEX4_EPOCH_DATA", "data" },
  { 76, "TAMEX4_HEADER", "trigger_window" },
  { 77, "TAMEX4_HEADER", "trigger_window" },
  { 78, "TAMEX4_PADDING", "padding" },
  { 79, "TAMEX4_PADDING", "padding" },
  { 80, "TAMEX4_TIME_DATA", "data" },
  { 81, "TAMEX4_TIME_DATA", "data" },
  { 82, "TAMEX4_SFP", "indicator" },
  { 83, "TAMEX4_SFP", "data_size" },
  { 84, "TAMEX4_SFP", "tdc_header" },
  { 85, "TAMEX4_SFP", "error_bits" },
  { 86, "TAMEX4_SFP", "trailer" },
  { 87, "TAMEX4_SFP", "indicator" },
  { 88, "TDC_DATA_V1190", "tdc_data" },
  { 89, "TDC_DATA_V1190", "tdc_data" },
  { 90, "TIMESTAMP_WHITERABBIT", "header" },
  { 91, "TIMESTAMP_WHITERABBIT", "d1" },
  { 92, "TIMESTAMP_WHITERABBIT", "d2" },
  { 93, "TIMESTAMP_WHITERABBIT", "d3" },
  { 94, "TIMESTAMP_WHITERABBIT", "d4" },
  { 95, "TIMESTAMP_WHITERABBIT", "header" },
  { 96, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 97, "TIMESTAMP_WHITERABBIT_EXTENDED", "d1" },
  { 98, "TIMESTAMP_WHITERABBIT_EXTENDED", "d2" },
  { 99, "TIMESTAMP_WHITERABBIT_EXTENDED", "d3" },
  { 100, "TIMESTAMP_WHITERABBIT_EXTENDED", "d4" },
  { 101, "TIMESTAMP_WHITERABBIT_EXTENDED", "header" },
  { 102, "TPAT_CRATE_DATA", "w1" },
  { 103, "TPAT_CRATE_DATA", "w2" },
  { 104, "TPAT_CRATE_DATA", "w3" },
  { 105, "TPAT_CRATE_DATA", "trigger_pattern" },
  { 106, "TPAT_CRATE_DATA", "w1" },
  { 107, "VME_CAEN_V1190_N", "header" },
  { 108, "VME_CAEN_V1190_N", "second1" },
  { 109, "VME_CAEN_V1190_N", "real_header" },
  { 110, "VME_CAEN_V1190_N", "ext_time_tag" },
  { 111, "VME_CAEN_V1190_N", "trailer" },
  { 112, "VME_CAEN_V1190_N", "eob" },
  { 113, "VME_CAEN_V1190_N", "header" },
  { 114, "TPC_CRATE_DATA", "aaahhh" },
  { 115, "TPC_CRATE_DATA", "exxxxx" },
  { 116, "TRIG3EVENT", "trig3" },
  { 117, "TRIG3EVENT", "trig3" },
  { 118, "VME_CAEN_V1751", "board_agg_size" },
  { 119, "VME_CAEN_V1751", "board_details" },
  { 120, "VME_CAEN_V1751", "board_agg_counter" },
  { 121, "VME_CAEN_V1751", "board_agg_timetag" },
  { 122, "VME_CAEN_V1751", "channel_agg_size" },
  { 123, "VME_CAEN_V1751", "format_one" },
  { 124, "VME_CAEN_V1751", "format_two" },
  { 125, "VME_CAEN_V1751", "channel_time_tag" },
  { 126, "VME_CAEN_V1751", "extras" },
  { 127, "VME_CAEN_V1751", "extras" },
  { 128, "VME_CAEN_V1751", "extras" },
  { 129, "VME_CAEN_V1751", "extras" },
  { 130, "VME_CAEN_V1751", "extras" },
  { 131, "VME_CAEN_V1751", "channel_time_tag" },
  { 132, "VME_CAEN_V1751", "qdata" },
  { 133, "VME_CAEN_V1751", "board_agg_size" },
  { 134, "WR_MULTI", "hi" },
  { 135, "WR_MULTI", "lo" },
  { 136, "WR_MULTI", "hi" },
  { 137, "bgo_tamex_subevent", "be" },
  { 138, "bm_subev", "headS2" },
  { 139, "bm_subev", "hit" },
  { 140, "bm_subev", "headS4" },
  { 141, "bm_subev", "hit" },
  { 142, "bm_subev", "trailer" },
  { 143, "frs_tpc_subev", "be" },
};

#define NUM_ACCOUNT_IDS  144

/** END_ACCOUNT_IDS ***************************************************/

